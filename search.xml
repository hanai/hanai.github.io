<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>用 canvas 转换图片格式</title>
    <url>/2017/08/convert-image-type-using-canvas.html</url>
    <content><![CDATA[步骤
input 输入文件
FileReader 将文件读作 DataURL
img 元素载入 URI
使用 CanvasRenderingContext2D.drawImage() 在 canvas 中绘制指定图片
使用 HTMLCanvasElement.toDataURL() 将图片转换成 data URI
a 元素 download 下载图片

代码&lt;input id&#x3D;&quot;file-input&quot; type&#x3D;&quot;file&quot; accept&#x3D;&quot;image&#x2F;*&quot;&gt;

&lt;script&gt;
  var doc &#x3D; document;

  var input &#x3D; doc.getElementById(&#39;file-input&#39;);

  function exportImageFileFromCanvas(canvas) &#123;
    var dataURL &#x3D; canvas.toDataURL(&#39;image&#x2F;webp&#39;, .8);
    var a &#x3D; doc.createElement(&#39;a&#39;);
    a.href &#x3D; dataURL;
    a.setAttribute(&#39;download&#39;, &#39;img.webp&#39;);
    doc.body.appendChild(a);
    a.click();
    doc.body.removeChild(a);
    a &#x3D; null;
  &#125;

  function url2canvas(url) &#123;
    return new Promise((resolve, reject) &#x3D;&gt; &#123;
      const image &#x3D; document.createElement(&#39;img&#39;);
      const canvas &#x3D; document.createElement(&#39;canvas&#39;);
      const ctx &#x3D; canvas.getContext(&#39;2d&#39;);

      image.onload &#x3D; event &#x3D;&gt; &#123;
        const img &#x3D; event.target;
        const height &#x3D; image.naturalHeight;
        const width &#x3D; image.naturalWidth;
        canvas.height &#x3D; height;
        canvas.width &#x3D; width;
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas);
      &#125;;
      image.onerror &#x3D; err &#x3D;&gt; &#123;
        reject(err);
      &#125;;
      image.src &#x3D; url;
    &#125;);

  &#125;

  function readFileAsDataURL(file) &#123;
    return new Promise((resolve, reject) &#x3D;&gt; &#123;
      const fr &#x3D; new FileReader();
      fr.onload &#x3D; event &#x3D;&gt; &#123;
        resolve(event.target.result);
      &#125;;
      fr.onerror &#x3D; err &#x3D;&gt; &#123;
        reject(err);
      &#125;
      fr.readAsDataURL(file);
    &#125;);
  &#125;

  function handleFileChange(e) &#123;
    var files &#x3D; e.target.files;
    if (!files || !files.length) return;
    var file &#x3D; e.target.files[0];

    readFileAsDataURL(file)
      .then(url2canvas)
      .then(exportImageFileFromCanvas);
  &#125;

  input.addEventListener(&#39;change&#39;, handleFileChange);
&lt;&#x2F;script&gt;
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 Node 包国内镜像</title>
    <url>/2017/08/domestic-mirror-for-common-node-package.html</url>
    <content><![CDATA[# .bashrc
export SASS_BINARY_SITE&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass&quot;
export ELECTRON_MIRROR&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;&quot;
export PHANTOMJS_CDNURL&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;phantomjs&quot;
export CHROMEDRIVER_CDNURL&#x3D;&quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;chromedriver&quot;

更多：Taobao Mirrors
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>npm</tag>
        <tag>mirror</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 3D 实现：三维投影</title>
    <url>/2017/08/js-3d-implement-3d-project.html</url>
    <content><![CDATA[代码: https://github.com/hanai/js-d3
坐标系
渲染投影将三维空间中的坐标 &lt;x, y, z&gt; 投影到平面上，得到投影的坐标 &lt;x&#39;, y&#39;&gt;。
渲染函数遍历每一个要渲染的对象，遍历对象的各个平面，对平面各个顶点由函数 project() 计算出投影在平面上的二维坐标，依次连接平面各顶点。
function render(objects, ctx, dx, dy) &#123;
  &#x2F;&#x2F; Clear the previous frame
  ctx.clearRect(0, 0, 2 * dx, 2 * dy);

  &#x2F;&#x2F; for each object
  objects.forEach(object &#x3D;&gt; &#123;
    &#x2F;&#x2F; for each face
    object.faces.forEach(face &#x3D;&gt; &#123;
      face.forEach((vertex, vertexIdx) &#x3D;&gt; &#123;
        var P &#x3D; project(vertex);

        if (vertexIdx &#x3D;&#x3D;&#x3D; 0) &#123;
          &#x2F;&#x2F; draw the first vertex
          ctx.beginPath();
          ctx.moveTo(P.x + dx, -P.y + dy);
        &#125; else &#123;
          &#x2F;&#x2F; draw the other vertices
          ctx.lineTo(P.x + dx, -P.y + dy);
        &#125;
      &#125;);

      &#x2F;&#x2F; close the path and draw the face
      ctx.closePath();
      ctx.stroke();
      ctx.fill();
    &#125;);
  &#125;);
&#125;

正视图function project(M) &#123;
    return new Vertex2D(M.x, M.z);
&#125;

透视图

由三维空间中的顶点 M(x, y, z)，我们希望的到平面上的投影 M&#39; 的坐标 (x&#39;, z&#39;)。

如图，由截线定理可得 x&#39; = d / y * x，故：
function project(M) &#123;
    &#x2F;&#x2F; Distance between the camera and the plane
    var d &#x3D; 200;
    var r &#x3D; d &#x2F; M.y;

    return new Vertex2D(r * M.x, r * M.z);
&#125;

其它旋转鼠标旋转立方体
绑定事件 mousedown 与 mousemove，由 event.clientX 与 event.clientY 可得 Δx, Δy，换算得水平旋转角度 theta 与竖直旋转角度 phi。

参考
https://www.wikiwand.com/en/3D_projection
Building a 3D Engine with JavaScript

]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>3D</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Underscore 源码学习</title>
    <url>/2017/08/learning-underscore-source-code-1.html</url>
    <content><![CDATA[Underscore.js 1.8.3
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L6

(function() &#123;
&#125;.call(this));

立即执行函数，避免污染外部环境。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L12

var root &#x3D; this;

获取根对象，self 或 global。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L18

var ArrayProto &#x3D; Array.prototype, ObjProto &#x3D; Object.prototype, FuncProto &#x3D; Function.prototype;

压缩变量名长度，节省字节。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L21

var
  push             &#x3D; ArrayProto.push,
  slice            &#x3D; ArrayProto.slice,
  toString         &#x3D; ObjProto.toString,
  hasOwnProperty   &#x3D; ObjProto.hasOwnProperty;

为一些方法创建引用，方便访问。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L29

var
  nativeIsArray      &#x3D; Array.isArray,
  nativeKeys         &#x3D; Object.keys,
  nativeBind         &#x3D; FuncProto.bind,
  nativeCreate       &#x3D; Object.create;

ES5 中原生支持的一些方法。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L36

var Ctor &#x3D; function()&#123;&#125;;

一个空的构造函数。



&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L39

var _ &#x3D; function(obj) &#123;
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped &#x3D; obj;
&#125;;

创建 Underscore 对象。
传入 obj 是 _ 的实例时返回 obj 本身。_ 不是作为构造函数调用时，使用 new _(obj) 生成 _ 的实例。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L48

if (typeof exports !&#x3D;&#x3D; &#39;undefined&#39;) &#123;
  if (typeof module !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; module.exports) &#123;
    exports &#x3D; module.exports &#x3D; _;
  &#125;
  exports._ &#x3D; _;
&#125; else &#123;
  root._ &#x3D; _;
&#125;

Node.js 环境中导出 _，浏览器环境中将 _ 添加到根对象。

&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L60

&#x2F;&#x2F; Internal function that returns an efficient (for current engines) version
&#x2F;&#x2F; of the passed-in callback, to be repeatedly applied in other Underscore
&#x2F;&#x2F; functions.
var optimizeCb &#x3D; function(func, context, argCount) &#123;
  if (context &#x3D;&#x3D;&#x3D; void 0) return func;
  switch (argCount &#x3D;&#x3D; null ? 3 : argCount) &#123;
    case 1: return function(value) &#123;
      return func.call(context, value);
    &#125;;
    case 2: return function(value, other) &#123;
      return func.call(context, value, other);
    &#125;;
    case 3: return function(value, index, collection) &#123;
      return func.call(context, value, index, collection);
    &#125;;
    case 4: return function(accumulator, value, index, collection) &#123;
      return func.call(context, accumulator, value, index, collection);
    &#125;;
  &#125;
  return function() &#123;
    return func.apply(context, arguments);
  &#125;;
&#125;;

用来返回高效的（对当前引擎而言）回调函数的内部函数。
回调函数无 context 时直接返回原 func。
js引擎访问 arguments 性能较差，且 call 比 apply 快（apply() vs call()），所以在知道参数列表长度的时候，直接用 call 会更好。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L84

&#x2F;&#x2F; A mostly-internal function to generate callbacks that can be applied
&#x2F;&#x2F; to each element in a collection, returning the desired result — either
&#x2F;&#x2F; identity, an arbitrary callback, a property matcher, or a property accessor.
var cb &#x3D; function(value, context, argCount) &#123;
  if (value &#x3D;&#x3D; null) return _.identity;
  if (_.isFunction(value)) return optimizeCb(value, context, argCount);
  if (_.isObject(value)) return _.matcher(value);
  return _.property(value);
&#125;;

生成可应用于集合中每一个元素的回调函数的内部函数。返回的结果：identity，任意回调，属性匹配器或属性访问器。
未传入 value 时返回 identity；value 是函数时返回回调函数；value 是对象时返回属性匹配器；其他情况返回属性访问器。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L93

_.iteratee &#x3D; function(value, context) &#123;
  return cb(value, context, Infinity);
&#125;;

返回一个参数长度不确定的迭代器。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L97

&#x2F;&#x2F; An internal function for creating assigner functions.
var createAssigner &#x3D; function(keysFunc, undefinedOnly) &#123;
  return function(obj) &#123;
    var length &#x3D; arguments.length;
    if (length &lt; 2 || obj &#x3D;&#x3D; null) return obj;
    for (var index &#x3D; 1; index &lt; length; index++) &#123;
      var source &#x3D; arguments[index],
          keys &#x3D; keysFunc(source),
          l &#x3D; keys.length;
      for (var i &#x3D; 0; i &lt; l; i++) &#123;
        var key &#x3D; keys[i];
        if (!undefinedOnly || obj[key] &#x3D;&#x3D;&#x3D; void 0) obj[key] &#x3D; source[key];
      &#125;
    &#125;
    return obj;
  &#125;;
&#125;;

创建一个赋值器。传入一个用来获取对象所有 key 的函数 keysFunc。与决定是否只对 undefined 属性赋值的布尔值 undefinedOnly。
赋值器第一个参数作为 obj，从第 2 个参数开始，获取每个参数的 keys，遍历 keys 为 key，如果 obj 属性 key 的值为 undefined，或创建此赋值器的 undefinedOnly 为 false，则对 obj 的 key 属性赋值。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L115

&#x2F;&#x2F; An internal function for creating a new object that inherits from another.
var baseCreate &#x3D; function(prototype) &#123;
  if (!_.isObject(prototype)) return &#123;&#125;;
  if (nativeCreate) return nativeCreate(prototype);
  Ctor.prototype &#x3D; prototype;
  var result &#x3D; new Ctor;
  Ctor.prototype &#x3D; null;
  return result;
&#125;;

用来创建继承另一个对象的对象的内部函数。
若传入 prototype 不是对象，则返回对象 &#123;&#125;；
若 Object.create 存在，则用 Object.create 创建新对象；
若 Object.create 不存在，则对空的构造函数 Ctor 的 prototype 赋值，用 Ctor 创建新的对象。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L125

var property &#x3D; function(key) &#123;
  return function(obj) &#123;
    return obj &#x3D;&#x3D; null ? void 0 : obj[key];
  &#125;;
&#125;;

生成用来获取对象指定 key 属性的值的函数。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L131

&#x2F;&#x2F; Helper for collection methods to determine whether a collection
&#x2F;&#x2F; should be iterated as an array or as an object
&#x2F;&#x2F; Related: http:&#x2F;&#x2F;people.mozilla.org&#x2F;~jorendorff&#x2F;es6-draft.html#sec-tolength
&#x2F;&#x2F; Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
var MAX_ARRAY_INDEX &#x3D; Math.pow(2, 53) - 1;
var getLength &#x3D; property(&#39;length&#39;);
var isArrayLike &#x3D; function(collection) &#123;
  var length &#x3D; getLength(collection);
  return typeof length &#x3D;&#x3D; &#39;number&#39; &amp;&amp; length &gt;&#x3D; 0 &amp;&amp; length &lt;&#x3D; MAX_ARRAY_INDEX;
&#125;;

判断一个 collection 是要作为数组还是对象遍历的方法。当 collection 有 length 属性，且 length 属性的值为数字时作为数组遍历。

Collection 相关函数
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L145

&#x2F;&#x2F; The cornerstone, an &#96;each&#96; implementation, aka &#96;forEach&#96;.
&#x2F;&#x2F; Handles raw objects in addition to array-likes. Treats all
&#x2F;&#x2F; sparse array-likes as if they were dense.
_.each &#x3D; _.forEach &#x3D; function(obj, iteratee, context) &#123;
  iteratee &#x3D; optimizeCb(iteratee, context);
  var i, length;
  if (isArrayLike(obj)) &#123;
    for (i &#x3D; 0, length &#x3D; obj.length; i &lt; length; i++) &#123;
      iteratee(obj[i], i, obj);
    &#125;
  &#125; else &#123;
    var keys &#x3D; _.keys(obj);
    for (i &#x3D; 0, length &#x3D; keys.length; i &lt; length; i++) &#123;
      iteratee(obj[keys[i]], keys[i], obj);
    &#125;
  &#125;
  return obj;
&#125;;

each, forEach 实现。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L165

_.map &#x3D; _.collect &#x3D; function(obj, iteratee, context) &#123;
  iteratee &#x3D; cb(iteratee, context);
  var keys &#x3D; !isArrayLike(obj) &amp;&amp; _.keys(obj),
      length &#x3D; (keys || obj).length,
      results &#x3D; Array(length);
  for (var index &#x3D; 0; index &lt; length; index++) &#123;
    var currentKey &#x3D; keys ? keys[index] : index;
    results[index] &#x3D; iteratee(obj[currentKey], currentKey, obj);
  &#125;
  return results;
&#125;;

map 实现。results = Array(length) 生成长度符合结果的空数组。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L177

&#x2F;&#x2F; Create a reducing function iterating left or right.
function createReduce(dir) &#123;
  &#x2F;&#x2F; Optimized iterator function as using arguments.length
  &#x2F;&#x2F; in the main function will deoptimize the, see #1991.
  function iterator(obj, iteratee, memo, keys, index, length) &#123;
    for (; index &gt;&#x3D; 0 &amp;&amp; index &lt; length; index +&#x3D; dir) &#123;
      var currentKey &#x3D; keys ? keys[index] : index;
      memo &#x3D; iteratee(memo, obj[currentKey], currentKey, obj);
    &#125;
    return memo;
  &#125;

  return function(obj, iteratee, memo, context) &#123;
    iteratee &#x3D; optimizeCb(iteratee, context, 4);
    var keys &#x3D; !isArrayLike(obj) &amp;&amp; _.keys(obj),
        length &#x3D; (keys || obj).length,
        index &#x3D; dir &gt; 0 ? 0 : length - 1;
    &#x2F;&#x2F; Determine the initial value if none is provided.
    if (arguments.length &lt; 3) &#123;
      memo &#x3D; obj[keys ? keys[index] : index];
      index +&#x3D; dir;
    &#125;
    return iterator(obj, iteratee, memo, keys, index, length);
  &#125;;
&#125;

使用 createReduce 来创建 reduce 的方法。接受 dir 作为生成的 reduce 的遍历的方向。没有初始值 memo 时采用第一位或最后一位值作为初始值。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;jashkenas&#x2F;underscore&#x2F;blob&#x2F;1.8.3&#x2F;underscore.js#L205

_.reduce &#x3D; _.foldl &#x3D; _.inject &#x3D; createReduce(1);

用 createReduce 生成 reduce 方法。
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title>M3U8 流媒体文件播放</title>
    <url>/2017/08/play-m3u8-streaming-media-file.html</url>
    <content><![CDATA[M3U8M3U8 是 Unicode 版本的 M3U，用 UTF-8 编码。
M3U 和 M3U8 文件都是苹果公司使用的 HTTP Live Streaming (HLS) 格式的基础，这种格式可以在 iPhone 和 Macbook 等设备播放。
HLSHTTP Live Streaming (HLS) 是一个由苹果公司提出的基于 HTTP 的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8) playlist 文件，用于寻找可用的媒体流。
HLS 只请求基本的 HTTP 报文，与实时传输协议 (RTP) 不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。
由于 Android 和 iOS 原生支持 HLS，HLS 已成为移动设备流媒体的事实标准。有很多无关平台的原因来推荐这个格式：

支持（客户端驱动）自适应比特率选择
通过标准的 HTTP 端口传输
简单、基于文本的 manifest 格式
不需要专有流服务器

然而除了 Safari，主流的桌面浏览器都不支持 HLS。这使得 web 开发人员要维护多个格式的同一视频文件，或者放弃使用 html 的 video 来提供最好的桌面浏览体验。
在这里，我们在支持 Media Source Extensions 的浏览器使用 polyfill 来使用 HLS。
Media Source ExtensionsMedia Source Extensions (MSE) 为支持无插件的基于 Web 的流媒体提供功能。使用 MSE，流媒体可以通过 JavaScript 创建，并用 &lt;audio&gt; 和 &lt;video&gt; 元素播放。
播放方法采用 videojs + videojs-contrib-hls。


Wikipedia: M3U
Wikipedia: HTTP_Live_Streaming
Apple: HLS
MDN: Media Source Extensions API
videojs-contrib-hls

]]></content>
      <tags>
        <tag>m3u8</tag>
        <tag>media</tag>
        <tag>player</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative: 根据平台应用不同的样式</title>
    <url>/2017/08/react-native-apply-different-style-according-to-platform.html</url>
    <content><![CDATA[对 StyleSheet.create 方法进行修改
&#x2F;* from js&#x2F;common&#x2F;F8StyleSheet.js *&#x2F;

import &#123;StyleSheet, Platform&#125; from &#39;react-native&#39;;

export function create(styles) &#123;
  const platformStyles &#x3D; &#123;&#125;;
  Object.keys(styles).forEach((name) &#x3D;&gt; &#123;
    let &#123;ios, android, ...style&#125; &#x3D; &#123;...styles[name]&#125;;
    if (ios &amp;&amp; Platform.OS &#x3D;&#x3D;&#x3D; &#39;ios&#39;) &#123;
      style &#x3D; &#123;...style, ...ios&#125;;
    &#125;
    if (android &amp;&amp; Platform.OS &#x3D;&#x3D;&#x3D; &#39;android&#39;) &#123;
      style &#x3D; &#123;...style, ...android&#125;;
    &#125;
    platformStyles[name] &#x3D; style;
  &#125;);
  return StyleSheet.create(platformStyles);
&#125;

使用示例：
&#x2F;* from js&#x2F;common&#x2F;F8SegmentedControl.js *&#x2F;
var styles &#x3D; F8StyleSheet.create(&#123;
  container: &#123;
    flexDirection: &#39;row&#39;,
    backgroundColor: &#39;transparent&#39;,
    ios: &#123;
      paddingBottom: 6,
      justifyContent: &#39;center&#39;,
      alignItems: &#39;center&#39;,
    &#125;,
    android: &#123;
      paddingLeft: 60,
    &#125;,
  &#125;,
  button: &#123;
    borderColor: &#39;transparent&#39;,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
    backgroundColor: &#39;transparent&#39;,
    ios: &#123;
      height: HEIGHT,
      paddingHorizontal: 20,
      borderRadius: HEIGHT &#x2F; 2,
      borderWidth: 1,
    &#125;,
    android: &#123;
      paddingBottom: 6,
      paddingHorizontal: 10,
      borderBottomWidth: 3,
      marginRight: 10,
    &#125;,
  &#125;,
  label: &#123;
    letterSpacing: 1,
    fontSize: 12,
    color: &#39;white&#39;,
  &#125;,
  deselectedLabel: &#123;
    color: &#39;rgba(255, 255, 255, 0.7)&#39;,
  &#125;,
&#125;);


参考

F8App

]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>SCSS Mixins</title>
    <url>/2017/08/scss-mixins.html</url>
    <content><![CDATA[@mixin retina &#123;
  @media
    only screen and (-webkit-min-device-pixel-ratio: 2),
    only screen and (min--moz-device-pixel-ratio: 2),
    only screen and (-o-min-device-pixel-ratio: 2&#x2F;1),
    only screen and (min-device-pixel-ratio: 2),
    only screen and (min-resolution: 192dpi),
    only screen and (min-resolution: 2dppx) &#123;
    @content;
  &#125;
&#125;

@mixin print &#123;
  @media print &#123;
    @content;
  &#125;
&#125;
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js cluster 浅尝</title>
    <url>/2017/08/shallow-taste-nodejs-cluster.html</url>
    <content><![CDATA[const cluster &#x3D; require(&#39;cluster&#39;)
const http &#x3D; require(&#39;http&#39;)
const numCPUs &#x3D; require(&#39;os&#39;).cpus().length

const rssWarn &#x3D; (50 * 1024 * 1024),
  heapWarn &#x3D; (50 * 1024 * 1024)

const workers &#x3D; &#123;&#125;

if (cluster.isMaster) &#123;
  for (let i &#x3D; 0; i &lt; numCPUs; i++) &#123;
    createWorker()
  &#125;

  setInterval(() &#x3D;&gt; &#123;
    const time &#x3D; Date.now()
    for (pid in workers) &#123;
      if (workers.hasOwnProperty(pid) &amp;&amp;
        workers[pid].lastCb + 5000 &lt; time) &#123;
        console.log(&#39;Long runing worker &#39; + pid + &#39; killed&#39;)
        workers[pid].worker.kill()
        delete workers[pid]
        createWorker()
      &#125;
    &#125;
  &#125;, 1000)
&#125; else &#123;
  http.Server((req, res) &#x3D;&gt; &#123;
    if (Math.floor(Math.random() * 200) &#x3D;&#x3D;&#x3D; 4) &#123;
      console.log(&#96;Stopped $&#123;process.pid&#125; from ever finishing&#96;)
      while (true) &#123;
        continue
      &#125;
    &#125;
    res.writeHead(200)
    res.end(&#96;hello world from $&#123;process.pid&#125;\n&#96;)
  &#125;).listen(8000)

  setInterval(function report() &#123;
    process.send(&#123;
      cmd: &#39;reportMem&#39;,
      memory: process.memoryUsage(),
      process: process.pid
    &#125;)
  &#125;, 1000)
&#125;

function createWorker() &#123;
  const worker &#x3D; cluster.fork()
  const pid &#x3D; worker.process.pid
  console.log(&#96;Created worker: $&#123;pid&#125;&#96;)

  workers[pid] &#x3D; &#123;
    worker: worker,
    lastCb: Date.now() - 1000
  &#125;

  worker.on(&#39;message&#39;, m &#x3D;&gt; &#123;
    if (m.cmd &#x3D;&#x3D;&#x3D; &#39;reportMem&#39;) &#123;
      workers[m.process].lastCb &#x3D; Date.now()

      if (m.memory.rss &gt; rssWarn) &#123;
        console.log(&#96;Worker $&#123;m.process&#125; using too much memory.&#96;)
      &#125;
    &#125;
  &#125;)
&#125;

]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>SPA 路由原理</title>
    <url>/2017/08/spa-router-principle.html</url>
    <content><![CDATA[hash监听 hashchange 事件。
window.addEventListener(&#39;hashchange&#39;, function() &#123;
  console.log(window.location.hash);
&#125;);


history使用 History API。
window.addEventListener(&#39;popstate&#39;, function(event) &#123;
  console.log(event.state);
&#125;);

popstate 事件在 history 改变时触发，调用 history.pushState() 创建新的历史项，或调用 history.replaceState() 替换新的历史项，那么 popstate 事件的 state 属性会包含历史项状态对象(state object)的拷贝(event.state)。
需要注意的是调用 history.pushState() 或 history.replaceState() 不会触发 popstate 事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用history.back()）。
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>transform: matrix() &amp; matrix3d()</title>
    <url>/2017/08/transform-matrix-and-matrix3d.html</url>
    <content><![CDATA[2D 图形的坐标笛卡尔坐标系

原点 (0, 0) 在元素的左上角，每一个点由向量 (x, y) 标记。
进行变换的时候，对每个点做矩阵乘法：
$$ \left\lgroup \matrix{a &amp; c\cr b &amp; d} \right\rgroup \left\lgroup \matrix{x \cr y} \right\rgroup &#x3D; \left\lgroup \matrix{ax + cy\cr bx + dy} \right\rgroup $$
可以在一行中应用多次变换：
$$ \left\lgroup \matrix{a_1 &amp; c_1\cr b_1 &amp; d_1} \right\rgroup \left\lgroup \matrix{a_2 &amp; c_2\cr b_2 &amp; d_2} \right\rgroup &#x3D; \left\lgroup \matrix{a_1a_2 + c_1b_2 &amp; a_1c_2 + c_1d_2\cr b_1a_2 + d_1b_2 &amp; b_1c_2 + d_1d_2} \right\rgroup $$
使用这种标记可以描述多种常用的变换：旋转、缩放、倾斜。事实上所有这些变换都是线性函数可以描述的。使用这种标记时有一种非线性的变换需要当做特例，就是平移。平移向量 (tx, ty) 必须作为两个附加的参数来表述。
函数定义的变换 matrix()语法matrix(a, b, c, d, tx, ty)


a, b, c, d 描述线性变换的数字
tx, ty 描述平移的数字

示例.pane &#123;
  background: green;
  width: 200px;
  height: 200px;
&#125;

.box &#123;
  float: left;
  background: blue;
  width: 50px;
  height: 50px;
  transform-origin: 0 0;
&#125;

.more &#123;
  float: left;
  width: 50px;
  height: 50px;
  background: red;
&#125;


  
  


上下左右各平移 4px.box &#123;
  transform: matrix(1, 0, 0, 1, 4, 4);
&#125;


  
  


放大两倍.box &#123;
  transform: matrix(2, 0, 0, 2, 0, 0);
&#125;


  
  


旋转.box &#123;
  transform: matrix(2, 1, -1, 2, 0, 0);
&#125;


  
  



Tip: 为什么平移不是线性变换？
一个线性变换 f，会使 f(x + y) &#x3D; f(x) + f(y) 成立
而平移：y &#x3D; ax + b
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>css-transform</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>WeakMap 与 Symbol 在类私有数据的应用</title>
    <url>/2017/08/using-weakmap-and-symbol-on-private-member-of-class.html</url>
    <content><![CDATA[用 WeakMap 实现let _counter &#x3D; new WeakMap();
let _action &#x3D; new WeakMap();

class Countdown &#123;
  constructor(counter, action) &#123;
    _counter.set(this, counter);
    _action.set(this, action);
  &#125;
  dec() &#123;
    let counter &#x3D; _counter.get(this);
    if (counter &lt; 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter &#x3D;&#x3D;&#x3D; 0) &#123;
      _action.get(this)();
    &#125;
  &#125;
&#125;

WeakMap 的键名是对象的弱引用，其所对应的对象可能会被自动回收，只要不暴露 WeakMap，私有数据就是安全的。
Pros.

私有属性命名不会冲突

Cons.

代码不够优雅


用 Symbol 实现const _counter &#x3D; Symbol(&#39;counter&#39;);
const _action &#x3D; Symbol(&#39;action&#39;);

class Countdown &#123;
  constructor(counter, action) &#123;
    this[_counter] &#x3D; counter;
    this[_action] &#x3D; action;
  &#125;
  dec() &#123;
    if (this[_counter] &lt; 1) return;
    this[_counter]--;
    if (this[_counter] &#x3D;&#x3D;&#x3D; 0) &#123;
      this[_action]();
    &#125;
  &#125;
&#125;

每一个 Symbol 都是唯一的，这就是为什么使用 Symbol 的属性键名之间不会冲突的原因。并且，Symbol 某种程度上来说是隐式的，但也并不完全是：
let c &#x3D; new Countdown(2, () &#x3D;&gt; console.log(&#39;DONE&#39;));

console.log(Object.keys(c));
&#x2F;&#x2F; []
console.log(Reflect.ownKeys(c));
&#x2F;&#x2F; [Symbol(counter), Symbol(action)]

Pros.

私有属性命名不会冲突

Cons.

代码不够优雅
不太安全，可以通过 Reflect.ownKeys() 列表一个对象所以的属性键名



如何在ES6中管理类的私有数据
Managing the private data of ES6 classes

]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端 webp 应用实践</title>
    <url>/2017/08/webp-practice-on-mobile.html</url>
    <content><![CDATA[判断浏览器是否支持 webp 格式的图片
var isWebpSupport &#x3D; false;

function detectWebpSupport() &#123;
  if (isWebpSupport) return;

  try &#123;
    isWebpSupport &#x3D; window.localStorage &amp;&amp; window.localStorage.getItem(&#39;isWebpSupport&#39;);
  &#125; catch (e) &#123;&#125;

  if (isWebpSupport) return;

  var img &#x3D; new Image();
  img.src &#x3D; &#39;data:image&#x2F;webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA&#x2F;veff&#x2F;0PP8bA&#x2F;&#x2F;LwYAAA&#39;;
  img.onload &#x3D; function() &#123;
    if (img.height &#x3D;&#x3D;&#x3D; 2) &#123;
      isWebpSupport &#x3D; true;
      try &#123;
        window.localStorage &amp;&amp; window.localStorage.setItem(&#39;isWebpSupport&#39;, true);
      &#125; catch (e) &#123;&#125;
    &#125;
  &#125;;
&#125;

detectWebpSupport();    &#x2F;&#x2F; 检查是否支持 webp

根据 webp 的支持情况替换图片的 url
$http.get(&#39;&#x2F;api&#x2F;list&#39;).then(res &#x3D;&gt; res.data).then(data &#x3D;&gt; &#123;
    let items &#x3D; data.items;
    if (isWebpSupport) &#123;
      items &#x3D; items.map(item &#x3D;&gt; &#123;
        item.img &#x3D; item.img.replace(&#x2F;\-thumb$&#x2F;, &#39;-thumbwebp&#39;);    &#x2F;&#x2F; 使用七牛云服务处理图片 http:&#x2F;&#x2F;developer.qiniu.com&#x2F;code&#x2F;v6&#x2F;api&#x2F;kodo-api&#x2F;image&#x2F;imageview2.html
        return item;
      &#125;);
    &#125;
    return items;
  &#125;
&#125;).catch(err &#x3D;&gt; &#123;
  console.error(err);
&#125;);


附：localStorage.getItem 与 img.onload 性能比较
function test1() &#123;
  var start &#x3D; window.performance.now();
  var img &#x3D; new Image();
  img.src &#x3D; &#39;data:image&#x2F;webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA&#x2F;veff&#x2F;0PP8bA&#x2F;&#x2F;LwYAAA&#39;;
  img.onload &#x3D; function() &#123; console.log(window.performance.now() - start); &#125;
&#125;

function test2() &#123;
  var start &#x3D; window.performance.now();
  window.localStorage.getItem(&#39;isWebpSupport&#39;);
  console.log(window.performance.now() - start);
&#125;
&#x2F;&#x2F; localStorage 为同步调用

相差一个数量级

]]></content>
      <tags>
        <tag>webp</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>window.requestAnimationFrame</title>
    <url>/2017/08/window-requestanimationframe.html</url>
    <content><![CDATA[window.requestAnimationFrame() 方法会告诉浏览器你想运行一个动画，并要求浏览器在下次重绘（repaint）之前调用一个函数来更新动画。
你应该在准备更新屏幕上的动画时调用这个方法。它将使你的动画函数在下次重绘之前调用。回调执行的频率通常为每秒60次，但一般会与屏幕的刷新率相匹配。当在后台的 tab 或者隐藏的 iframe 中运行时，回调执行的频率会降低以提高性能与电池寿命。
window.requestAnimationFrame(callback);


window.requestAnimationFrame()
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title>Nightwatch 中 ChromeDriver 启用 Mobile Emulation 与 headless</title>
    <url>/2017/09/chrome-driver-enable-mobile-emulation-and-headless-in-nightwatch.html</url>
    <content><![CDATA[在对移动端的项目进行 E2E 测试时，需要用到 ChromeDriver 的 Mobile Emulation 来模拟移动设备。
在 Javascript 中启用 Mobile Emulation 需要如下配置。
chrome: &#123;
  desiredCapabilities: &#123;
    browserName: &#39;chrome&#39;,
    javascriptEnabled: true,
    acceptSslCerts: true,
    chromeOptions: &#123;
      args: [&#39;--headless&#39;],
      mobileEmulation: &#123;
        deviceName: &#39;iPhone 6&#39;
      &#125;
    &#125;
  &#125;
&#125;

deviceName 可以在 Chrome 浏览器的 开发者工具 - Settings - Devices 中找到。


Mobile Emulation - ChromeDriver
node-chromedriver
mobile_device_list.cc - chromium
Getting Started with Headless Chrome - Google Developers

]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>E2E</tag>
        <tag>Test</tag>
        <tag>Nightwatch</tag>
      </tags>
  </entry>
  <entry>
    <title>简易七牛文件上传</title>
    <url>/2017/09/simple-qiniu-file-upload.html</url>
    <content><![CDATA[由于七牛提供的 js sdk 依赖较多，所以对于单纯上传文件的需求，采用表单上传会是一种更简便的方法。
function upload(file, token, params) &#123;
  const formData &#x3D; new FormData();
  formData.append(&#39;token&#39;, token);
  formData.append(&#39;file&#39;, file);
  Object.keys(params).forEach(key &#x3D;&gt; &#123;
    formData.append(&#96;x:$&#123;key&#125;&#96;, params[key]);
  &#125;);

  return post(&#39;&#x2F;&#x2F;upload.qiniup.com&#39;, formData);
&#125;


表单上传-七牛开发者中心
]]></content>
      <tags>
        <tag>qiniu</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Node.js 导出的 csv 文件在 Excel 打开中文乱码的问题</title>
    <url>/2017/09/solve-problem-that-chinese-garbled-in-nodejs-exported-csv-by-excel.html</url>
    <content><![CDATA[在项目中有需要导出 CSV 文件，用 Node.js 生成的 CSV 在 Excel 中打开中文会乱码。查阅资料后得知需要给导出的文件添加 BOM。
const filename &#x3D; &#39;export.csv&#39;;
ctx.body &#x3D; &#96;\ufeff$&#123;csv&#125;&#96;; &#x2F;&#x2F; add utf-8 bom to string
ctx.set(&#39;content-disposition&#39;, &#96;attachment; filename&#x3D;$&#123;filename&#125;&#96;);
ctx.set(&#39;content-type&#39;, &#39;text&#x2F;csv&#39;);


特殊字符 (JavaScript) - MSDN
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>CSV</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发问题集</title>
    <url>/2017/10/problem-set-of-we-app-development.html</url>
    <content><![CDATA[setData: invokeWebviewMethod 数据传输长度为 *** 已经超过最大长度 1048576在小程序中执行 setData 时，如果数据内容过大的话，会出现数据传输长度超过最大长度的问题。其原因在于 setData 实际上是在 webview 上执行了 stringByEvaluatingJavaScriptFromString 这类方法，如果传入数据过大的话，就会使 webview 的内存开销过大，JavaScript 代码执行失败。
开发中，在存在大量数据的情况下，可以对数据执行 map 之类的操作，仅留下需要展示的数据以及对应的 key，这样每次 setData 的数据就会小很多。

rich-text 数据来源由于小程序不支持 iframe 这样的组件，所以在需要展示 html 页面的时候，只能使用 rich-text。
欲显示的 html 内容最好在服务器端转换成数组的形式，有以下几个原因：

根据小程序开发文档所言，nodes 属性推荐使用 Array 类型，由于组件会将 String 类型转换为 Array 类型，因而性能会有所下降
rich-text 仅支持有限的 html 标签。对于不支持的标签，一部分可以替换成 span 或者 tag 这类它支持的标签。剩下的也可以根据实际情况直接去除或者替换成提示文字。
小程序中的 wxss 样式仅能根据 class 生效，而原 html 文档的 css 文件中会有使用类型选择器，为了能使用原有的这些样式，为每一个元素增加类似 __tag__span 这样的类名，同时对原 css 执行正则表达式将其中的 span &#123;...&#125; 替换成 .__tag__span &#123;...&#125; 的形式
剔除 rich-text 不支持的 attr

以上这些操作适合在服务器端执行，代码如下：
const parse5 &#x3D; require(&#39;parse5&#39;);
const entities &#x3D; require(&#39;entities&#39;);

const AVAILABLE_ATTRS &#x3D; [
  &#39;class&#39;,
  &#39;style&#39;,
  &#39;span&#39;,
  &#39;width&#39;,
  &#39;alt&#39;,
  &#39;src&#39;,
  &#39;height&#39;,
  &#39;start&#39;,
  &#39;type&#39;,
  &#39;colspan&#39;,
  &#39;rowspan&#39;,
];

const AVAILABLE_TAGS &#x3D; [
  &#39;a&#39;, &#39;abbr&#39;, &#39;b&#39;, &#39;blockquote&#39;,
  &#39;br&#39;, &#39;code&#39;, &#39;col&#39;, &#39;colgroup&#39;,
  &#39;dd&#39;, &#39;del&#39;, &#39;div&#39;, &#39;dl&#39;, &#39;dt&#39;,
  &#39;em&#39;, &#39;fieldset&#39;, &#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;,
  &#39;h4&#39;, &#39;h5&#39;, &#39;h6&#39;, &#39;hr&#39;, &#39;i&#39;, &#39;img&#39;,
  &#39;ins&#39;, &#39;label&#39;, &#39;legend&#39;, &#39;li&#39;,
  &#39;ol&#39;, &#39;p&#39;, &#39;q&#39;, &#39;span&#39;, &#39;strong&#39;,
  &#39;sub&#39;, &#39;sup&#39;, &#39;table&#39;, &#39;tbody&#39;,
  &#39;td&#39;, &#39;tfoot&#39;, &#39;th&#39;, &#39;thead&#39;,
  &#39;tr&#39;, &#39;ul&#39;,
];

const REPLACEABLE_TAGS &#x3D; [
  &#39;pre&#39;, &#39;small&#39;, &#39;var&#39;, &#39;button&#39;, &#39;font&#39;, &#39;details&#39;,
  &#39;summary&#39;, &#39;caption&#39;, &#39;figure&#39;, &#39;figcaption&#39;, &#39;dfn&#39;,
  &#39;string&#39;, &#39;s&#39;,
];

const REPLACE_MAP &#x3D; &#123;
  pre: &#39;div&#39;,
  small: &#39;span&#39;,
  var: &#39;span&#39;,
  button: &#39;span&#39;,
  font: &#39;span&#39;,
  details: &#39;div&#39;,
  summary: &#39;div&#39;,
  caption: &#39;div&#39;,
  figure: &#39;div&#39;,
  figcaption: &#39;div&#39;,
  dfn: &#39;span&#39;,
  string: &#39;span&#39;,
  s: &#39;span&#39;,
&#125;;

const IGNOREABLE_TAGS &#x3D; [
  &#39;meta&#39;,
];

function parseNode(ctx, node) &#123;
  const &#123; childNodes, tagName, attrs: _attrs &#125; &#x3D; node;
  let needOverrideTagName &#x3D; false;

  if (node.nodeName &#x3D;&#x3D;&#x3D; &#39;#text&#39;) &#123;
    return &#123;
      type: &#39;text&#39;,
      text: entities.decodeHTML(node.value),
    &#125;;
  &#125;

  if (AVAILABLE_TAGS.indexOf(tagName) &#x3D;&#x3D;&#x3D; -1) &#123;
    if (IGNOREABLE_TAGS.indexOf(tagName) &gt; -1) &#123;
      return null;
    &#125; else if (REPLACEABLE_TAGS.indexOf(tagName) &gt; -1) &#123;
      needOverrideTagName &#x3D; true;
    &#125; else &#123;
      if (tagName !&#x3D;&#x3D; &#39;iframe&#39;) &#123;
        ctx.logger.info(&#96;UNSUPPORT TAG: $&#123;tagName&#125;&#96;);
      &#125;

      return &#123;
        name: &#39;div&#39;,
        attrs: &#123;
          class: &#39;content-unavailable&#39;,
        &#125;,
        children: [
          &#123;
            type: &#39;text&#39;,
            text: &#39;此处内容无法在当前环境中显示&#39;,
          &#125;,
        ],
      &#125;;
    &#125;
  &#125;

  let children;
  if (childNodes &amp;&amp; childNodes.length &gt; 0) &#123;
    children &#x3D; childNodes.map(node &#x3D;&gt; parseNode(ctx, node)).filter(child &#x3D;&gt; !!child);
  &#125;

  const attrs &#x3D; _attrs
    .filter(attr &#x3D;&gt; AVAILABLE_ATTRS.indexOf(attr.name) &gt; -1)
    .reduce((obj, attr) &#x3D;&gt; &#123;
      obj[attr.name] &#x3D; attr.value;
      return obj;
    &#125;, &#123;&#125;);

  const classNames &#x3D; attrs.class ? attrs.class.split(&#39; &#39;) : [];
  classNames.push(&#96;__tag_$&#123;tagName&#125;&#96;, &#39;__univ&#39;);
  attrs.class &#x3D; classNames.join(&#39; &#39;);

  const nodeObj &#x3D; &#123;
    name: needOverrideTagName ? REPLACE_MAP[tagName] : tagName,
    attrs,
    children,
  &#125;;

  return nodeObj;
&#125;

function parseHtml(ctx, html) &#123;
  const documentFragment &#x3D; parse5.parseFragment(html);
  const nodes &#x3D; documentFragment.childNodes.map(node &#x3D;&gt; parseNode(ctx, node));
  return nodes;
&#125;


rich-text setData在使用 setData 对 rich-text 的 nodes 属性赋值时，如果元素过多，则可能出现页面卡顿或者数据传输长度超过最大长度的问题。此时，可以将 nodes 数组分成适量片段，分段 setData。
&lt;rich-text wx:for&#x3D;&quot;&#123;&#123; nodesList &#125;&#125;&quot; wx:for-index&#x3D;&quot;index&quot; wx:for-item&#x3D;&quot;nodes&quot; nodes&#x3D;&quot;&#123;&#123;nodes&#125;&#125;&quot;&gt;&lt;&#x2F;rich-text&gt;

const nodes &#x3D; ***;
const nodesList &#x3D; [];
const lastNodes &#x3D; nodes.reduce((arr, cur) &#x3D;&gt; &#123;
  const curArr &#x3D; [cur];
  const newArr &#x3D; arr.concat(curArr);
  if (JSON.stringify(newArr).length &gt; (1048576 - 1024 * 1000)) &#123;
    nodesList.push(arr);
    return curArr;
  &#125; else &#123;
    return newArr;
  &#125;
&#125;, []);
nodesList.push(lastNodes);

this.setData(&#123;
  &#39;nodesList&#39;: []
&#125;);
nodesList.forEach((nodes, idx) &#x3D;&gt; &#123;
  if (idx &#x3D;&#x3D;&#x3D; 0) &#123;
    this.setData(&#123;
      [&#96;nodesList[$&#123;idx&#125;]&#96;]: nodes,
      loading: false
    &#125;);
  &#125; else &#123;
    this.setData(&#123;
      [&#96;nodesList[$&#123;idx&#125;]&#96;]: nodes
    &#125;);
  &#125;
&#125;);
]]></content>
      <tags>
        <tag>小程序</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>convert mov to mp4 on macOS</title>
    <url>/2017/11/convert-mov-to-mp4-on-mac-os.html</url>
    <content><![CDATA[这些天有在 iOS 和 macOS 上录制屏幕，输出的文件都是 mov 格式的，于是期望转换成 mp4  格式，找到了一下方法：
$ brew install ffmpeg
$ ffmpeg -i &#x2F;path&#x2F;to&#x2F;input.mov &#x2F;path&#x2F;to&#x2F;output.mp4
]]></content>
      <tags>
        <tag>mp4</tag>
        <tag>video</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>GIF vs MP4</title>
    <url>/2017/11/gif-vs-mp4.html</url>
    <content><![CDATA[


GIF
MP4







1 MB
122 KB


Convert
$ ffmpeg -f gif -i Desktop&#x2F;tom-and-jerry.gif -pix_fmt yuv420p -c:v libx264 -movflags +faststart -filter:v crop&#x3D;&#39;floor(in_w&#x2F;2)*2:floor(in_h&#x2F;2)*2&#39; Desktop&#x2F;tom-and-jerry.mp4
]]></content>
      <tags>
        <tag>mp4</tag>
        <tag>video</tag>
        <tag>gif</tag>
      </tags>
  </entry>
  <entry>
    <title>优化 React Functional Component 性能</title>
    <url>/2017/11/optimize-react-functional-component-performance.html</url>
    <content><![CDATA[Functional Component 的引入为 React 的开发带来了极大的便利，然而它并不像 Class Component 那样可以设置 shouldComponentUpdate。
测试代码如下
import React from &quot;react&quot;;

const ItemX &#x3D; id &#x3D;&gt; &#123;
  return props &#x3D;&gt; &#123;
    console.log(&#96;Item$&#123;id&#125; render&#96;);
    const &#123; title &#125; &#x3D; props;
    let timer &#x3D; null;

    return &lt;div&gt;&#123;title&#125;&lt;&#x2F;div&gt;;
  &#125;;
&#125;;

const Item1 &#x3D; ItemX(1);

class App extends React.Component &#123;
  state &#x3D; &#123;
    title1: 1,
    x: 3
  &#125;;

  _handleClickIncX &#x3D; () &#x3D;&gt; &#123;
    const &#123; x &#125; &#x3D; this.state;
    this.setState(&#123;
      x: x + 1
    &#125;);
  &#125;;

  _handleClickIncTitle1 &#x3D; () &#x3D;&gt; &#123;
    const &#123; title1 &#125; &#x3D; this.state;
    this.setState(&#123;
      title1: title1 + 1
    &#125;);
  &#125;;

  render() &#123;
    const &#123; title1, title2, title3 &#125; &#x3D; this.state;
    return (
      &lt;div&gt;
        &lt;Item1 title&#x3D;&#123;title1&#125; &#x2F;&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncX&#125;&gt;incX&lt;&#x2F;button&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncTitle1&#125;&gt;incTitle1&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;


可以发现点击 incX 也会导致 Item1 的执行，这就很尴尬了，那么如何让 Functional Component 也具有 shouldComponentUpdate 的功能呢？
我们可以用 PureComponent 将 Functional Component 包裹起来。
function pure1(component) &#123;
  return class extends React.PureComponent &#123;
    render() &#123;
      const props &#x3D; this.props;
      return component(props);
    &#125;
  &#125;;
&#125;

const Item2 &#x3D; pure1(ItemX(2));

class App extends React.Component &#123;
  state &#x3D; &#123;
    title1: 1,
    title2: 2,
    x: 3
  &#125;;

  _handleClickIncTitle2 &#x3D; () &#x3D;&gt; &#123;
    const &#123; title2 &#125; &#x3D; this.state;
    this.setState(&#123;
      title2: title2 + 1
    &#125;);
  &#125;;

  render() &#123;
    const &#123; title1, title2 &#125; &#x3D; this.state;
    return (
      &lt;div&gt;
        &lt;Item1 title&#x3D;&#123;title1&#125; &#x2F;&gt;
        &lt;Item2 title&#x3D;&#123;title2&#125; &#x2F;&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncX&#125;&gt;incX&lt;&#x2F;button&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncTitle1&#125;&gt;incTitle1&lt;&#x2F;button&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncTitle2&#125;&gt;incTitle2&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;

点击 incX 和 incTitle1 并不会导致 Item2 被执行。
项目开发中可以使用 recompose 中的 pure 函数来包裹 Functional Component。

然而 pure1 本质上是用一个 Class Component 包裹 Functional Component，这样似乎并不那么 Functional，那么换种方法呢？
const hasOwnProperty &#x3D; Object.prototype.hasOwnProperty;

function is(x, y) &#123;
  if (x &#x3D;&#x3D;&#x3D; y) &#123;
    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;
  &#125; else &#123;
    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;
  &#125;
&#125;

function shallowEqual(objA, objB) &#123;
  if (is(objA, objB)) &#123;
    return true;
  &#125;

  if (
    typeof objA !&#x3D;&#x3D; &quot;object&quot; ||
    objA &#x3D;&#x3D;&#x3D; null ||
    typeof objB !&#x3D;&#x3D; &quot;object&quot; ||
    objB &#x3D;&#x3D;&#x3D; null
  ) &#123;
    return false;
  &#125;

  const keysA &#x3D; Object.keys(objA);
  const keysB &#x3D; Object.keys(objB);

  if (keysA.length !&#x3D;&#x3D; keysB.length) &#123;
    return false;
  &#125;

  for (let i &#x3D; 0; i &lt; keysA.length; i++) &#123;
    if (
      !hasOwnProperty.call(objB, keysA[i]) ||
      !is(objA[keysA[i]], objB[keysA[i]])
    ) &#123;
      return false;
    &#125;
  &#125;

  return true;
&#125;

function pure2(component) &#123;
  let isInitialized &#x3D; false;
  let oldProps &#x3D; null;
  let oldValue &#x3D; null;

  return function(newProps) &#123;
    if (!isInitialized) &#123;
      isInitialized &#x3D; true;
      oldProps &#x3D; newProps;
      oldValue &#x3D; component(newProps);
      return oldValue;
    &#125;

    if (shallowEqual(oldProps, newProps)) &#123;
      return oldValue;
    &#125; else &#123;
      oldProps &#x3D; newProps;
      oldValue &#x3D; component(newProps);
      return oldValue;
    &#125;
  &#125;;
&#125;

const Item3 &#x3D; pure2(ItemX(3));

class App extends React.Component &#123;
  state &#x3D; &#123;
    title1: 1,
    title2: 2,
    title3: 3,
    x: 3
  &#125;;

  _handleClickIncTitle3 &#x3D; () &#x3D;&gt; &#123;
    const &#123; title3 &#125; &#x3D; this.state;
    this.setState(&#123;
      title3: title3 + 1
    &#125;);
  &#125;;

  render() &#123;
    const &#123; title1, title2, title3 &#125; &#x3D; this.state;
    return (
      &lt;div&gt;
        &lt;Item1 title&#x3D;&#123;title1&#125; &#x2F;&gt;
        &lt;Item2 title&#x3D;&#123;title2&#125; &#x2F;&gt;
        &lt;Item3 title&#x3D;&#123;title3&#125; &#x2F;&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncX&#125;&gt;incX&lt;&#x2F;button&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncTitle1&#125;&gt;incTitle1&lt;&#x2F;button&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncTitle2&#125;&gt;incTitle2&lt;&#x2F;button&gt;
        &lt;button onClick&#x3D;&#123;this._handleClickIncTitle3&#125;&gt;incTitle3&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;

shallowEqual 这个函数是从 React 源码中 PureComponent 那部分提取出来的。
Nice Work!
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Component</tag>
        <tag>HOC</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native 开发 Tip</title>
    <url>/2017/11/react-native-development-tip.html</url>
    <content><![CDATA[与 css 中的表现不同，在 React Native 中，flex 元素的子元素默认会在主轴方向填满父元素。需要子元素大小包裹内容时，可以在父元素样式中添加 flexWrap: &#39;wrap&#39;。

TouchableWithoutFeedback 与 TouchableHighlight 的差异。可以在 TouchableHighlight 元素可以设置 style 属性，而 TouchableWithoutFeedback 元素上不能设置 style 属性。

ios android 平台中 borderRadius 有所差异：
const style &#x3D; StyleSheet.create(&#123;
  avatar: &#123;
    width: 50,
    height: 50,
    backgroundColor: &#39;transparent&#39;,
    overflow: &#39;hidden&#39;,
    ...Platform.select(&#123;
      ios: &#123;
        borderRadius: 50 &#x2F; 2,
      &#125;,
      android: &#123;
        borderRadius: 50,
      &#125;
    &#125;),
  &#125;
&#125;);


]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative 响应式单位 rpx</title>
    <url>/2017/11/react-native-responsive-unit-rpx.html</url>
    <content><![CDATA[日前在 ReactNative 开发中有遇到如何写出符合多种 viewport 宽度的样式的问题。在常规的移动端开发中，可以借助 rem、vw 等单位，那么在使用 ReactNative 时有没有类似的方案呢？最近进行小程序开发时注意到它们有 rpx 这种单位：

rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx &#x3D; 375px &#x3D; 750物理像素，1rpx &#x3D; 0.5px &#x3D; 1物理像素。

受其启发，决定在代码中实现类似的单位，当需要自适应的时候写字符串 &#39;20rpx&#39;，不需要的时候正常写数字 20。
&#x2F;&#x2F; style-sheet.js
import &#123; StyleSheet, PixelRatio &#125; from &#39;react-native&#39;;

const REG &#x3D; &#x2F;[\d\.]rpx&#x2F;;

function pre(obj) &#123;
  Object.keys(obj).forEach(key &#x3D;&gt; &#123;
    const value &#x3D; obj[key];
    if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;
      obj[key] &#x3D; pre(value);
    &#125; else if (typeof value &#x3D;&#x3D;&#x3D; &#39;string&#39; &amp;&amp; REG.test(value)) &#123;
      obj[key] &#x3D; PixelRatio.getPixelSizeForLayoutSize(parseFloat(value) &#x2F; 4);
    &#125;
  &#125;);

  return obj;
&#125;

function create(obj) &#123;
  obj &#x3D; pre(obj);
  return StyleSheet.create(obj);
&#125;

const BORDER_COLOR &#x3D; &#39;#e6e6e6&#39;;

const SS &#x3D; &#123;
  hairlineWidth: StyleSheet.hairlineWidth,
  create,
  pre,
  absoluteFillObject: StyleSheet.absoluteFillObject,
  common: &#123;
    backgroundColor: &#39;#F2F3F8&#39;,
    center: &#123;
      justifyContent: &#39;center&#39;,
      alignItems: &#39;center&#39;,
      display: &#39;flex&#39;
    &#125;,
    centerH: &#123;
      alignItems: &#39;center&#39;,
      display: &#39;flex&#39;,
      flexDirection: &#39;row&#39;
    &#125;,
    centerV: &#123;
      alignItems: &#39;center&#39;,
      display: &#39;flex&#39;,
      flexDirection: &#39;column&#39;
    &#125;,
    primaryGreen: &#39;#75CA2A&#39;,
    primaryDarkGreen: &#39;#62A427&#39;,
    borderColor: BORDER_COLOR,
  &#125;
&#125;

export default SS;
]]></content>
      <tags>
        <tag>ReactNative</tag>
        <tag>小程序</tag>
        <tag>Responsive</tag>
      </tags>
  </entry>
  <entry>
    <title>react-navigation 实践</title>
    <url>/2017/11/react-navigation-practice.html</url>
    <content><![CDATA[goBack 时回传参数&#x2F;&#x2F; A.js
class A extends React.Component &#123;
  _handlePressLocationSelect &#x3D; () &#x3D;&gt; &#123;
    const &#123; navigation &#125; &#x3D; this.props;
    navigation.navigate(
      &#39;B&#39;,
      &#123;
        onSelect: this._onSelect
      &#125;
    );
  &#125;

  _onSelect &#x3D; (&#123;&#125;) &#x3D;&gt; &#123;
    this.setState(&#123;
    &#125;);
  &#125;
&#125;

&#x2F;&#x2F; B.js
class B extends React.Component &#123;
  _onPressBack &#x3D; (&#123;&#125;) &#x3D;&gt; &#123;
    const &#123; navigation &#125; &#x3D; this.props;
    navigation.goBack();
    navigation.state.params.onSelect(&#123;&#125;);
  &#125;
&#125;




react-navigation 与 mobx 集成&#x2F;&#x2F; NavStore.js

import &#123; observable, computed, action &#125; from &#39;mobx&#39;;
import &#123; NavigationActions &#125; from &#39;react-navigation&#39;;

import AppNavigator from &#39;@&#x2F;AppNavigator&#39;;

const initialState &#x3D; AppNavigator.router.getStateForAction(
  NavigationActions.init()
);

class NavStore &#123;
  constructor(rootStore) &#123;
    this.rootStore &#x3D; rootStore;
  &#125;

  @observable.ref _nav &#x3D; initialState;

  @action
  dispatch &#x3D; (action) &#x3D;&gt; &#123;
    const state &#x3D; this.nav;

    const nextState &#x3D; AppNavigator.router.getStateForAction(action, state);

    this._nav &#x3D; nextState;
  &#125;

  @computed
  get nav() &#123;
    return this._nav;
  &#125;
&#125;

export default NavStore;

&#x2F;&#x2F; App.js

import React from &#39;react&#39;;
import &#123; observer &#125; from &#39;mobx-react&#39;;
import store from &#39;@&#x2F;store&#39;;

import AppNavigator from &#39;@&#x2F;AppNavigator&#39;;

import &#123;
  addNavigationHelpers
&#125; from &#39;react-navigation&#39;;

@observer
class App extends React.Component &#123;
  render() &#123;
    const navigation &#x3D; addNavigationHelpers(&#123;
      dispatch: store.navStore.dispatch,
      state: store.navStore.nav,
    &#125;);

    return (
      &lt;AppNavigator navigation&#x3D;&#123;navigation&#125; &#x2F;&gt;
    );
  &#125;
&#125;

export default App;


使用 decorator 配置 navigationOptions开发中，很多 screen 的 Header 样式是相似的，通过使用 decorator 可以使 navigationOptions 的配置更加简便。
import SS from &#39;@&#x2F;utils&#x2F;style-sheet&#39;;

export function greenHeader(options) &#123;
  return function (target) &#123;
    let prevOpts &#x3D; &#123;&#125;;
    if (&#39;navigationOptions&#39; in target) &#123;
      prevOpts &#x3D; target.navigationOptions;
    &#125;

    target.navigationOptions &#x3D; (props) &#x3D;&gt; &#123;
      if (typeof prevOpts &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
        prevOpts &#x3D; prevOpts(props);
      &#125;

      const opts &#x3D; typeof options &#x3D;&#x3D;&#x3D; &#39;function&#39; ? options(props) : options;

      return Object.assign(&#123;
        headerStyle: &#123;
          backgroundColor: &#39;#75CA2A&#39;,
          borderBottomWidth: 0,
        &#125;,
        headerTitleStyle: SS.pre(&#123;
          color: &#39;#ffffff&#39;,
          fontSize: &#39;36rpx&#39;
        &#125;),
        headerTintColor: &#39;#fff&#39;
      &#125;, prevOpts, opts);
    &#125;
    return target;
  &#125;
&#125;

export function noBackTitle(options) &#123;
  return function (target) &#123;
    let prevOpts &#x3D; &#123;&#125;;
    if (&#39;navigationOptions&#39; in target) &#123;
      prevOpts &#x3D; target.navigationOptions;
    &#125;

    target.navigationOptions &#x3D; (props) &#x3D;&gt; &#123;
      if (typeof prevOpts &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
        prevOpts &#x3D; prevOpts(props);
      &#125;

      const opts &#x3D; typeof options &#x3D;&#x3D;&#x3D; &#39;function&#39; ? options(props) : options;

      return Object.assign(&#123;
        headerBackTitleStyle: &#123; display: &#39;none&#39;, &#125;
      &#125;, prevOpts, opts);
    &#125;
    return target;
  &#125;
&#125;


这里定义了两个 decorator：greenHeader 用来生成绿色的 Header，noBackTitle 用来隐藏掉 Header 中后退按钮的 title。
使用示例：
@greenHeader(&#123;
  tabBarVisible: true,
  tabBarLabel: &#39;订单&#39;,
  title: &#39;我的订单&#39;,
&#125;)
class TabOrder extends React.Component &#123;&#125;

@screen.greenHeader(&#123; title: &#39;贷款详情&#39; &#125;)
@screen.noBackTitle()
class LoanDetail extends React.Component &#123;&#125;


Changelog

2017&#x2F;11&#x2F;22 增加 使用 decorator 配置 navigationOptions

]]></content>
      <tags>
        <tag>React</tag>
        <tag>Mobx</tag>
        <tag>react-natigation</tag>
      </tags>
  </entry>
  <entry>
    <title>不吹不黑聊聊前端框架</title>
    <url>/2017/11/talk-about-frontend-framework.html</url>
    <content><![CDATA[本文为听 尤雨溪 的知乎 Live 不吹不黑聊聊前端框架 后的部分记录。

组件的分类

接入型 container
展示型
交互型 比如各类加强版的表单组件，通常强调复用
功能型 比如 &lt;router-view&gt;，&lt;transition&gt;，作为一种扩展、抽象机制存在


JSX 与模板区别
JSX 更自由，适合功能型组件；模板适合展示型组件。

路由
将 url 映射到组件树

web 应用、原生应用路由区别：
web 应用从一个 url 调到另一个 url，上一个 url 的状态被清空；原生应用一层一层的叠加。

主流的 CSS 方案

跟 JS 完全解耦，靠预处理器和比如 BEM 这样的规范来保持可维护性，偏传统
CSS Modules，依然是 CSS，但是通过编译来避免 CSS 类名的全局冲突
各类 CSS-in-JS 方案，React 社区为代表，比较激进
Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面），一种比较折中的方案


传统 css 的一些问题：

作用域
Critical CSS
Atomic CSS
分发复用
跨平台复用

]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>某 SPA 向 PWA 迁移实录</title>
    <url>/2017/12/a-spa-to-pwa-migration-record.html</url>
    <content><![CDATA[背景有一单页应用 小B，近感其加载过慢、客户端载入时请求数过多，故考虑将之转换成 PWA，缩短内容到达时间，提升用户体验，以使其发挥更大的价值。
客户端其貌不扬的 SPA，基于 Vue, VueRouter, Vuex 生态构建。起始页含 5 个 Tab，靠底部的 TabBar 切换。多数页面需要用户登录，用户信息通过模板被后台注入到 html 文件中。
服务器端使用 Egg.js 搭建的 Node 应用，用于接收 SPA 的请求，并使用存在 redis 中的 token 等内容与后端 API 服务进行交互。
对客户端进行改动将 小B 转换成 PWA，修改的重头在客户端，可参考项目 vue-hackernews-2.0。本文仅对部分内容进行讨论。
server 与 client 采用不同的入口由于不再是纯前端项目，部分代码需要根据环境的不同，执行不同的操作，所以使用两个入口文件 entry-client.js 与 entry-server.js。
依赖特定平台 API 的模块代码中一些模块会使用到特定平台的 API，如 window 或 document，则在 Node.js 中执行时会抛出错误。这种情况下，应尽量使用同构的模块（如 axios）；或者在 mounted 中动态加载需要用到浏览器 API 的模块：
export default &#123;
  mounted() &#123;
    import(&#39;utils&#x2F;preview-image&#39;).then(previewImage &#x3D;&gt; this.previewImage &#x3D; previewImage.default || previewImage);
  &#125;,
  methods: &#123;
    onClickImagePreview(urls) &#123;
      this.previewImage(&#123; urls &#125;);
    &#125;
  &#125;
&#125;

Vuex store 中的模块重用在服务端渲染时，为了避免有状态的单例，我们会使用如 createApp, createStore, createRouter 这样的工厂函数，然而在 Vuex 模块中的 state 可能会被忘记。
const module &#x3D; &#123;
  state: &#123; ... &#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;,
  getters: &#123; ... &#125;
&#125;

需要修改为
const getInitialState &#x3D; () &#x3D;&gt; &#123;
  return &#123; ... &#125;;
&#125;;

const module &#x3D; &#123;
  state: getInitialState,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;,
  getters: &#123; ... &#125;
&#125;



与后端服务结合由于前后端项目代码是分离的，所以采用 SSR 后需要对后端代码进行修改。主要有以下几个方面：

前端项目的依赖（如 vue、vue-router 等）并不一定存在于后端项目中
session 信息的插入

对于项目的依赖，需要修改 webpack.server.config.js，将 webpack-node-externals 插件移除，这样 node_modules 中用到的依赖也会被打包到生成的 server bundle 中。
之前项目中用户的 session 信息里存有用户的登录状态及基本信息，并通过模板渲染注入的用户访问到的 html 文件中。改用 SSR 后需要依据开发及部署环境进行不同的处理。
开发环境中，采用简单的 express 服务，主要用来渲染页面，并且将 API 请求转发到后台（依据请求路径）。可以修改 server.js，在 renderToString 之前发送请求到后台获取用户信息，填入 context 中：
&#x2F;&#x2F; server.js

const getUserInfo &#x3D; cookies &#x3D;&gt; &#123;
  return axios.get(&#39;http:&#x2F;&#x2F;localhost:7005&#x2F;api&#x2F;account&#x2F;get-profile?need_token&#x3D;true&#39;, &#123;
    headers: &#123;
      Cookie: Object.keys(cookies).map(key &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;cookies[key]&#125;&#96;).join(&#39;; &#39;)
    &#125;
  &#125;)
    .then(res &#x3D;&gt; res.data);
&#125;;

function render(req, res) &#123;
   ...
   getUserInfo(req.cookies)
    .then(data &#x3D;&gt; &#123;
      if (data.code &#x3D;&#x3D;&#x3D; 0) &#123;
        context.userInfo &#x3D; data.result;
      &#125;

      renderer.renderToString(context, (err, html) &#x3D;&gt; &#123;
        if (err) &#123;
          return handleError(err);
        &#125;
        res.send(html);
        if (!isProd) &#123;
          console.log(&#96;whole request: $&#123;Date.now() - s&#125;ms&#96;);
        &#125;
      &#125;);
    &#125;);
   ...
&#125;

后台则可以直接从 redis 中读到用到的信息填入 context：
&#x2F;&#x2F; app&#x2F;controller&#x2F;home.js

module.exports &#x3D; app &#x3D;&gt; &#123;
  class HomeController extends app.Controller &#123;
    async index() &#123;
      ...
      const context &#x3D; &#123;
        title: &#39;xxx&#39;,
        url,
        bugtags: process.env.BUGTAGS ? &#96;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;dn-bts.qbox.me&#x2F;sdk&#x2F;bugtags-1.0.3.js&quot;&gt;&lt;&#x2F;script&gt;
        &lt;script&gt;
          new Bugtags(&#39;xxx&#39;,&#39;xxx&#39;,&#39;xxx&#39;);
        &lt;&#x2F;script&gt;&#96; : null,
        userInfo: ctx.session.userInfo
      &#125;;
      ...
    &#125;
  &#125;
&#125;

这样下来在 entry-server.js 中就可以通过 context 拿到用户信息，填入 store：
&#x2F;&#x2F; entry-server.js

export default context &#x3D;&gt; &#123;
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    ...

    const &#123; app, router, store &#125; &#x3D; createApp();

    if (isDef(context.userInfo)) &#123;
      store.state.user.userInfo &#x3D; context.userInfo;
      store.state.user.isLogin &#x3D; true;
    &#125;

    ...
  &#125;
&#125;


TBC…
]]></content>
      <tags>
        <tag>SPA</tag>
        <tag>Vue</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] t 检验的前提假设</title>
    <url>/2017/12/assumptions-for-the-t-test.html</url>
    <content><![CDATA[
双自变量（A、B 两组）
连续的因变量
每个因变量的观察值独立于其他因变量的观察值（其概率分布不受其值影响）。例外：对于相依样本 t 检验（paired t-test），我们只需要每对的差异（$\mathrm A_i - \mathrm B_i$）彼此独立
因变量服从正态分布，在每组中具有相同的方差 $\sigma^2$（就好像组 $\mathrm A$ 的分布仅仅被移动而成为组 $\mathrm B$ 的分布，而不改变形状）


注：正态分布的标度参数 $\sigma$ 也称为总体标准偏差，在正态曲线的图片上很容易看到。$\sigma$ 位于正常平均值的左侧或右侧的曲线从凸面变为凹面（二阶导数为零）的位置。

Cornell CSIC Elrod: Assumptions for the t-test
]]></content>
      <tags>
        <tag>Statistics</tag>
        <tag>t-test</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title>GCE 生成 initramfs 提速</title>
    <url>/2017/12/gce-build-initramfs-speed-up.html</url>
    <content><![CDATA[在 GCE 中生成 initramfs 会很慢，终端输出如下：
update-initramfs: Generating &#x2F;boot&#x2F;initrd.img-4.10.0-42-generic
W: mdadm: &#x2F;etc&#x2F;mdadm&#x2F;mdadm.conf defines no arrays.
xz: Adjusted LZMA2 dictionary size from 8 MiB to 2 MiB to not exceed the memory usage limit of 30 MiB

可以看出使用了 xz 压缩格式，并限制使用 30MB 的内存，这对我的小内存机器就很尴尬了。
可以修改配置文件 /etc/initramfs-tools/conf.d/99-gce.conf，将 5% 的内存限制调高。
# Use xz compression per GCE
COMPRESS&#x3D;xz
XZ_OPT&#x3D;--memlimit-compress&#x3D;5%
export XZ_OPT
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>GCE</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] LaTeX 数学公式快速入门</title>
    <url>/2017/12/latex-mathematical-notation-starter.html</url>
    <content><![CDATA[排版LaTeX 的书写有两种模式：inline 与 display。inline 表达式与文字渲染在行内，而 display 表达式独占一行。
inline 模式的表达式：$e^{i\pi} + 1 &#x3D; 0$
display 模式的表达式：$$e^x &#x3D; \sum_{n&#x3D;0}^\infty \frac{x^n}{n!}$$
写 inline 表达式时，要使用单个 $ 符号，$y=mx+b$ 输出 $y&#x3D;mx+b$。创建 display 表达式时，使用两个 $ 符号，$$P(A\mid B) = \frac&#123;P(B\mid A)P(A)&#125;&#123;P(B)&#125;$$ 输出 $$P(A\mid B) &#x3D; \frac{P(B\mid A)P(A)}{P(B)}$$
上标下标$x^2$ $x^2$
$e^2x$ $e^2x$
$e^&#123;2x&#125;$ $e^{2x}$
$x_i$ $x_i$
$_&#123;10&#125;C_5 $_{10}C_5$
指令特殊符号与格式使用指令书写，写作 \command。例如：创建一个平方根的根号，$\sqrt&#123;2\pi&#125;$ 生成 $\sqrt{2\pi}$。&#123;&#125; 包裹根号下的内容，\pi 渲染出希腊字母 pi($\pi$)。分数使用 \frac 命令显示，它接受两个分别被括号包裹的输入值，一个是分子，一个是分母。
符号符号以 \symbol 书写。

希腊字母 \alpha, \beta, \gamma：$\alpha$, $\beta$, $\gamma$。大写 \Phi, \Gamma：$\Phi$, $\Gamma$。由于 beta 的大写形式就是 $\mathrm{B}$，所以没有 \Beta。
操作符 \times, \pm, \cup, \oplus：$\times$, $\pm$, $\cup$, $\oplus$
三角函数 \sin, \cosh, \arctan：$\sin$, $\cosh$, $\arctan$
关系 \leq, \geq, \approx, \neq：$\leq$, $\geq$, $\approx$, $\neq$
三点 \cdots, \ldots, \ddots：$\cdots$, $\ldots$, $\ddots$
其它 \infty, \nabla, \partial：$\infty$, $\nabla$, $\partial$

撇号
加一个 hat \hat x $\hat x$，给多个字母加 hat \widehat&#123;abs&#125; $\widehat{abs}$
加一个 bar \bar x $\bar x$，给多个字母加 bar \overline&#123;abs&#125; $\overline{abs}$
小圆点 \dot x $\dot x$, \ddot x $\ddot x$
箭头 \vec&#123;x&#125; $\vec{x}$, \overrightarrow&#123;xy&#125; $\overrightarrow{xy}$

圆括号、方括号和花括号圆括号和方括号默认是没有『弹性』的，也就是说它们不会延伸达到内容完整的高度，例如 z = (\frac&#123;dx&#125;&#123;dy&#125;)^&#123;1/3&#125;：
$$z &#x3D; (\frac{dx}{dy})^{1&#x2F;3}$$
为了使括号延伸，要使用 \left 和 \right，如 $$z = \left(\frac&#123;dx&#125;&#123;dy&#125;\right)^&#123;1/3&#125;$$：
$$z &#x3D; \left(\frac{dx}{dy}\right)^{1&#x2F;3}$$
还有一些无法用键盘创建的特殊的括号。

使用 | 或 \vert 的垂直线，如 $|x|$ 或 $\vert x \vert $。使用 \mid 作括号中间的线。$P(A\vert B)$ 使用 \vert，而 $P(A\mid B)$，使用 \mid
尖括号：$\langle \phi \mid \psi \rangle$ 输出 $\langle \phi \mid \psi \rangle$
矩阵的组括号：\left\lgroup \matrix&#123;a &amp; b\cr c &amp; d&#125; \right\rgroup $$\left\lgroup \matrix{a &amp; b\cr c &amp; d} \right\rgroup$$



字体
对于非斜体的罗马文字，使用 \textrm&#123;Roman&#125; 或 \rm Roman：$\textrm{Roman}$, $\rm Roman$
改变字体大小：\rm\tiny tiny \Tiny Tiny \small small \normalsize normal \large lg \Large Lg \LARGE LG \huge hg \Huge Hg $$\rm\tiny tiny \Tiny Tiny \small small \normalsize normal \large lg \Large Lg \LARGE LG \huge hg \Huge Hg$$
粗体 \mathbf：$$\mathbf{abcdefghijklmnopqrstuvwxyz\\0123456789\\ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$
斜体 \mathit：$$\mathit{abcdefghijklmnopqrstuvwxyz\\0123456789\\ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$
无衬线体 \mathsf：$$\mathsf{abcdefghijklmnopqrstuvwxyz\\0123456789\\ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$
打字机 \mathtt：$$\mathtt{abcdefghijklmnopqrstuvwxyz\\0123456789\\ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$
书法 \mathcal：$$\mathcal{abcdefghijklmnopqrstuvwxyz\\0123456789\\ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$
黑板粗体 \mathbb：$$\mathbb{abcdefghijklmnopqrstuvwxyz\\0123456789\\ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$

空格符号间的空格会被 LaTeX 移除，\int f(x) dx 输出 $\int f(x) dx$，在函数与 $dx$ 间没有空格。你可以使用 \,、\: 与 \; 增加小、中、大空格。\int f(x)\,dx 输出 $\int f(x),dx$。
对于更大的空格，可以使用 \quad 与 \qquad。分别是 1em 和 2em 宽度的空格：$x\quad y$, $x\qquad y$
转义字符有时你想使用 &#123; 或 _ 这样的特殊字符，你需要用反斜线转义它们，如 \&#123;, \_, \$ 分别对应 ${$, $_$, $$$。对于反斜线，要使用 \backslash $\backslash$，因为 \\ 被用来换行。
等式对齐对于连续多行的等式，可以使用 \\ 来换行：
$$
a_1 &#x3D; b_1 + c_1 \\
a_2 &#x3D; b_2 + c_2 + d_2
$$

$$\displaylines{a_1 &#x3D; b_1 + c_1\\a_2 &#x3D; b_2 + c_2 + d_2}$$
等号并没有对齐来提高可读性，使用 \begin&#123;align&#125; 来开始，\end&#123;align&#125; 来结束表达式的显示，&amp; 放在想要等式对齐的位置：
\begin&#123;align&#125;
a_1 &amp; &#x3D; b_1 + c_1 \\
a_2 &amp; &#x3D; b_2 + c_2 + d_2
\end&#123;align&#125;

$$\begin{align}a_1 &amp; &#x3D; b_1 + c_1 \\a_2 &amp; &#x3D; b_2 + c_2 + d_2\end{align}$$

所有 MathJax 可用符号：List of LaTeX mathematical symbols

Udacity’s Data Blog: A Primer on Using LaTeX in Jupyter Notebooks
]]></content>
      <tags>
        <tag>translation</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改 sw-precache</title>
    <url>/2017/12/magic-modify-sw-precache.html</url>
    <content><![CDATA[sw-precache 是一个用来生成预加载资源的 ServiceWorker 的 js 文件的模块。将它用到 Ghost 上后，发现它并不能正常工作，原来 Ghost 会自动给 asset 中的静态文件加上 ?v=#######，而 sw-precache 里记录的是原始的文件名，并不匹配。所以对 sw.js 修改了一下。
&#x2F;&#x2F; sw.js

var url &#x3D; event.request.url;
if (&#x2F;\.(js|css)(\?|$)&#x2F;.test(url) &amp;&amp; &#x2F;^https?:\&#x2F;\&#x2F;(blog\.ihanai\.com|cdnjs\.cloudflare\.com)&#x2F;.test(url)) &#123;
  event.respondWith(
    caches.open(cacheName).then(function (cache) &#123;
      return setOfCachedUrls(cache).then(function (cachedUrls) &#123;
        &#x2F;&#x2F; If we don&#39;t have a key matching url in the cache already, add it.
        var cacheKey &#x3D; event.request.url;
        if (!cachedUrls.has(cacheKey)) &#123;
          return fetch(event.request).then(function (response) &#123;
            if (response.ok || response.type &#x3D;&#x3D;&#x3D; &#39;opaque&#39;) &#123;
              cleanResponse(response).then(function (responseToCache) &#123;
                return cache.put(cacheKey, responseToCache);
              &#125;);
            &#125;
            return response.clone();
          &#125;);
        &#125; else &#123;
          return cache.match(cacheKey).then(function (response) &#123;
              if (response) return response;
              throw Error(&#39;The cached response that was expected is missing.&#39;);
            &#125;)
            .catch(function (e) &#123;
              console.warn(&#39;Couldn\&#39;t serve response for &quot;%s&quot; from cache: %O&#39;, event.request.url, e);
              return fetch(event.request);
            &#125;);
        &#125;
      &#125;);
    &#125;)
  );
&#125;

这里有点需要注意的是使用 response.clone() 避免 TypeError。
当然，这样改了之后，功能变了，由原来的预加载资源文件变成了将部分文件使用 ServiceWorker 作缓存了。
最简单的方法还是修改 sw-precache 的配置，增加 ignoreUrlParametersMatching: [/^utm_/, /^v$/]，这样 sw-precache 就能忽略 assetHash 了。由于生成的 sw.js 文件里有对资源 hash 的记录，所以忽略 Ghost 生成的 assetHash 并不会有什么不好的影响。
说点其它的，使用上面所说的方法将所以 js、css 资源文件用 ServiceWorker 缓存之后发现较 from disk cache 变慢了，原因在于随着 fetch 事件触发次数的增加，sw.js 中的一些代码如 setOfCachedUrls、caches.open 执行了一次又一次，很多结果是相同的，但是并没有缓存，所以实际使用中可以考虑对其进行定制化修改。
]]></content>
      <tags>
        <tag>PWA</tag>
        <tag>ServiceWorker</tag>
        <tag>prefetch</tag>
      </tags>
  </entry>
  <entry>
    <title>使 nginx 日志忽略爬虫</title>
    <url>/2017/12/make-nginx-log-ignore-crawler.html</url>
    <content><![CDATA[map $http_user_agent $log_ua &#123;

    ~Googlebot 0;
    ~Baiduspider 0;
    ~YandexBot 0;
    ~bingbot 0;
    ~MJ12bot 0;
    ~linkdexbot 0;
    ~GridBot 0;

    default 1;
&#125;

server &#123;
    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;blog.ihanai.access.log combined if&#x3D;$log_ua;
&#125;
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 docker-compose 管理 Node.js 项目</title>
    <url>/2017/12/manage-nodejs-project-with-docker-compose.html</url>
    <content><![CDATA[实际开发中，项目会在多种环境中运行，如 local、dev 或者 test 等。我们可以依据不同的运行环境进行配置，使用 docker-compose 来更方便的部署应用。
项目结构
.
├── Dockerfile
├── README.md
├── config
│   ├── config.default.js
│   ├── config.dev.js
│   ├── config.local.js
│   ├── config.prod.js
│   ├── config.sandbox.js
│   ├── config.test.js
├── docker-compose.yml
├── env
│   ├── common.env
│   ├── dev.env
│   ├── local.env
│   ├── prod.env
│   ├── sandbox.env
│   └── test.env
├── package.json
├── view
└── yarn.lock

配置# Dockerfile
FROM node:8-alpine
ADD . &#x2F;code
WORKDIR &#x2F;code
RUN yarn install

# docker-compose.yml
version: &#39;2.1&#39;
services:
  app-local:
    env_file:
      - .&#x2F;env&#x2F;common.env
      - .&#x2F;env&#x2F;local.env
    build:
      context: .
      args:
        NPM_REGISTRY: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot;
    ports:
      - &quot;7005:7005&quot;
    depends_on:
      - redis
    links:
      - redis
    volumes:
      - - &#x2F;path&#x2F;to&#x2F;view:&#x2F;code&#x2F;view
      - .&#x2F;app:&#x2F;code&#x2F;app
    command: [&quot;npm&quot;, &quot;run&quot;, &quot;dev&quot;]
  app-dev:
    env_file:
      - .&#x2F;env&#x2F;common.env
      - .&#x2F;env&#x2F;dev.env
    build:
      context: .
      args:
        NPM_REGISTRY: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot;
    ports:
      - &quot;7005:7005&quot;
    depends_on:
      - redis
    links:
      - redis
    volumes:
      - - &#x2F;path&#x2F;to&#x2F;view:&#x2F;code&#x2F;view
    command: [&quot;npm&quot;, &quot;run&quot;, &quot;start&quot;]
  app-test:
    env_file:
      - .&#x2F;env&#x2F;common.env
      - .&#x2F;env&#x2F;test.env
    build:
      context: .
      args:
        NPM_REGISTRY: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot;
    ports:
      - &quot;7005:7005&quot;
    depends_on:
      - redis
    links:
      - redis
    volumes:
      - &#x2F;path&#x2F;to&#x2F;view:&#x2F;code&#x2F;view
    command: [&quot;npm&quot;, &quot;run&quot;, &quot;start&quot;]
  app-sandbox:
    env_file:
      - .&#x2F;env&#x2F;common.env
      - .&#x2F;env&#x2F;sandbox.env
    build:
      context: .
      args:
        NPM_REGISTRY: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot;
    ports:
      - &quot;7005:7005&quot;
    depends_on:
      - redis
    links:
      - redis
    volumes:
      - &#x2F;path&#x2F;to&#x2F;view:&#x2F;code&#x2F;view
    command: [&quot;npm&quot;, &quot;run&quot;, &quot;start&quot;]
  app-prod:
    env_file:
      - .&#x2F;env&#x2F;common.env
      - .&#x2F;env&#x2F;prod.env
    build:
      context: .
      args:
        NPM_REGISTRY: &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot;
    ports:
      - &quot;7005:7005&quot;
    volumes:
      - &#x2F;code&#x2F;view
    command: [&quot;npm&quot;, &quot;run&quot;, &quot;start&quot;]
  redis:
    image: redis:3.2-alpine
    expose:
      - &quot;6379&quot;

部署build 镜像
$ docker-compose build app-local
$ docker-compose build app-dev
$ docker-compose build app-prod

运行
$ docker-compose up -d app-local
$ docker-compose up -d app-dev
$ docker-compose up -d app-prod
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA 配置参考</title>
    <url>/2017/12/pwa-configure-reference.html</url>
    <content><![CDATA[
Google Web Fundamentals: The Web App Manifest

Apple Safari Web Content Guide: Configuring Web Applications


]]></content>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] React Components, Elements, and Instances</title>
    <url>/2017/12/react-components-elements-instances.html</url>
    <content><![CDATA[管理实例在传统的 UI 模型中，由你管理子组件实例的创建销毁。如果有个 From 想要渲染一个 Button 组件，它需要创建它的实例，并手动根据新的数据更新。
class Form extends TraditionalObjectOrientedView &#123;
  render() &#123;
    &#x2F;&#x2F; Read some data passed to the view
    const &#123; isSubmitted, buttonText &#125; &#x3D; this.attrs;

    if (!isSubmitted &amp;&amp; !this.button) &#123;
      &#x2F;&#x2F; Form is not yet submitted. Create the button!
      this.button &#x3D; new Button(&#123;
        children: buttonText,
        color: &#39;blue&#39;
      &#125;);
      this.el.appendChild(this.button.el);
    &#125;

    if (this.button) &#123;
      &#x2F;&#x2F; The button is visible. Update its text!
      this.button.attrs.children &#x3D; buttonText;
      this.button.render();
    &#125;

    if (isSubmitted &amp;&amp; this.button) &#123;
      &#x2F;&#x2F; Form was submitted. Destroy the button!
      this.el.removeChild(this.button.el);
      this.button.destroy();
    &#125;

    if (isSubmitted &amp;&amp; !this.message) &#123;
      &#x2F;&#x2F; Form was submitted. Show the success message!
      this.message &#x3D; new Message(&#123; text: &#39;Success!&#39; &#125;);
      this.el.appendChild(this.message.el);
    &#125;
  &#125;
&#125;

每一个组件的实例都需要保存它的 DOM 节点以及子组件的实例，并在合适的时间创建、更新、销毁它们。代码行数随着组件可能的状态增多增长的很快，并且父组件可以直接访问子组件的实例，使得未来很难将它们解耦。
那么 React 有什么不同呢？

使用 Element 描述树状结构Element 是描述组件实例或者 DOM 节点及其属性的 plain 对象。一个 Element 并不是实例，不能从它调用任何方法。它有两个字段 type: (string | ReactClass) 和 props: Object。
DOM Elements当 element 的 type 为字符串时，它表示一个 DOM 节点。
&#123;
  type: &#39;button&#39;,
  props: &#123;
    className: &#39;button button-blue&#39;,
    children: &#123;
      type: &#39;b&#39;,
      props: &#123;
        children: &#39;OK!&#39;
      &#125;
    &#125;
  &#125;
&#125;

Component Elements当 element 的 type 为函数或类时，它表示一个 React 组件。
&#123;
  type: Button,
  props: &#123;
    color: &#39;blue&#39;,
    children: &#39;OK!&#39;
  &#125;
&#125;

就像描述 DOM 节点，描述组件的 element 依旧是 element。它们之间可以相互嵌套混合。

组件封装 Element 树当 React 看到 element 的 type 是函数或类时，它会询问组件要渲染什么 element，给它对应的 props。
例如如下 element：
&#123;
  type: Button,
  props: &#123;
    color: &#39;blue&#39;,
    children: &#39;OK!&#39;
  &#125;
&#125;

React 会询问 Button 它要渲染什么，而 Button 会返回如下 element：
&#123;
  type: &#39;button&#39;,
  props: &#123;
    className: &#39;button button-blue&#39;,
    children: &#123;
      type: &#39;b&#39;,
      props: &#123;
        children: &#39;OK!&#39;
      &#125;
    &#125;
  &#125;
&#125;

React 会重复这个过程直到获得每个组件下面的 DOM 标签。
返回的 element 树可以包含描述 DOM 节点的 element 和描述其他组件的 element。这使您可以在不依赖内部 DOM 结构的情况下编写独立的 UI 部分。
我们让 React 创建、更新和销毁实例，我们使用从组件返回的 element 来描述它们，而 React 负责管理这些实例。

组件可以是类或函数有三种大致等价的声明组件的方式：
&#x2F;&#x2F; 1) 作为接受 props 的函数
const Button &#x3D; (&#123; children, color &#125;) &#x3D;&gt; (&#123;
  type: &#39;button&#39;,
  props: &#123;
    className: &#39;button button-&#39; + color,
    children: &#123;
      type: &#39;b&#39;,
      props: &#123;
        children: children
      &#125;
    &#125;
  &#125;
&#125;);

&#x2F;&#x2F; 2) 使用 React.createClass() 工厂函数
const Button &#x3D; React.createClass(&#123;
  render() &#123;
    const &#123; children, color &#125; &#x3D; this.props;
    return &#123;
      type: &#39;button&#39;,
      props: &#123;
        className: &#39;button button-&#39; + color,
        children: &#123;
          type: &#39;b&#39;,
          props: &#123;
            children: children
          &#125;
        &#125;
      &#125;
    &#125;;
  &#125;
&#125;);

&#x2F;&#x2F; 3) 使用 ES6 class 继承自 React.Component
class Button extends React.Component &#123;
  render() &#123;
    const &#123; children, color &#125; &#x3D; this.props;
    return &#123;
      type: &#39;button&#39;,
      props: &#123;
        className: &#39;button button-&#39; + color,
        children: &#123;
          type: &#39;b&#39;,
          props: &#123;
            children: children
          &#125;
        &#125;
      &#125;
    &#125;;
  &#125;
&#125;

使用 class 来定义组件时，它比函数式组件更强大。它可以保存一些本地状态，并在对应 DOM 节点创建销毁时执行自定义的逻辑。
无论函数或类，它们本质上都是 React 组件。它们接受 props 作为输入，返回 element 作为输出。

由上而下 Reconciliation调用：
ReactDOM.render(&#123;
  type: Form,
  props: &#123;
    isSubmitted: false,
    buttonText: &#39;OK!&#39;
  &#125;
&#125;, document.getElementById(&#39;root&#39;));

React 会给 Form 组件 props，获得返回的 element 树。它将逐渐 refine 它对组件树的理解，以简单的原语表示。
&#123;
  type: Form,
  props: &#123;
    isSubmitted: false,
    buttonText: &#39;OK!&#39;
  &#125;
&#125;

&#x2F;&#x2F; 从 From 找到 Button
&#123;
  type: Button,
  props: &#123;
    children: &#39;OK!&#39;,
    color: &#39;blue&#39;
  &#125;
&#125;

&#x2F;&#x2F; 从 Button 找到 button
&#123;
  type: &#39;button&#39;,
  props: &#123;
    className: &#39;button button-blue&#39;,
    children: &#123;
      type: &#39;b&#39;,
      props: &#123;
        children: &#39;OK!&#39;
      &#125;
    &#125;
  &#125;
&#125;

这部分处理被 React 称作 reconciliation，它在 ReactDOM.render() 或 setState() 时执行。reconciliation 结束后，React 获知最终的 DOM 树，像 react-dom 或 react-native 那样的 render 会采取最小的改动来更新 DOM 节点（或者 React Native 那样特定平台的视图）。
这个逐渐 refining 的过程也是 React 应用易于优化的原因。如果组件树的某些部分变得太大而无法高效地被 React 访问，那么你可以告诉它如果相关的 props 没有改变，就跳过这个 refining 和 diffing。如果 props 是不可变（immutable）的，计算 props 是否改变的速度非常快。所以可以同时使用 React 和 immutability，并且可以用最小的工作提供很大的优化。
只有类组件有实例，并且你不应该直接创建它们，React 为你做了这些。虽然父组件实例访问子组件实例的机制存在，但它们仅用于必要的操作（例如设置焦点在字段上），通常应避免。
React 负责为每个类组件创建一个实例，因此可以用方法和本地状态以面向对象的方式编写组件，但除此之外，实例在React的编程模型中并不是非常重要，并且由 React 本身来管理。

总结element 是描述 DOM 节点或其它组件的 plain 对象。elememt 可以在 props 中包含其它 elememt。创建 element 很容易。一旦创建后它不可修改。
一个组件可以用几种不同的方式来声明。它可以是一个带有 render() 方法的类。在简单的情况下，它可以被定义为一个函数。无论哪种情况，都需要 props 作为输入，并返回一个 elememt 树作为输出。
一个实例就是在类组件中用 this 引用的。这对于存储本地状态和对生命周期事件做出反应非常有用。
函数式组件没有实例，类组件有实例。
创建 elements 要使用 React.createElement()、JSX 或者一个 element 工厂函数。不要在实际代码中用纯对象写 elements。

延伸阅读
React Blog: Introducing React Elements
React Blog: Streamlining React Elements
React Doc: React (Virtual) DOM Terminology


注：由于安全原因，所有的 React emelents 需要一个额外的 $$typeof: Symbol.for(&#39;react.element&#39;) 字段定义在对象上。

React Blog: React Components, Elements, and Instances
]]></content>
      <tags>
        <tag>React</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title>统计基础 1</title>
    <url>/2017/12/statistical-basics-1.html</url>
    <content><![CDATA[统计研究方法入门建构建构（Constructs，即抽象概念）：建构是任何难以衡量的东西，因为它可以用许多不同的方式来定义和衡量。
操作定义（Operational Definition）：建构的操作定义是我们用于度量建构的单位。 一旦我们在操作上定义了一些东西，它就不再是一个建构。
例：容量是一个建构。我们知道容量是某物占据的空间，但我们还没有定义如何度量这个空间（即升、加仑等）。当我们要用升来度量容量的时候，它不再是一个建构，而是操作定义。
例：分钟已被操作定义了，我们正在测量的东西没有含糊之处。
总体与样本总体（Population）：一个群体中的所有个体。样本（Sample）：一个群体中的部分个体。
参数（Parameter）与统计值（Statistic）：参数定义总体的特征，统计值定义样本的特征。
例：总体的平均值用符号 $\mu$ 定义，样本的平均值用 $\bar x$ 定义。
实验治疗组（Treatment Group）：接受不同程度自变量的研究小组，这些小组被用来衡量治疗的效果。
对照组（Control Group）：一个没有得到任何治疗的研究小组。这个组被用作比较治疗组的基线。
安慰剂（Placebo）：给对照组的受试者一些东西，让他们认为他们正在接受治疗，而实际上他们正在得到一些对他们没有任何影响的东西。（例如糖丸）
盲法（Blinding）：盲法是一种用来减少偏见的技术。双盲法可确保执行治疗和接受治疗的患者不知道接受哪种治疗。

数据可视化频率频率（Frequency）：数据集的频率是某个结果发生的次数。

这个直方图显示从 0-5 学生测试的分数。我们看到没有学生得 0 分，8 名学生得 1 分。这些数字就是学生成绩的频率。
比例（Proportion）：比例是计数除以总样本的分数。比例可以通过乘以 100 来变成百分数。
例：使用上面的直方图，我们可以看出得 1 分学生的比例为 $\frac{8}{39} \approx 0.2051$ 或 $20.51\%$


直方图直方图（Histogram）：直方图是数据分布的图形表示，组距决定箱子宽度。
调整直方图的组距（bin size）大小将压缩（或展开）分布。

组距为 1


组距为 2


组距为 5

偏斜分布（Skewed Distribution）
正偏斜（Positive Skew）：异常值出现在分布的最右端

负偏斜（Negative Skew）：异常值出现在分布的最左端


集中趋势均值、中位数和众数均值（Mean）：数据集的均值是数值的平均值，可以通过将所有数据点之和除以数据点数来计算：$$\bar x &#x3D; \frac{\Sigma^{n}_{i &#x3D; 0}x_i}{n}$$
均值受到异常值的影响严重，因此我们说均值不是一个稳健的度量。
中位数（Median）：数据集的中位数是直接位于数据集中间的数据点。如果有两个数字在中间，那么中位数就是这两者的平均数。

数据集有奇数个数据，$n &#x2F; 2$ 为数据集中中位数的位置
数据集有偶数个数据，$\frac{x_k + x_{k + 1}}{n}$ 给出中间两个数据点的均值

中位数对于异常值是稳健的，因此异常值不会影响中位数的值。
众数（Mode）：数据集的众数是数据集中出现频率最高的数据点。
众数对异常值也稳健。
正态分布中，均值 &#x3D; 中位数 &#x3D; 众数



差异性箱形图与 IQR箱形图（boxplot）是以一种视觉上吸引人的方式展示数据集的 5 个摘要值的方法。 这 5 个值包括最小值、第一四分位数、中位数、第三四分位数和最大值
四分位间距（Interquartile range）：四分位间距（IQR）是第一个四分位数与第三个四分位数之间的距离，它给出了我们数据中间 $50\%$ 的范围。$IQR &#x3D; Q3 - Q1$

找出异常值如何识别异常值：使用 IQR 识别异常值（outlier）
上界：$Q3 + 1.5 \cdot IQR$下界：$Q1 - 1.5 \cdot IQR$
方差和标准差方差（Variance）：方差是平均差的均值。 计算方差的公式是：$$\sigma^2&#x3D;\frac{\Sigma^{n}_{i&#x3D;0}(x_i - \bar{x})^2}{n}$$
标准差（Standard Deviation）：标准差是方差的平方根，用来衡量到均值的距离。
在正态分布中，$65\%$ 的数据与均值有 1 个标准偏差，2 个标准差内有 $95\%$，3 个标准差内有 $99.7\%$。
通常，抽样会低估了总体中差异性的数量，因为抽样往往是总体居于中间的值。特别是在正态分布中，多数值位于中间位置。因此我们从正态分布的总体中抽样时，多数值也在此处附近。因此样本的差异性将少于总体的差异性。
贝塞耳校正（Bessel’s Correction）：校正对总体方差与标准差的预估。为了应用贝塞尔校正，我们用方差乘以 $\frac{n}{n - 1}$。
使用贝塞尔校正主要是为了估计总体标准差。
样本标准差
$$\mathrm s &#x3D; \sqrt{\frac{\Sigma{(x_i - \bar {x})^2}}{n - 1}} \approx \sigma &#x3D; \sqrt{\frac{\Sigma{(x_i - \bar {x})^2}}{n}}$$
]]></content>
      <tags>
        <tag>Statistics</tag>
        <tag>统计基础</tag>
      </tags>
  </entry>
  <entry>
    <title>统计基础 2</title>
    <url>/2017/12/statistical-basics-2.html</url>
    <content><![CDATA[归一化Z值（Z score）标准值（Standard Score）：给定一个观察值 x，Z 值表示 x 偏离均值多少个标准差。
$$ Z &#x3D; \frac{x - \mu}{\sigma} $$
标准正态曲线（Standard Normal Curve）：标准正态曲线是归一化的结果。我们使用这个分布与 Z 值表来计算给定值之上、之下、之间的百分比。

正态分布概率分布函数（Probability Distribution Function）概率分布函数（PDF）是一个下面面积为 1 的正态曲线，用来表示值的累积频率。

使用 Z 值表找出概率例：某私立大学学生的平均身高是 1.85m，标准差为 0.15m。求身高低于 2.05m 的学生的比例。

解决此题要先计算出 Z 值：$$ z &#x3D; \frac{x - \mu}{\sigma} &#x3D; \frac{2.05 - 1.85}{0.15} &#x3D; 1.\bar{3} $$
然后从 Z 值表中找出 Z 值低于 1.33 的比例。
如图：

查表得 $90.82\%$
]]></content>
      <tags>
        <tag>Statistics</tag>
        <tag>统计基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 快速启用 BBR</title>
    <url>/2017/12/ubuntu-enable-bbr-quickly.html</url>
    <content><![CDATA[网上看到好多开启 BBR 的方法都是从源码编译 Linux 内核，然而现在一些发行版的 tcp_bbr module 已是直接可用的，所以只需在 /etc/sysctl.conf 中启用即可。
判断是否有已编译好的 tcp_bbr 模块
$ find &#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;kernel&#x2F; -iname &quot;*bbr*&quot;
&#x2F;lib&#x2F;modules&#x2F;4.10.0-40-generic&#x2F;kernel&#x2F;net&#x2F;ipv4&#x2F;tcp_bbr.ko

在 /etc/sysctl.conf 中启用 BBR
$ sudo bash -c &#39;echo &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf&#39;

应用变动
$ sudo sysctl -p
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>BBR</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VueRouter 源码全解：history</title>
    <url>/2017/12/vue-router-source-code-full-analysis-history.html</url>
    <content><![CDATA[前言history 是 vue-router 中代码量最大的部分，此模块中共有 4 个文件：

abstract.js
base.js
hash.js
html5.js

base.js 定义了基类 History，其它三个文件中的类都继承自 History。abstract.js, hash.js, html5.js 别对应了 vue-router 设置中 mode 的三个值。hash.js, html5.js 适用于浏览器中的环境。abstract.js 适用于 node.js 环境。
读码base.js&#x2F;* @flow *&#x2F;

import &#123; _Vue &#125; from &#39;..&#x2F;install&#39;
import type Router from &#39;..&#x2F;index&#39;
import &#123; inBrowser &#125; from &#39;..&#x2F;util&#x2F;dom&#39;
import &#123; runQueue &#125; from &#39;..&#x2F;util&#x2F;async&#39;
import &#123; warn, isError &#125; from &#39;..&#x2F;util&#x2F;warn&#39;
import &#123; START, isSameRoute &#125; from &#39;..&#x2F;util&#x2F;route&#39;
import &#123;
  flatten,
  flatMapComponents,
  resolveAsyncComponents
&#125; from &#39;..&#x2F;util&#x2F;resolve-components&#39;

&#x2F;&#x2F; 定义基类 History
export class History &#123;
  router: Router;
  base: string;
  current: Route;
  pending: ?Route;
  cb: (r: Route) &#x3D;&gt; void;
  ready: boolean;
  readyCbs: Array&lt;Function&gt;;
  readyErrorCbs: Array&lt;Function&gt;;
  errorCbs: Array&lt;Function&gt;;

  &#x2F;&#x2F; 在子类中实现以下方法
  +go: (n: number) &#x3D;&gt; void;  &#x2F;&#x2F; 只读的 go 方法
  +push: (loc: RawLocation) &#x3D;&gt; void;  &#x2F;&#x2F; 只读的 push 方法
  +replace: (loc: RawLocation) &#x3D;&gt; void;  &#x2F;&#x2F; 只读的 replace 方法
  +ensureURL: (push?: boolean) &#x3D;&gt; void;  &#x2F;&#x2F; 只读的 ensureURL 方法，若当前路由的路径与实际路径不等时，则 push 或 replace
  +getCurrentLocation: () &#x3D;&gt; string;  &#x2F;&#x2F; 只读的 getCurrentLocation 方法，获取当前实际的路径

  constructor (router: Router, base: ?string) &#123;
    this.router &#x3D; router
    this.base &#x3D; normalizeBase(base)  &#x2F;&#x2F; 归一化 base URL
    &#x2F;&#x2F; start with a route object that stands for &quot;nowhere&quot;
    this.current &#x3D; START
    this.pending &#x3D; null
    this.ready &#x3D; false  &#x2F;&#x2F; 完成路由初始导航后变为 true
    this.readyCbs &#x3D; []
    this.readyErrorCbs &#x3D; []
    this.errorCbs &#x3D; []
  &#125;

  listen (cb: Function) &#123;
    this.cb &#x3D; cb
  &#125;

  &#x2F;&#x2F; 该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。
  &#x2F;&#x2F; 这可以有效确保服务端渲染时服务端和客户端输出的一致。
  onReady (cb: Function, errorCb: ?Function) &#123;
    if (this.ready) &#123;
      cb()
    &#125; else &#123;
      this.readyCbs.push(cb)
      if (errorCb) &#123;
        this.readyErrorCbs.push(errorCb)
      &#125;
    &#125;
  &#125;

  &#x2F;&#x2F; 注册一个回调，该回调会在路由导航过程中出错时被调用。
  onError (errorCb: Function) &#123;
    this.errorCbs.push(errorCb)
  &#125;

  &#x2F;&#x2F; 路径跳转
  transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;
    const route &#x3D; this.router.match(location, this.current)
    this.confirmTransition(route, () &#x3D;&gt; &#123;  &#x2F;&#x2F; 执行跳转
      this.updateRoute(route)
      onComplete &amp;&amp; onComplete(route)
      this.ensureURL()  &#x2F;&#x2F; 切换路径

      &#x2F;&#x2F; fire ready cbs once
      if (!this.ready) &#123;
        this.ready &#x3D; true
        this.readyCbs.forEach(cb &#x3D;&gt; &#123; cb(route) &#125;)  &#x2F;&#x2F; 路由完成初始导航后回调
      &#125;
    &#125;, err &#x3D;&gt; &#123;
      if (onAbort) &#123;
        onAbort(err)
      &#125;
      if (err &amp;&amp; !this.ready) &#123;
        &#x2F;&#x2F; 初始化路由解析运行出错
        this.ready &#x3D; true
        this.readyErrorCbs.forEach(cb &#x3D;&gt; &#123; cb(err) &#125;)
      &#125;
    &#125;)
  &#125;

  &#x2F;&#x2F; transition 中进行修改 url 的操作，history 栈操作在不同 History 子类中实现
  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) &#123;
    const current &#x3D; this.current
    const abort &#x3D; err &#x3D;&gt; &#123;
      if (isError(err)) &#123;
        if (this.errorCbs.length) &#123;
          this.errorCbs.forEach(cb &#x3D;&gt; &#123; cb(err) &#125;)
        &#125; else &#123;
          warn(false, &#39;uncaught error during route navigation:&#39;)
          console.error(err)
        &#125;
      &#125;
      onAbort &amp;&amp; onAbort(err)
    &#125;
    if (
      isSameRoute(route, current) &amp;&amp;
      &#x2F;&#x2F; in the case the route map has been dynamically appended to
      route.matched.length &#x3D;&#x3D;&#x3D; current.matched.length
    ) &#123;
      this.ensureURL()
      return abort()
    &#125;

    const &#123;
      updated,
      deactivated,
      activated
    &#125; &#x3D; resolveQueue(this.current.matched, route.matched)

    const queue: Array&lt;?NavigationGuard&gt; &#x3D; [].concat(
      &#x2F;&#x2F; in-component leave guards
      extractLeaveGuards(deactivated),
      &#x2F;&#x2F; global before hooks
      this.router.beforeHooks,
      &#x2F;&#x2F; in-component update hooks
      extractUpdateHooks(updated),
      &#x2F;&#x2F; in-config enter guards
      activated.map(m &#x3D;&gt; m.beforeEnter),
      &#x2F;&#x2F; async components
      resolveAsyncComponents(activated)
    )

    this.pending &#x3D; route
    const iterator &#x3D; (hook: NavigationGuard, next) &#x3D;&gt; &#123;
      if (this.pending !&#x3D;&#x3D; route) &#123;
        return abort()
      &#125;
      try &#123;
        hook(route, current, (to: any) &#x3D;&gt; &#123;
          if (to &#x3D;&#x3D;&#x3D; false || isError(to)) &#123;
            &#x2F;&#x2F; next(false) -&gt; abort navigation, ensure current URL
            this.ensureURL(true)
            abort(to)
          &#125; else if (
            typeof to &#x3D;&#x3D;&#x3D; &#39;string&#39; ||
            (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; (
              typeof to.path &#x3D;&#x3D;&#x3D; &#39;string&#39; ||
              typeof to.name &#x3D;&#x3D;&#x3D; &#39;string&#39;
            ))
          ) &#123;
            &#x2F;&#x2F; next(&#39;&#x2F;&#39;) or next(&#123; path: &#39;&#x2F;&#39; &#125;) -&gt; redirect
            abort()
            if (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; to.replace) &#123;
              this.replace(to)
            &#125; else &#123;
              this.push(to)
            &#125;
          &#125; else &#123;
            &#x2F;&#x2F; confirm transition and pass on the value
            next(to)
          &#125;
        &#125;)
      &#125; catch (e) &#123;
        abort(e)
      &#125;
    &#125;

    runQueue(queue, iterator, () &#x3D;&gt; &#123;
      const postEnterCbs &#x3D; []
      const isValid &#x3D; () &#x3D;&gt; this.current &#x3D;&#x3D;&#x3D; route
      &#x2F;&#x2F; wait until async components are resolved before
      &#x2F;&#x2F; extracting in-component enter guards
      const enterGuards &#x3D; extractEnterGuards(activated, postEnterCbs, isValid)
      const queue &#x3D; enterGuards.concat(this.router.resolveHooks)
      runQueue(queue, iterator, () &#x3D;&gt; &#123;
        if (this.pending !&#x3D;&#x3D; route) &#123;
          return abort()
        &#125;
        this.pending &#x3D; null
        onComplete(route)
        if (this.router.app) &#123;
          this.router.app.$nextTick(() &#x3D;&gt; &#123;
            postEnterCbs.forEach(cb &#x3D;&gt; &#123; cb() &#125;)
          &#125;)
        &#125;
      &#125;)
    &#125;)
  &#125;

  updateRoute (route: Route) &#123;
    const prev &#x3D; this.current
    this.current &#x3D; route
    this.cb &amp;&amp; this.cb(route)
    this.router.afterHooks.forEach(hook &#x3D;&gt; &#123;
      hook &amp;&amp; hook(route, prev)
    &#125;)
  &#125;
&#125;

&#x2F;&#x2F; 归一化 base URL
function normalizeBase (base: ?string): string &#123;
  if (!base) &#123;
    if (inBrowser) &#123;
      &#x2F;&#x2F; 检查 &lt;base&gt; 标签
      &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;HTML&#x2F;Element&#x2F;base
      const baseEl &#x3D; document.querySelector(&#39;base&#39;)
      base &#x3D; (baseEl &amp;&amp; baseEl.getAttribute(&#39;href&#39;)) || &#39;&#x2F;&#39;
      &#x2F;&#x2F; 去除协议、域名、端口，不使用完整 URL
      base &#x3D; base.replace(&#x2F;^https?:\&#x2F;\&#x2F;[^\&#x2F;]+&#x2F;, &#39;&#39;)
    &#125; else &#123;
      base &#x3D; &#39;&#x2F;&#39; &#x2F;&#x2F; 非浏览器环境以 &#x2F; 为 base URL
    &#125;
  &#125;
  &#x2F;&#x2F; 使 URL 以 &#x2F; 开头
  if (base.charAt(0) !&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
    base &#x3D; &#39;&#x2F;&#39; + base
  &#125;
  &#x2F;&#x2F; 移除末尾的 &#x2F;
  return base.replace(&#x2F;\&#x2F;$&#x2F;, &#39;&#39;)
&#125;

function resolveQueue (
  current: Array&lt;RouteRecord&gt;,
  next: Array&lt;RouteRecord&gt;
): &#123;
  updated: Array&lt;RouteRecord&gt;,
  activated: Array&lt;RouteRecord&gt;,
  deactivated: Array&lt;RouteRecord&gt;
&#125; &#123;
  let i
  const max &#x3D; Math.max(current.length, next.length)
  for (i &#x3D; 0; i &lt; max; i++) &#123;
    if (current[i] !&#x3D;&#x3D; next[i]) &#123;
      break
    &#125;
  &#125;
  return &#123;
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  &#125;
&#125;

function extractGuards (
  records: Array&lt;RouteRecord&gt;,
  name: string,
  bind: Function,
  reverse?: boolean
): Array&lt;?Function&gt; &#123;
  const guards &#x3D; flatMapComponents(records, (def, instance, match, key) &#x3D;&gt; &#123;
    const guard &#x3D; extractGuard(def, name)
    if (guard) &#123;
      return Array.isArray(guard)
        ? guard.map(guard &#x3D;&gt; bind(guard, instance, match, key))
        : bind(guard, instance, match, key)
    &#125;
  &#125;)
  return flatten(reverse ? guards.reverse() : guards)
&#125;

function extractGuard (
  def: Object | Function,
  key: string
): NavigationGuard | Array&lt;NavigationGuard&gt; &#123;
  if (typeof def !&#x3D;&#x3D; &#39;function&#39;) &#123;
    &#x2F;&#x2F; extend now so that global mixins are applied.
    def &#x3D; _Vue.extend(def)
  &#125;
  return def.options[key]
&#125;

function extractLeaveGuards (deactivated: Array&lt;RouteRecord&gt;): Array&lt;?Function&gt; &#123;
  return extractGuards(deactivated, &#39;beforeRouteLeave&#39;, bindGuard, true)
&#125;

function extractUpdateHooks (updated: Array&lt;RouteRecord&gt;): Array&lt;?Function&gt; &#123;
  return extractGuards(updated, &#39;beforeRouteUpdate&#39;, bindGuard)
&#125;

function bindGuard (guard: NavigationGuard, instance: ?_Vue): ?NavigationGuard &#123;
  if (instance) &#123;
    return function boundRouteGuard () &#123;
      return guard.apply(instance, arguments)
    &#125;
  &#125;
&#125;

function extractEnterGuards (
  activated: Array&lt;RouteRecord&gt;,
  cbs: Array&lt;Function&gt;,
  isValid: () &#x3D;&gt; boolean
): Array&lt;?Function&gt; &#123;
  return extractGuards(activated, &#39;beforeRouteEnter&#39;, (guard, _, match, key) &#x3D;&gt; &#123;
    return bindEnterGuard(guard, match, key, cbs, isValid)
  &#125;)
&#125;

function bindEnterGuard (
  guard: NavigationGuard,
  match: RouteRecord,
  key: string,
  cbs: Array&lt;Function&gt;,
  isValid: () &#x3D;&gt; boolean
): NavigationGuard &#123;
  return function routeEnterGuard (to, from, next) &#123;
    return guard(to, from, cb &#x3D;&gt; &#123;
      next(cb)
      if (typeof cb &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
        cbs.push(() &#x3D;&gt; &#123;
          &#x2F;&#x2F; #750
          &#x2F;&#x2F; if a router-view is wrapped with an out-in transition,
          &#x2F;&#x2F; the instance may not have been registered at this time.
          &#x2F;&#x2F; we will need to poll for registration until current route
          &#x2F;&#x2F; is no longer valid.
          poll(cb, match.instances, key, isValid)
        &#125;)
      &#125;
    &#125;)
  &#125;
&#125;

function poll (
  cb: any, &#x2F;&#x2F; somehow flow cannot infer this is a function
  instances: Object,
  key: string,
  isValid: () &#x3D;&gt; boolean
) &#123;
  if (instances[key]) &#123;
    cb(instances[key])
  &#125; else if (isValid()) &#123;
    setTimeout(() &#x3D;&gt; &#123;
      poll(cb, instances, key, isValid)
    &#125;, 16)
  &#125;
&#125;

abstract.js最简单的 history 类，适用于非浏览器环境
&#x2F;* @flow *&#x2F;

import type Router from &#39;..&#x2F;index&#39;
import &#123; History &#125; from &#39;.&#x2F;base&#39;

export class AbstractHistory extends History &#123;
  index: number;
  stack: Array&lt;Route&gt;;

  constructor (router: Router, base: ?string) &#123;
    super(router, base)
    this.stack &#x3D; []  &#x2F;&#x2F; history 栈
    this.index &#x3D; -1  &#x2F;&#x2F; 栈指针
  &#125;

  push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;
    this.transitionTo(location, route &#x3D;&gt; &#123;  &#x2F;&#x2F; 调用父类中的 transitionTo 进行路径跳转
      this.stack &#x3D; this.stack.slice(0, this.index + 1).concat(route)  &#x2F;&#x2F; 入栈
      this.index++
      onComplete &amp;&amp; onComplete(route)
    &#125;, onAbort)
  &#125;

  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;
    this.transitionTo(location, route &#x3D;&gt; &#123;
      this.stack &#x3D; this.stack.slice(0, this.index).concat(route)  &#x2F;&#x2F; replace 栈顶 route，不改变栈指针
      onComplete &amp;&amp; onComplete(route)
    &#125;, onAbort)
  &#125;

  go (n: number) &#123;
    const targetIndex &#x3D; this.index + n
    if (targetIndex &lt; 0 || targetIndex &gt;&#x3D; this.stack.length) &#123;
      return
    &#125;
    const route &#x3D; this.stack[targetIndex]
    this.confirmTransition(route, () &#x3D;&gt; &#123;
      this.index &#x3D; targetIndex
      this.updateRoute(route)
    &#125;)
  &#125;

  getCurrentLocation () &#123;
    const current &#x3D; this.stack[this.stack.length - 1]
    return current ? current.fullPath : &#39;&#x2F;&#39;
  &#125;

  ensureURL () &#123;
    &#x2F;&#x2F; noop
  &#125;
&#125;
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>VueRouter 源码全解：0</title>
    <url>/2017/12/vue-router-source-code-full-analysis-0.html</url>
    <content><![CDATA[install.js为 Vue 插件定义 install 方法（Vue.js: Plugins）。
import View from &#39;.&#x2F;components&#x2F;view&#39;
import Link from &#39;.&#x2F;components&#x2F;link&#39;

export let _Vue

export function install (Vue) &#123;
  if (install.installed &amp;&amp; _Vue &#x3D;&#x3D;&#x3D; Vue) return  &#x2F;&#x2F; 避免重复安装
  install.installed &#x3D; true

  _Vue &#x3D; Vue

  const isDef &#x3D; v &#x3D;&gt; v !&#x3D;&#x3D; undefined

  const registerInstance &#x3D; (vm, callVal) &#x3D;&gt; &#123;
    let i &#x3D; vm.$options._parentVnode &#x2F;&#x2F; 获取组件的父节点
    if (isDef(i) &amp;&amp; isDef(i &#x3D; i.data) &amp;&amp; isDef(i &#x3D; i.registerRouteInstance)) &#123;  &#x2F;&#x2F; 判断是否是 router-view
      i(vm, callVal)  &#x2F;&#x2F; 执行 router-view 的 registerRouteInstance 方法
    &#125;
  &#125;

  &#x2F;&#x2F; 为所有组件 mixin 方法
  Vue.mixin(&#123;
    beforeCreate () &#123;  &#x2F;&#x2F; 实例创建
      if (isDef(this.$options.router)) &#123;  &#x2F;&#x2F; 判断是否是路由的根实例（使用 new Vue(&#123;router&#125;) 创建，一般为 app）
        this._routerRoot &#x3D; this  &#x2F;&#x2F; 绑定到 this._routerRoot
        this._router &#x3D; this.$options.router
        this._router.init(this)  &#x2F;&#x2F; 在路由的根实例初始化 vue-router
        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)
      &#125; else &#123;
        this._routerRoot &#x3D; (this.$parent &amp;&amp; this.$parent._routerRoot) || this  &#x2F;&#x2F; 使非路由根实例的 _routerRoot 指向路由的根实例
      &#125;
      registerInstance(this, this)
    &#125;,
    destroyed () &#123;  &#x2F;&#x2F; 实例销毁
      registerInstance(this)
    &#125;
  &#125;)

  &#x2F;&#x2F; 为所有 Vue 实例增加 $router 属性，用于获取路由根实例的 _router 属性
  Object.defineProperty(Vue.prototype, &#39;$router&#39;, &#123;
    get () &#123; return this._routerRoot._router &#125;
  &#125;)

  &#x2F;&#x2F; 为所有 Vue 实例增加 $route 属性，用于获取路由根实例的 _route 属性
  Object.defineProperty(Vue.prototype, &#39;$route&#39;, &#123;
    get () &#123; return this._routerRoot._route &#125;
  &#125;)

  Vue.component(&#39;router-view&#39;, View)  &#x2F;&#x2F; 注册全局组件 router-view
  Vue.component(&#39;router-link&#39;, Link)  &#x2F;&#x2F; 注册全局组件 router-link

  const strats &#x3D; Vue.config.optionMergeStrategies
  &#x2F;&#x2F; 路由钩子使用相同的合并策略 https:&#x2F;&#x2F;vuejs.org&#x2F;v2&#x2F;guide&#x2F;mixins.html#Custom-Option-Merge-Strategies
  strats.beforeRouteEnter &#x3D; strats.beforeRouteLeave &#x3D; strats.beforeRouteUpdate &#x3D; strats.created
&#125;


index.js&#x2F;* @flow *&#x2F;

import &#123; install &#125; from &#39;.&#x2F;install&#39;
import &#123; START &#125; from &#39;.&#x2F;util&#x2F;route&#39;
import &#123; assert &#125; from &#39;.&#x2F;util&#x2F;warn&#39;
import &#123; inBrowser &#125; from &#39;.&#x2F;util&#x2F;dom&#39;
import &#123; cleanPath &#125; from &#39;.&#x2F;util&#x2F;path&#39;
import &#123; createMatcher &#125; from &#39;.&#x2F;create-matcher&#39;
import &#123; normalizeLocation &#125; from &#39;.&#x2F;util&#x2F;location&#39;
import &#123; supportsPushState &#125; from &#39;.&#x2F;util&#x2F;push-state&#39;

import &#123; HashHistory &#125; from &#39;.&#x2F;history&#x2F;hash&#39;
import &#123; HTML5History &#125; from &#39;.&#x2F;history&#x2F;html5&#39;
import &#123; AbstractHistory &#125; from &#39;.&#x2F;history&#x2F;abstract&#39;

import type &#123; Matcher &#125; from &#39;.&#x2F;create-matcher&#39;

export default class VueRouter &#123;
  static install: () &#x3D;&gt; void;
  static version: string;

  app: any;
  apps: Array&lt;any&gt;;
  ready: boolean;
  readyCbs: Array&lt;Function&gt;;
  options: RouterOptions;
  mode: string;
  history: HashHistory | HTML5History | AbstractHistory;
  matcher: Matcher;
  fallback: boolean;
  beforeHooks: Array&lt;?NavigationGuard&gt;;
  resolveHooks: Array&lt;?NavigationGuard&gt;;
  afterHooks: Array&lt;?AfterNavigationHook&gt;;

  constructor (options: RouterOptions &#x3D; &#123;&#125;) &#123;
    this.app &#x3D; null
    this.apps &#x3D; []
    this.options &#x3D; options
    this.beforeHooks &#x3D; []
    this.resolveHooks &#x3D; []
    this.afterHooks &#x3D; []
    this.matcher &#x3D; createMatcher(options.routes || [], this)

    let mode &#x3D; options.mode || &#39;hash&#39;
    this.fallback &#x3D; mode &#x3D;&#x3D;&#x3D; &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !&#x3D;&#x3D; false
    if (this.fallback) &#123;
      mode &#x3D; &#39;hash&#39;
    &#125;
    if (!inBrowser) &#123;
      mode &#x3D; &#39;abstract&#39;
    &#125;
    this.mode &#x3D; mode

    switch (mode) &#123;  &#x2F;&#x2F; 根据不同 mode 实例化不同的 History
      case &#39;history&#39;:
        this.history &#x3D; new HTML5History(this, options.base)
        break
      case &#39;hash&#39;:
        this.history &#x3D; new HashHistory(this, options.base, this.fallback)
        break
      case &#39;abstract&#39;:
        this.history &#x3D; new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;
          assert(false, &#96;invalid mode: $&#123;mode&#125;&#96;)
        &#125;
    &#125;
  &#125;

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route &#123;
    return this.matcher.match(raw, current, redirectedFrom)
  &#125;

  get currentRoute (): ?Route &#123;
    return this.history &amp;&amp; this.history.current
  &#125;

  init (app: any &#x2F;* Vue component instance *&#x2F;) &#123;
    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; assert(
      install.installed,
      &#96;not installed. Make sure to call \&#96;Vue.use(VueRouter)\&#96; &#96; +
      &#96;before creating root instance.&#96;
    )

    this.apps.push(app)

    &#x2F;&#x2F; main app already initialized.
    if (this.app) &#123;
      return
    &#125;

    this.app &#x3D; app

    const history &#x3D; this.history

    if (history instanceof HTML5History) &#123;
      history.transitionTo(history.getCurrentLocation())
    &#125; else if (history instanceof HashHistory) &#123;
      const setupHashListener &#x3D; () &#x3D;&gt; &#123;
        history.setupListeners()
      &#125;
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    &#125;

    history.listen(route &#x3D;&gt; &#123;
      this.apps.forEach((app) &#x3D;&gt; &#123;
        app._route &#x3D; route
      &#125;)
    &#125;)
  &#125;

  beforeEach (fn: Function): Function &#123;
    return registerHook(this.beforeHooks, fn)
  &#125;

  beforeResolve (fn: Function): Function &#123;
    return registerHook(this.resolveHooks, fn)
  &#125;

  afterEach (fn: Function): Function &#123;
    return registerHook(this.afterHooks, fn)
  &#125;

  onReady (cb: Function, errorCb?: Function) &#123;
    this.history.onReady(cb, errorCb)
  &#125;

  onError (errorCb: Function) &#123;
    this.history.onError(errorCb)
  &#125;

  push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;
    this.history.push(location, onComplete, onAbort)
  &#125;

  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;
    this.history.replace(location, onComplete, onAbort)
  &#125;

  go (n: number) &#123;
    this.history.go(n)
  &#125;

  back () &#123;
    this.go(-1)
  &#125;

  forward () &#123;
    this.go(1)
  &#125;

  getMatchedComponents (to?: RawLocation | Route): Array&lt;any&gt; &#123;
    const route: any &#x3D; to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute
    if (!route) &#123;
      return []
    &#125;
    return [].concat.apply([], route.matched.map(m &#x3D;&gt; &#123;
      return Object.keys(m.components).map(key &#x3D;&gt; &#123;
        return m.components[key]
      &#125;)
    &#125;))
  &#125;

  resolve (
    to: RawLocation,
    current?: Route,
    append?: boolean
  ): &#123;
    location: Location,
    route: Route,
    href: string,
    &#x2F;&#x2F; for backwards compat
    normalizedTo: Location,
    resolved: Route
  &#125; &#123;
    const location &#x3D; normalizeLocation(
      to,
      current || this.history.current,
      append,
      this
    )
    const route &#x3D; this.match(location, current)
    const fullPath &#x3D; route.redirectedFrom || route.fullPath
    const base &#x3D; this.history.base
    const href &#x3D; createHref(base, fullPath, this.mode)
    return &#123;
      location,
      route,
      href,
      &#x2F;&#x2F; for backwards compat
      normalizedTo: location,
      resolved: route
    &#125;
  &#125;

  addRoutes (routes: Array&lt;RouteConfig&gt;) &#123;
    this.matcher.addRoutes(routes)
    if (this.history.current !&#x3D;&#x3D; START) &#123;
      this.history.transitionTo(this.history.getCurrentLocation())
    &#125;
  &#125;
&#125;

function registerHook (list: Array&lt;any&gt;, fn: Function): Function &#123;
  list.push(fn)
  return () &#x3D;&gt; &#123;
    const i &#x3D; list.indexOf(fn)
    if (i &gt; -1) list.splice(i, 1)
  &#125;
&#125;

function createHref (base: string, fullPath: string, mode) &#123;
  var path &#x3D; mode &#x3D;&#x3D;&#x3D; &#39;hash&#39; ? &#39;#&#39; + fullPath : fullPath
  return base ? cleanPath(base + &#39;&#x2F;&#39; + path) : path
&#125;

VueRouter.install &#x3D; install
VueRouter.version &#x3D; &#39;__VERSION__&#39;

if (inBrowser &amp;&amp; window.Vue) &#123;
  window.Vue.use(VueRouter)
&#125;
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>VueRouter 源码全解：util</title>
    <url>/2017/12/vue-router-source-code-full-analysis-util.html</url>
    <content><![CDATA[async.js&#x2F;* @flow *&#x2F;

&#x2F;&#x2F; 定义一个函数 runQueue。这个函数接受一个参数列表 queue，一个函数 fn，一个回调 cb。它会对 queue 中的每一项依次调用 fn，并在最后结束时调用回调函数 cb
export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function) &#123;
  const step &#x3D; index &#x3D;&gt; &#123;
    if (index &gt;&#x3D; queue.length) &#123;
      cb()
    &#125; else &#123;
      if (queue[index]) &#123;
        fn(queue[index], () &#x3D;&gt; &#123;
          step(index + 1)
        &#125;)
      &#125; else &#123;
        step(index + 1)
      &#125;
    &#125;
  &#125;
  step(0)
&#125;

dom.js&#x2F;* @flow *&#x2F;

&#x2F;&#x2F; 根据是否有全局变量 &#96;window&#96; 判断当前运行环境
export const inBrowser &#x3D; typeof window !&#x3D;&#x3D; &#39;undefined&#39;

path.js&#x2F;* @flow *&#x2F;

&#x2F;&#x2F; 将 relative 与 base 合成完整路径
export function resolvePath (
  relative: string,
  base: string,
  append?: boolean
): string &#123;
  const firstChar &#x3D; relative.charAt(0)
  if (firstChar &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;
    return relative
  &#125;

  if (firstChar &#x3D;&#x3D;&#x3D; &#39;?&#39; || firstChar &#x3D;&#x3D;&#x3D; &#39;#&#39;) &#123;
    return base + relative
  &#125;

  const stack &#x3D; base.split(&#39;&#x2F;&#39;)

  &#x2F;&#x2F; remove trailing segment if:
  &#x2F;&#x2F; - not appending
  &#x2F;&#x2F; - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) &#123;
    stack.pop()
  &#125;

  &#x2F;&#x2F; resolve relative path
  const segments &#x3D; relative.replace(&#x2F;^\&#x2F;&#x2F;, &#39;&#39;).split(&#39;&#x2F;&#39;)
  for (let i &#x3D; 0; i &lt; segments.length; i++) &#123;
    const segment &#x3D; segments[i]
    if (segment &#x3D;&#x3D;&#x3D; &#39;..&#39;) &#123;
      stack.pop()
    &#125; else if (segment !&#x3D;&#x3D; &#39;.&#39;) &#123;
      stack.push(segment)
    &#125;
  &#125;

  &#x2F;&#x2F; ensure leading slash
  if (stack[0] !&#x3D;&#x3D; &#39;&#39;) &#123;
    stack.unshift(&#39;&#39;)
  &#125;

  return stack.join(&#39;&#x2F;&#39;)
&#125;

&#x2F;&#x2F; 将传入的 path 分成 path, query, hash 三部分
export function parsePath (path: string): &#123;
  path: string;
  query: string;
  hash: string;
&#125; &#123;
  let hash &#x3D; &#39;&#39;
  let query &#x3D; &#39;&#39;

  const hashIndex &#x3D; path.indexOf(&#39;#&#39;)
  if (hashIndex &gt;&#x3D; 0) &#123;
    hash &#x3D; path.slice(hashIndex)
    path &#x3D; path.slice(0, hashIndex)
  &#125;

  const queryIndex &#x3D; path.indexOf(&#39;?&#39;)
  if (queryIndex &gt;&#x3D; 0) &#123;
    query &#x3D; path.slice(queryIndex + 1)
    path &#x3D; path.slice(0, queryIndex)
  &#125;

  return &#123;
    path,
    query,
    hash
  &#125;
&#125;

&#x2F;&#x2F; 将传入 path 中的 &#x2F;&#x2F; 替换成 &#x2F;
export function cleanPath (path: string): string &#123;
  return path.replace(&#x2F;\&#x2F;\&#x2F;&#x2F;g, &#39;&#x2F;&#39;)
&#125;

params.js&#x2F;* @flow *&#x2F;

import &#123; warn &#125; from &#39;.&#x2F;warn&#39;
import Regexp from &#39;path-to-regexp&#39;  &#x2F;&#x2F; path-to-regexp 用来将 &#96;&#x2F;user&#x2F;:name&#96; 这样的字符串转换成正则表达式

&#x2F;&#x2F; $flow-disable-line
const regexpCompileCache: &#123;
  [key: string]: Function
&#125; &#x3D; Object.create(null)

&#x2F;&#x2F; 将 params 中的对应的参数填入 path 中，返回填充后的路径
export function fillParams (
  path: string,
  params: ?Object,
  routeMsg: string
): string &#123;
  try &#123;
    const filler &#x3D;
      regexpCompileCache[path] ||
      (regexpCompileCache[path] &#x3D; Regexp.compile(path))
    return filler(params || &#123;&#125;, &#123; pretty: true &#125;)
  &#125; catch (e) &#123;
    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;
      warn(false, &#96;missing param for $&#123;routeMsg&#125;: $&#123;e.message&#125;&#96;)
    &#125;
    return &#39;&#39;
  &#125;
&#125;

query.js&#x2F;* @flow *&#x2F;

import &#123; warn &#125; from &#39;.&#x2F;warn&#39;

const encodeReserveRE &#x3D; &#x2F;[!&#39;()*]&#x2F;g
const encodeReserveReplacer &#x3D; c &#x3D;&gt; &#39;%&#39; + c.charCodeAt(0).toString(16)
const commaRE &#x3D; &#x2F;%2C&#x2F;g

&#x2F;&#x2F; 使 encodeURIComponent 更符合 RFC3986 标准
&#x2F;&#x2F; - 转义 [!&#39;()*]
&#x2F;&#x2F; - 保留逗号
const encode &#x3D; str &#x3D;&gt; encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, &#39;,&#39;)

const decode &#x3D; decodeURIComponent

&#x2F;&#x2F; 根据 query 字符串与 extraQuery 键值对生成键值对
export function resolveQuery (
  query: ?string,
  extraQuery: Dictionary&lt;string&gt; &#x3D; &#123;&#125;,
  _parseQuery: ?Function
): Dictionary&lt;string&gt; &#123;
  const parse &#x3D; _parseQuery || parseQuery
  let parsedQuery
  try &#123;
    parsedQuery &#x3D; parse(query || &#39;&#39;)
  &#125; catch (e) &#123;
    process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(false, e.message)
    parsedQuery &#x3D; &#123;&#125;
  &#125;
  for (const key in extraQuery) &#123;
    parsedQuery[key] &#x3D; extraQuery[key]
  &#125;
  return parsedQuery
&#125;

&#x2F;&#x2F; 将 query 字符串转换成键值对
function parseQuery (query: string): Dictionary&lt;string&gt; &#123;
  const res &#x3D; &#123;&#125;

  query &#x3D; query.trim().replace(&#x2F;^(\?|#|&amp;)&#x2F;, &#39;&#39;)

  if (!query) &#123;
    return res
  &#125;

  query.split(&#39;&amp;&#39;).forEach(param &#x3D;&gt; &#123;
    const parts &#x3D; param.replace(&#x2F;\+&#x2F;g, &#39; &#39;).split(&#39;&#x3D;&#39;)
    const key &#x3D; decode(parts.shift())
    const val &#x3D; parts.length &gt; 0
      ? decode(parts.join(&#39;&#x3D;&#39;))
      : null

    if (res[key] &#x3D;&#x3D;&#x3D; undefined) &#123;
      res[key] &#x3D; val
    &#125; else if (Array.isArray(res[key])) &#123;
      res[key].push(val)
    &#125; else &#123;
      res[key] &#x3D; [res[key], val]
    &#125;
  &#125;)

  return res
&#125;

&#x2F;&#x2F; 将 query 键值对 encode，然后转成 &#96;?key1&#x3D;val1&amp;key2&#x3D;val2 这样的字符串
export function stringifyQuery (obj: Dictionary&lt;string&gt;): string &#123;
  const res &#x3D; obj ? Object.keys(obj).map(key &#x3D;&gt; &#123;
    const val &#x3D; obj[key]

    if (val &#x3D;&#x3D;&#x3D; undefined) &#123;
      return &#39;&#39;
    &#125;

    if (val &#x3D;&#x3D;&#x3D; null) &#123;
      return encode(key)
    &#125;

    if (Array.isArray(val)) &#123;
      const result &#x3D; []
      val.forEach(val2 &#x3D;&gt; &#123;
        if (val2 &#x3D;&#x3D;&#x3D; undefined) &#123;
          return
        &#125;
        if (val2 &#x3D;&#x3D;&#x3D; null) &#123;
          result.push(encode(key))
        &#125; else &#123;
          result.push(encode(key) + &#39;&#x3D;&#39; + encode(val2))
        &#125;
      &#125;)
      return result.join(&#39;&amp;&#39;)
    &#125;

    return encode(key) + &#39;&#x3D;&#39; + encode(val)
  &#125;).filter(x &#x3D;&gt; x.length &gt; 0).join(&#39;&amp;&#39;) : null
  return res ? &#96;?$&#123;res&#125;&#96; : &#39;&#39;
&#125;

location.js&#x2F;* @flow *&#x2F;

import type VueRouter from &#39;..&#x2F;index&#39;
import &#123; parsePath, resolvePath &#125; from &#39;.&#x2F;path&#39;
import &#123; resolveQuery &#125; from &#39;.&#x2F;query&#39;
import &#123; fillParams &#125; from &#39;.&#x2F;params&#39;
import &#123; warn &#125; from &#39;.&#x2F;warn&#39;

export function normalizeLocation (
  raw: RawLocation,
  current: ?Route,
  append: ?boolean,
  router: ?VueRouter
): Location &#123;
  let next: Location &#x3D; typeof raw &#x3D;&#x3D;&#x3D; &#39;string&#39; ? &#123; path: raw &#125; : raw
  &#x2F;&#x2F; named target
  if (next.name || next._normalized) &#123;
    return next
  &#125;

  &#x2F;&#x2F; relative params
  if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123;
    next &#x3D; assign(&#123;&#125;, next)
    next._normalized &#x3D; true
    const params: any &#x3D; assign(assign(&#123;&#125;, current.params), next.params)
    if (current.name) &#123;
      next.name &#x3D; current.name
      next.params &#x3D; params
    &#125; else if (current.matched.length) &#123;
      const rawPath &#x3D; current.matched[current.matched.length - 1].path
      next.path &#x3D; fillParams(rawPath, params, &#96;path $&#123;current.path&#125;&#96;)
    &#125; else if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;
      warn(false, &#96;relative params navigation requires a current route.&#96;)
    &#125;
    return next
  &#125;

  const parsedPath &#x3D; parsePath(next.path || &#39;&#39;)
  const basePath &#x3D; (current &amp;&amp; current.path) || &#39;&#x2F;&#39;
  const path &#x3D; parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath

  const query &#x3D; resolveQuery(
    parsedPath.query,
    next.query,
    router &amp;&amp; router.options.parseQuery
  )

  let hash &#x3D; next.hash || parsedPath.hash
  if (hash &amp;&amp; hash.charAt(0) !&#x3D;&#x3D; &#39;#&#39;) &#123;
    hash &#x3D; &#96;#$&#123;hash&#125;&#96;
  &#125;

  return &#123;
    _normalized: true,
    path,
    query,
    hash
  &#125;
&#125;

function assign (a, b) &#123;
  for (const key in b) &#123;
    a[key] &#x3D; b[key]
  &#125;
  return a
&#125;




]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 动态引入组件</title>
    <url>/2018/01/dynamic-import-component-in-vue.html</url>
    <content><![CDATA[当基于 Vue 的单页应用采用 SSR 后，有些组件由于内部使用了 document 等浏览器端的变量，会在 import 时报错。比较好的解决方法是在 mounted 中动态的 import 组件，赋值到 data 中，在模板里通过 v-bind:is 来引入。
示例：
&lt;template&gt;
  &lt;component v-bind:is&#x3D;&quot;Comp&quot;&gt;&lt;&#x2F;component&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  data() &#123;
    return &#123;
      Comp: null
    &#125;
  &#125;,
  mounted() &#123;
    import(&#39;comp&#39;).then(Comp &#x3D;&gt; &#123;
      this.Comp &#x3D; Comp;
    &#125;);
  &#125;
&#125;
&lt;&#x2F;script&gt;

]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>eslint-plugin-vue 的初体验</title>
    <url>/2018/01/first-experience-of-eslint-plugin-vue.html</url>
    <content><![CDATA[近日看到 vuejs-templates&#x2F;webpack 的更新记录中介绍了 eslint-plugin-vue。由于它不包含如分号这类代码风格相关的规范，只加强了 Vue 相关的规范，能够和 standard 与 airbnb 这类样式共存，所以决定在项目中采用。
安装yarn add -D eslint eslint-plugin-vue

在 eslintrc 的 extends 项中添加 plugin:vue/essential：
module.exports &#x3D; &#123;
  extends: [
    &#x2F;&#x2F; add more generic rulesets here, such as:
    &#x2F;&#x2F; &#39;eslint:recommended&#39;,
    &#39;plugin:vue&#x2F;essential&#39;
  ],
  rules: &#123;
    &#x2F;&#x2F; override&#x2F;add rules settings here, such as:
    &#x2F;&#x2F; &#39;vue&#x2F;no-unused-vars&#39;: &#39;error&#39;
  &#125;
&#125;

注意事项如果使用了其它的 parser（如 &quot;parser&quot;: &quot;babel-eslint&quot;），需要将它移到 parserOptions 中，这样就不会与 vue-eslint-parser 冲突：
- &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;parserOptions&quot;: &#123;
+     &quot;parser&quot;: &quot;babel-eslint&quot;,
      &quot;ecmaVersion&quot;: 2017,
      &quot;sourceType&quot;: &quot;module&quot;
  &#125;

原来的项目中有使用 eslint-plugin-html，它会与 eslint-plugin-vue 冲突，使用时需要移除。


使用效果执行一遍 npm run lint 后，输出如图：

由于启用了所有规则，所以会显示出很多 error，尤其是 vue/order-in-components，它规范了组件中属性的顺序。
相信启用 eslint-plugin-vue 可以使项目代码更加规范统一。
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>前端弹幕设计实现</title>
    <url>/2018/01/front-end-danmu-design-and-impl.html</url>
    <content><![CDATA[什么是弹幕弹dàn幕mù（日语：弾幕だんまく）本义是指战场上由密集子弹形成的火力网（子弹密集得像幕一样），相当于中文的“枪林弹雨”。同时还可用于代指密集移动的事物，现今多用于视频网站中飞过的即时评论字幕（用于这种用法时，在日语中称为コメント，评论之意）。
技术选择要实现弹幕，很容易就能想到两种方式：

使用 Canvas 绘制一个个字幕，生成动画
纯 HTML 元素制作字幕，使用 css 移动字幕

比较这两种方式，canvas 方案只需要一个 canvas 元素即可，所有字幕动画都是通过 js 代码生成，更加简洁，但是 canvas 中要高频的重复绘制相似的内容，不够经济。纯 HTML 元素方案中，每一条弹幕就是一个元素节点，可以 css transform 属性来实现流畅的动画，当弹幕移出可视区域时，即可移除节点，性能更好。
约定
弹幕的容器即可视区域，称作 Canvas
每一条字幕称作 Msg
Msg 是匀速运动的，所以 transition 中的 timing-function 应使用 linear
Msg 的移动速度和 Msg 的长度有关，长度越长速度越快，同时应有最大值与最小值：
Msg 应从 Canvas 的右侧外部移动到 Canvas 中，再从左侧移出：

思路由约定，可得：

Msg 的速度：$v &#x3D; \alpha * msg_width$
Msg 需要运动的位移：$s &#x3D; canvas_width + msg_width$
Msg 需要运动的时间：$duration &#x3D; \frac{s}{v}$

即，在 Msg 长度、Canvas 长度已知的情况下，位移、速度和时间都是确定的，所以，只需记录下 Msg 运动的初始时间，即可计算出 Msg 在任意时刻的位置。
实现TBC…

萌娘百科：弹幕
]]></content>
      <tags>
        <tag>css-transform</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能指标监控</title>
    <url>/2018/01/front-end-performance-index-monitor.html</url>
    <content><![CDATA[Paint当用户导航到网页时，他们会寻找一些视觉反馈来确保一切正常，我们可以用 paint 计时接口来衡量这个指标。
Paint 是指将渲染树转换成屏幕上的像素的过程。
function showPaintTimings() &#123;
  if (window.performance) &#123;
    let performance &#x3D; window.performance;
    let performanceEntries &#x3D; performance.getEntriesByType(&#39;paint&#39;);
    performanceEntries.forEach(performanceEntry &#x3D;&gt; &#123;
      console.log(&quot;The time to &quot; + performanceEntry.name + &quot; was &quot; + performanceEntry.startTime + &quot; milliseconds.&quot;);
    &#125;);
  &#125; else &#123;
    console.log(&#39;Performance timing isn\&#39;t supported.&#39;);
  &#125;
&#125;

这个接口暴露两个值：

Time to first paint: 浏览器开始在屏幕上渲染内容的第一个比特
Time to first contentful paint: 浏览器开始渲染 DOM、文字、图片的第一个比特




MDN web docs: PerformancePaintTiming
Google Developers: New in Chrome 60: Paint timings API
Google Developers: Leveraging the Performance Metrics that Most Affect User Experience

]]></content>
      <tags>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 缓存</title>
    <url>/2018/01/http-caching.html</url>
    <content><![CDATA[缓存的分类缓存可以被归类为两种主要的类别：私有缓存与共享缓存。共享缓存可以为不止一位用户的复用来储存响应。私有缓存独属于单个用户。

私有浏览器缓存浏览器的缓存会被用来前进、后退、保存、查看源文件等，不需要额外请求服务器。
共享代理缓存ISP 或者你的公司可能会为许多用户架设代理来重用流行的资源、降低网络负载。


控制缓存Cache-Control 头完全不缓存客户端请求或是服务器响应都不被存储。每次都会向服务器发送请求并下载完整的响应。
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate

强制确认缓存使用缓存的数据前向服务器发送请求确认缓存是否过期。
Cache-Control: no-cache

私有公共缓存public 指响应可以被任何缓存服务缓存。它可以使页面带有 HTTP 验证或者响应的状态码通常不被缓存的被缓存。private 指响应是对应单个用户的，不应被共享缓存储存，只能保存在私有浏览器缓存中。
Cache-Control: private
Cache-Control: public

过期max-age=&lt;seconds&gt; 是资源被认为新鲜的最大时间，与 Expires 不同，它是相对于请求时间的。
Cache-Control: max-age&#x3D;31536000

验证当时用 must-revalidate 指令时，缓存必须被验证新鲜状态，如果过期了便不被使用。
Cache-Control: must-revalidate



HTTP 的缓存验证分为两部分：Freshness 与 Validation。
根据相应头部的 Cache-Control: max-age 和 Expires 可以判断缓存的内容是否新鲜。如果内容新鲜，则直接读取缓存，这时从 Network Panel 中能看到 200 (from disk cache)，这一部分并不会发送请求到服务器。如果内容不新鲜，则读取 Last-Modified 和 ETag，发送校验请求，头部附上 If-Modified-Since 或 If-None-Match，服务器判断缓存是否与当前的资源相同，若相同，则返回 304 (Not Modified)，若不同，则返回 200 与新的数据。


rfc7234: Hypertext Transfer Protocol (HTTP&#x2F;1.1): Caching
Caching Tutorial

]]></content>
      <tags>
        <tag>Caching</tag>
      </tags>
  </entry>
  <entry>
    <title>Hybrid App 表单组件设计实现(Vue 版)</title>
    <url>/2018/01/hybrid-app-form-component-design-and-implementation-vue-version.html</url>
    <content><![CDATA[App 改版了，表单经过重新设计，需要实现新的表单组件。由于参考了 Material Design，故以 md 为命名空间。
设计如图：

可以将其拆分为以下几个组件：



名称
描述



md-form
多个表单组件的外层容器


md-form-item
表单项，用来包裹标题与输入组件等


md-form-label
表单项标题


md-input
输入组件-单行文本


md-select
输入组件-选择


md-textarea
输入组件-多行文本




拆解如图：

md-form仅作为容器，提供样式。
&lt;template lang&#x3D;&quot;pug&quot;&gt;
.md-form
  slot
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;md-form&#39;
&#125;;
&lt;&#x2F;script&gt;

md-form-item基本表单项。
每个 md-form-item 包含：

label
input
bottom

3 个 slot，分别对应标题组件、输入组件和其他元素。
由于一些操作要求点击整个表单项即触发，所以要在 .md-form-item 绑定 click 事件，并在当前实例上触发（$emit）它。
md-form-item 需要能够获取到输入组件的 focus 状态：输入组件通过 $parent.$emit 在 md-form-item 触发事件，md-form-item 可以监听实例上的 focus 和 blur 事件。
&lt;template lang&#x3D;&quot;pug&quot;&gt;
.md-form-item(
  @click&#x3D;&quot;handleClick&quot;,
  :class&#x3D;&quot;&#123; active: focus, arrow: arrow, &#39;input-focus&#39;: focus &amp;&amp; focusType &#x3D;&#x3D;&#x3D; &#39;input&#39; &#125;&quot;
)
  slot(name&#x3D;&quot;label&quot;)
  slot(name&#x3D;&quot;input&quot;)
  slot(name&#x3D;&quot;bottom&quot;)
  .md-input-border(v-if&#x3D;&quot;!borderless&quot;)
  arrow-right(v-if&#x3D;&quot;arrow&quot;)
&lt;&#x2F;template&gt;

&lt;script&gt;
const getInitialData &#x3D; () &#x3D;&gt; &#123;
  return &#123;
    focus: false,
    focusType: &#39;&#39;
  &#125;
&#125;;

export default &#123;
  name: &#39;md-form-item&#39;,
  data: getInitialData,
  props: &#123;
    borderless: &#123;
      type: Boolean,
      required: false,
      default: false
    &#125;,
    arrow: &#123;
      type: Boolean,
      required: false,
      default: false
    &#125;
  &#125;,
  mounted() &#123;
    this.$on(&#39;focus&#39;, this.onFocus);
    this.$on(&#39;blur&#39;, this.onBlur);
  &#125;,
  methods: &#123;
    handleClick() &#123;
      this.$emit(&#39;form-item:click&#39;);
    &#125;,
    onFocus(e, type) &#123;
      this.focus &#x3D; true;
      this.focusType &#x3D; type;
    &#125;,
    onBlur(e, type) &#123;
      this.focus &#x3D; false;
      this.focusType &#x3D; &#39;&#39;;
    &#125;
  &#125;
&#125;;
&lt;&#x2F;script&gt;

md-form-label普通的 label 组件，用来展示表单项的标题。由于标题可能不是纯文本格式，所以需要使用 slot 的方式传入标题。
&lt;template lang&#x3D;&quot;pug&quot;&gt;
.md-form-label
  slot
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;md-form-label&#39;
&#125;;
&lt;&#x2F;script&gt;

md-input单行文本输入组件，使用 input 元素。
subfix slot 用于显示单位之类的内容。
value 与 this.$emit(&#39;input&#39;, val) 可以使 md-input 支持 v-model。
input 元素上 blur、focus 事件触发时，会通过 this.$parent.$emit(&#39;focus&#39;, event, &#39;input&#39;) 传到父元素，&#39;input&#39; 用于区分 input、select 与 textarea。
&lt;template lang&#x3D;&quot;pug&quot;&gt;
.md-input
  input.md-input-input(
    :type&#x3D;&quot;type&quot;,
    :value&#x3D;&quot;value&quot;,
    :placeholder&#x3D;&quot;placeholder&quot;,
    :step&#x3D;&quot;step&quot;,
    :maxlength&#x3D;&quot;maxlength&quot;,
    @input&#x3D;&quot;handleInput&quot;,
    @focus&#x3D;&quot;handleFocus&quot;,
    @blur&#x3D;&quot;handleBlur&quot;,
  )
  slot(name&#x3D;&quot;subfix&quot;)
&lt;&#x2F;template&gt;

&lt;script&gt;
const getInitialData &#x3D; () &#x3D;&gt; &#123;
  return &#123;
    focus: false
  &#125;
&#125;;

export default &#123;
  name: &#39;md-input&#39;,
  data: getInitialData,
  props: &#123;
    value: &#123;
      type: String,
      required: true
    &#125;,
    type: &#123;
      type: String,
      required: false,
      default: &#39;text&#39;
    &#125;,
    placeholder: &#123;
      type: String,
      required: false
    &#125;,
    maxlength: &#123;
      type: Number,
      required: false
    &#125;,
    step: &#123;
      required: false
    &#125;
  &#125;,
  methods: &#123;
    handleInput(event) &#123;
      const val &#x3D; event.target.value;
      this.$emit(&#39;input&#39;, val);
    &#125;,
    handleFocus(event) &#123;
      this.focus &#x3D; true;
      this.$emit(&#39;focus&#39;, event);
      this.$parent.$emit(&#39;focus&#39;, event, &#39;input&#39;);
    &#125;,
    handleBlur(event) &#123;
      this.focus &#x3D; false;
      this.$emit(&#39;blur&#39;, event);
      this.$parent.$emit(&#39;blur&#39;, event, &#39;input&#39;);
    &#125;
  &#125;
&#125;;
&lt;&#x2F;script&gt;

md-select选择输入组件，点击外层 md-form-item 会触发本组件上的 click 事件，调出实际的选择组件（actionsheet 等）。
&lt;template lang&#x3D;&quot;pug&quot;&gt;
.md-select
  .md-select-placeholder(v-if&#x3D;&quot;value &#x3D;&#x3D; null&quot;) &#123;&#123; placeholder &#125;&#125;
  .md-select-value(v-if&#x3D;&quot;value !&#x3D; null&quot;) &#123;&#123; value &#125;&#125;
&lt;&#x2F;template&gt;

&lt;script&gt;
const getInitialData &#x3D; () &#x3D;&gt; &#123;
  return &#123;
  &#125;
&#125;;

export default &#123;
  name: &#39;md-select&#39;,
  data: getInitialData,
  mounted() &#123;
    this.$parent.$on(&#39;form-item:click&#39;, () &#x3D;&gt; &#123;
      this.onFormItemClick();
    &#125;);
  &#125;,
  props: &#123;
    value: &#123;
      required: true
    &#125;,
    placeholder: &#123;
      type: String,
      required: false,
      default: &#39;&#39;
    &#125;
  &#125;,
  methods: &#123;
    onFormItemClick() &#123;
      this.$emit(&#39;click&#39;);
    &#125;
  &#125;
&#125;;
&lt;&#x2F;script&gt;

md-textarea多行文本输入组件，使用 textarea 元素，与 md-input 类似。
&lt;template lang&#x3D;&quot;pug&quot;&gt;
.md-textarea
  textarea.md-textarea-textarea(
    :value&#x3D;&quot;value&quot;,
    :placeholder&#x3D;&quot;placeholder&quot;,
    :rows&#x3D;&quot;rows&quot;,
    :maxlength&#x3D;&quot;maxlength&quot;,
    @input&#x3D;&quot;handleInput&quot;,
    @focus&#x3D;&quot;handleFocus&quot;,
    @blur&#x3D;&quot;handleBlur&quot;,
  )
&lt;&#x2F;template&gt;

&lt;script&gt;
const getInitialData &#x3D; () &#x3D;&gt; &#123;
  return &#123;
    focus: false
  &#125;
&#125;;

export default &#123;
  name: &#39;md-input&#39;,
  data: getInitialData,
  props: &#123;
    value: &#123;
      type: String,
      required: true
    &#125;,
    placeholder: &#123;
      type: String,
      required: false,
      default: &#39;&#39;
    &#125;,
    maxlength: &#123;
      type: Number,
      required: false
    &#125;,
    rows: &#123;
      required: false,
      default: 4
    &#125;
  &#125;,
  methods: &#123;
    handleInput(event) &#123;
      const val &#x3D; event.target.value;
      this.$emit(&#39;input&#39;, val);
    &#125;,
    handleFocus(event) &#123;
      this.focus &#x3D; true;
      this.$emit(&#39;focus&#39;, event);
      this.$parent.$emit(&#39;focus&#39;, event, &#39;textarea&#39;);
    &#125;,
    handleBlur(event) &#123;
      this.focus &#x3D; false;
      this.$emit(&#39;blur&#39;, event);
      this.$parent.$emit(&#39;blur&#39;, event, &#39;textarea&#39;);
    &#125;
  &#125;
&#125;;
&lt;&#x2F;script&gt;


总结由于目前设计比较简洁，所以并不需要使用 functional 组件即可实现。组件嵌套使用了 slot，组件间的通信使用了 vm.$emit 与 vm.$on，通过 vm.$parent 访问父组件实例。
]]></content>
      <tags>
        <tag>Component</tag>
        <tag>Vue</tag>
        <tag>HybridApp</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程、协程及 Node.js  中的应用</title>
    <url>/2018/01/process-thread-coroutine-and-usage-in-nodejs.html</url>
    <content><![CDATA[基本概念进程(Process)进程是计算机中已运行程序的实体，是线程的容器。
进程间通信使用 IPC。
线程(Thread)线程是操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运行单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。
线程间使用共享内存通信。

运行在一个处理器上的一个进程有两个线程在执行



Wikipedia: Process
Wikipedia: Thread
Wikipedia: Coroutine

]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Coroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 原理之数据响应</title>
    <url>/2018/01/vue-principle-data-reactive.html</url>
    <content><![CDATA[定义 Reactive 属性通过 Object.defineProperty 可以为一个对象设置具有 getter 和 setter 的属性，于是，我们可以为一个对象添加 reactive 的属性。
function defineReactive (obj, key, val) &#123;
  Object.defineProperty(obj, key, &#123;
    get: function reactiveGetter () &#123;
      return val
    &#125;,
    set: function reactiveSetter (newVal) &#123;
      console.log(&#96;$&#123;key&#125; is set to $&#123;newVal&#125;&#96;)
      val &#x3D; newVal
    &#125;
  &#125;)
&#125;

const apple &#x3D; &#123;&#125;

defineReactive(apple, &#39;color&#39;, &#39;red&#39;)
console.log(apple.color)  &#x2F;&#x2F; -&gt; &#39;red&#39;
apple.color &#x3D; &#39;yellow&#39;  &#x2F;&#x2F; color is set to yellow

定义 computed 属性function defineComputed (target, key, computeFunc, updateCb) &#123;
  Object.defineProperty(target, key, &#123;
    get: function computedGetter() &#123;
      &#x2F;&#x2F; evaluate computeFunc and return value
      return computeFunc()
    &#125;,
    set: function computedSetter() &#123;
      &#x2F;&#x2F; noop
    &#125;
  &#125;)
&#125;



为计算属性添加依赖追踪（简单实现）定义一个全局的变量用于追踪依赖
const Dep &#x3D; &#123;
  target: null
&#125;

修改 defineComputed：
function defineComputed (target, key, computeFunc, updateCb) &#123;
  const onDepUpdated &#x3D; () &#x3D;&gt; &#123;
    &#x2F;&#x2F; recompute val when dep update
    const val &#x3D; computeFunc()
    updateCb(val)
  &#125;

  Object.defineProperty(target, key, &#123;
    get: function computedGetter() &#123;
      Dep.target &#x3D; onDepUpdated
      const val &#x3D; computeFunc()
      Dep.target &#x3D; null
      return val
    &#125;,
    set: function computedSetter() &#123;
      &#x2F;&#x2F; noop
    &#125;
  &#125;)
&#125;

修改 defineReactive：
function defineReactive (obj, key, val) &#123;
  const deps &#x3D; []

  Object.defineProperty(obj, key, &#123;
    get: function reactiveGetter () &#123;
      if (Dep.target) &#123;
        deps.push(Dep.target)
      &#125;
      return val
    &#125;,
    set: function reactiveSetter (newVal) &#123;
      val &#x3D; newVal
      deps.forEach(func &#x3D;&gt; &#123;
        func()
      &#125;)
    &#125;
  &#125;)
&#125;

测试：
defineComputed(apple, &#39;description&#39;, function () &#123;
  return &#96;this is a $&#123; apple.color &#125; apple&#96;
&#125;, function (newVal) &#123;
  console.log(&#96;description has changed to &#39;$&#123;newVal&#125;&#39;&#96;)
&#125;)

console.log(apple.color)
&#x2F;&#x2F; red
console.log(apple.description)
&#x2F;&#x2F; this is a red apple

apple.color &#x3D; &#39;yellow&#39;
&#x2F;&#x2F; description has changed to &#39;this is a yellow apple&#39;

console.log(apple.description)
&#x2F;&#x2F; this is a yellow apple

上面是通过在执行计算属性的 getter 时设置一个标志 Dep.target，调用到计算属性的依赖的 getter 时，会去读取 Dep.target，即可在 deps 中保存下依赖关系。
为计算属性添加依赖追踪（嵌套）依赖追踪的简单实现中，我们将 onDepUpdated 保存在 Dep.target 中，但是存在多层依赖关系时，简单修改 Dep.target 并不能满足需求。
const apple &#x3D; &#123;&#125;

defineReactive(apple, &#39;color&#39;, &#39;red&#39;)

defineComputed(apple, &#39;appleName&#39;, function () &#123;
  return &#96;$&#123; apple.color &#125; apple&#96;
&#125;, function (newVal) &#123;
  console.log(&#96;appleName has changed to &#39;$&#123;newVal&#125;&#39;&#96;)
&#125;)


defineComputed(apple, &#39;description&#39;, function () &#123;
  return &#96;this is a $&#123; apple.appleName &#125;&#96;
&#125;, function (newVal) &#123;
  console.log(&#96;description has changed to &#39;$&#123;newVal&#125;&#39;&#96;)
&#125;)

console.log(apple.color)
&#x2F;&#x2F; red
console.log(apple.appleName)
&#x2F;&#x2F; red apple
console.log(apple.description)
&#x2F;&#x2F; this is a red apple

apple.color &#x3D; &#39;yellow&#39;
&#x2F;&#x2F; appleName has changed to &#39;yellow apple&#39;
&#x2F;&#x2F; appleName has changed to &#39;yellow apple&#39;

appleName 的 onDepUpdated 在 deps 里被存了两份。且修改 apple.color 后，期望的输出应该是 appleName has changed to &#39;yellow apple&#39; 与 description has changed to &#39;this is a yellow apple&#39;。
原因在于向 deps 中添加 Dep.target 时并没有判重，且嵌套计算属性时，Dep.target 被最近读取的计算属性所覆盖，考虑使用栈模型解决这个问题。
const Dep &#x3D; &#123;&#125;
Dep.target &#x3D; null
const targetStack &#x3D; []

function pushTarget (_target) &#123;
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target &#x3D; _target
&#125;

function popTarget () &#123;
  Dep.target &#x3D; targetStack.pop()
&#125;

function defineReactive (obj, key, val) &#123;
  const deps &#x3D; []

  Object.defineProperty(obj, key, &#123;
    get: function reactiveGetter () &#123;
      if (Dep.target &amp;&amp; deps.indexOf(Dep.target) &#x3D;&#x3D;&#x3D; -1) &#123;
        deps.push(Dep.target)
      &#125;
      return val
    &#125;,
    set: function reactiveSetter (newVal) &#123;
      val &#x3D; newVal
      deps.forEach(func &#x3D;&gt; &#123;
        func()
      &#125;)
    &#125;
  &#125;)
&#125;

function defineComputed (target, key, computeFunc, updateCb) &#123;
  const deps &#x3D; []

  const onDepUpdated &#x3D; () &#x3D;&gt; &#123;
    const val &#x3D; computeFunc()
    updateCb(val)

    deps.forEach(func &#x3D;&gt; &#123;
      func()
    &#125;)
  &#125;

  Object.defineProperty(target, key, &#123;
    get: function computedGetter() &#123;
      if (Dep.target &amp;&amp; deps.indexOf(Dep.target) &#x3D;&#x3D;&#x3D; -1) &#123;
        deps.push(Dep.target)
      &#125;
      pushTarget(onDepUpdated)
      const val &#x3D; computeFunc()
      popTarget()
      return val
    &#125;,
    set: function computedSetter() &#123;
      &#x2F;&#x2F; noop
    &#125;
  &#125;)
&#125;

将 target 存在 targetStack 中，每次执行计算属性的 getter 时，调用 pushTarget 和 popTarget 来修改 targetStack。
模块化 Dep将 defineReactive 与 defineComputed 中 Dep 相关的函数抽出。
&#x2F;&#x2F; dep.js

export default class Dep &#123;
&#125;

Dep.target &#x3D; null
const targetStack &#x3D; []

export function pushTarget (_target: Watcher) &#123;
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target &#x3D; _target
&#125;

export function popTarget () &#123;
  Dep.target &#x3D; targetStack.pop()
&#125;

import Dep, &#123; pushTarget, popTarget &#125; from &#39;.&#x2F;dep&#39;

最终代码&#x2F;&#x2F; dep.js

export default class Dep &#123;
&#125;

Dep.target &#x3D; null
const targetStack &#x3D; []

export function pushTarget (_target: Watcher) &#123;
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target &#x3D; _target
&#125;

export function popTarget () &#123;
  Dep.target &#x3D; targetStack.pop()
&#125;

import Dep, &#123; pushTarget, popTarget &#125; from &#39;.&#x2F;dep&#39;

function defineReactive (obj, key, val) &#123;
  const deps &#x3D; []

  Object.defineProperty(obj, key, &#123;
    get: function reactiveGetter () &#123;
      if (Dep.target &amp;&amp; deps.indexOf(Dep.target) &#x3D;&#x3D;&#x3D; -1) &#123;
        deps.push(Dep.target)
      &#125;
      return val
    &#125;,
    set: function reactiveSetter (newVal) &#123;
      val &#x3D; newVal
      deps.forEach(func &#x3D;&gt; &#123;
        func()
      &#125;)
    &#125;
  &#125;)
&#125;

function defineComputed (target, key, computeFunc, updateCb) &#123;
  const deps &#x3D; []

  const onDepUpdated &#x3D; () &#x3D;&gt; &#123;
    const val &#x3D; computeFunc()
    updateCb(val)

    deps.forEach(func &#x3D;&gt; &#123;
      func()
    &#125;)
  &#125;

  Object.defineProperty(target, key, &#123;
    get: function computedGetter() &#123;
      if (Dep.target &amp;&amp; deps.indexOf(Dep.target) &#x3D;&#x3D;&#x3D; -1) &#123;
        deps.push(Dep.target)
      &#125;
      pushTarget(onDepUpdated)
      const val &#x3D; computeFunc()
      popTarget()
      return val
    &#125;,
    set: function computedSetter() &#123;
      &#x2F;&#x2F; noop
    &#125;
  &#125;)
&#125;



vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;dep.js
vue&#x2F;src&#x2F;core&#x2F;observer&#x2F;index.js
vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;state.js

]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 原理之从 VNode 到 Node 的流程</title>
    <url>/2018/01/vue-principle-from-vnode-to-node.html</url>
    <content><![CDATA[VNode 意即虚拟节点，每一个 VNode 对应一个 DOM Element。操作 VNode，Vue 会对变化进行 patch 操作，最后根据新的 VNode，进行 node-ops 生成 DOM 树。

graph LR
Component -- createElement --&gt; VNode
VNode -- patch --&gt; DOM
DOM -- platforms&#x2F;web&#x2F;runtime&#x2F;node-ops.js --&gt; Node


class VNode &#123;
  tag: string | void;
  data: VNodeData | void;
  children: ?Array&lt;VNode&gt;;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; &#x2F;&#x2F; rendered in this component&#39;s scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; &#x2F;&#x2F; component instance
  parent: VNode | void; &#x2F;&#x2F; component placeholder node

  &#x2F;&#x2F; 私有属性
  raw: boolean; &#x2F;&#x2F; contains raw HTML? (server only)
  isStatic: boolean; &#x2F;&#x2F; hoisted static node
  isRootInsert: boolean; &#x2F;&#x2F; necessary for enter transition check
  isComment: boolean; &#x2F;&#x2F; empty comment placeholder?
  isCloned: boolean; &#x2F;&#x2F; is a cloned node?
  isOnce: boolean; &#x2F;&#x2F; is a v-once node?
  asyncFactory: Function | void; &#x2F;&#x2F; async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; &#x2F;&#x2F; real context vm for functional nodes
  fnOptions: ?ComponentOptions; &#x2F;&#x2F; for SSR caching
  fnScopeId: ?string; &#x2F;&#x2F; functioanl scope id support
&#125;
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>from async to generator</title>
    <url>/2018/03/from-async-to-generator.html</url>
    <content><![CDATA[想要实现 async 函数的功能，首先要明白 async 函数有哪些特点。

返回 Promise
async 函数中可以使用 await 等待 Promise

以上，我们可以使用 generator 来模拟实现 async 函数，因为 yield 同样可以用来暂停恢复函数的执行。
下面我们来看看 babel 是怎么转换 async&#x2F;await 的。
const xxx &#x3D; async () &#x3D;&gt; &#123;
  const val &#x3D; await yyy();
  return val;
&#125;

先分析下原始代码，定义一个async 函数 xxx，这个 async 函数里面使用 await 取得 async 函数 yyy 的值赋值给 val 并返回 val。


以下是经 babel 转换得到的代码：
function _asyncToGenerator(fn) &#123;
  return function() &#123;
    var gen &#x3D; fn.apply(this, arguments);
    return new Promise(function(resolve, reject) &#123;
      function step(key, arg) &#123;
        try &#123;
          var info &#x3D; gen[key](arg);
          var value &#x3D; info.value;
        &#125; catch (error) &#123;
          reject(error);
          return;
        &#125;
        if (info.done) &#123;
          resolve(value);
        &#125; else &#123;
          return Promise.resolve(value).then(
            function(value) &#123;
              step(&quot;next&quot;, value);
            &#125;,
            function(err) &#123;
              step(&quot;throw&quot;, err);
            &#125;
          );
        &#125;
      &#125;
      return step(&quot;next&quot;);
    &#125;);
  &#125;;
&#125;

const xxx &#x3D; (() &#x3D;&gt; &#123;
  var _ref &#x3D; _asyncToGenerator(function*() &#123;
    const val &#x3D; yield yyy();
    return val;
  &#125;);

  return function xxx() &#123;
    return _ref.apply(this, arguments);
  &#125;;
&#125;)();

可以看到 xxx 使用立即执行函数的返回值初始化。在立即执行函数中，原始代码中的 async 函数的内容被放在 generator 中，并被 _asyncToGenerator 处理，await 变成了 yield。
现在来看函数 _asyncToGenerator。我们知道 async 函数会返回一个 Promise，所以 _asyncToGenerator 也要返回一个 Promise。在这个 Promise 中，会重复的执行 gen.next() 直到 done 值为 true，这时 resolve(value) 即可。
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Async</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy 在 React SyntheticEvent 中的应用</title>
    <url>/2018/03/use-proxy-react-synthetic-event.html</url>
    <content><![CDATA[
近日在开发 React 应用中发现 SyntheticEvent 是一个 Proxy 对象，比较好奇 SyntheticEvent 这里怎么用到了 Proxy，于是查看下 React 的源码。
&#x2F;** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 *&#x2F;
if (__DEV__) &#123;
  const isProxySupported &#x3D;
    typeof Proxy &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp;
    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;issues&#x2F;12011
    !Object.isSealed(new Proxy(&#123;&#125;, &#123;&#125;));

  if (isProxySupported) &#123;
    &#x2F;*eslint-disable no-func-assign *&#x2F;
    SyntheticEvent &#x3D; new Proxy(SyntheticEvent, &#123;
      construct: function(target, args) &#123;
        return this.apply(target, Object.create(target.prototype), args);
      &#125;,
      apply: function(constructor, that, args) &#123;
        return new Proxy(constructor.apply(that, args), &#123;
          set: function(target, prop, value) &#123;
            if (
              prop !&#x3D;&#x3D; &#39;isPersistent&#39; &amp;&amp;
              !target.constructor.Interface.hasOwnProperty(prop) &amp;&amp;
              shouldBeReleasedProperties.indexOf(prop) &#x3D;&#x3D;&#x3D; -1
            ) &#123;
              warning(
                didWarnForAddedNewProperty || target.isPersistent(),
                &quot;This synthetic event is reused for performance reasons. If you&#39;re &quot; +
                  &quot;seeing this, you&#39;re adding a new property in the synthetic event object. &quot; +
                  &#39;The property is never released. See &#39; +
                  &#39;https:&#x2F;&#x2F;fb.me&#x2F;react-event-pooling for more information.&#39;,
              );
              didWarnForAddedNewProperty &#x3D; true;
            &#125;
            target[prop] &#x3D; value;
            return true;
          &#125;,
        &#125;);
      &#125;,
    &#125;);
    &#x2F;*eslint-enable no-func-assign *&#x2F;
  &#125;
&#125;

可以看到 Proxy 被用来修改 SyntheticEvent 的 set 操作，当尝试向 SyntheticEvent 对象添加新的属性时，会弹出 warning。


React: SyntheticEvent
MDN: Proxy

]]></content>
      <tags>
        <tag>React</tag>
        <tag>ES6</tag>
        <tag>SyntheticEvent</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>在 create-react-app 创建的项目中使用 svg-sprite-loader</title>
    <url>/2018/03/use-svg-sprite-loader-in-project-created-by-create-react-app.html</url>
    <content><![CDATA[create-react-app 可以很方便的初始化一个 React 项目，但是当我们需要完成一些特定需求的时候，便要 eject 来做定制化操作。
本文主要讲述在 create-react-app 创建的项目中使用 svg-sprite-loader 的方法，以及其中要注意的问题。
第一步：eject$ yarn run eject

第二步：添加依赖$ yarn add -D svg-sprite-loader svgo svgo-loader

第三步：修改配置要启用 svg-sprite-loader 需要修改两个配置文件：config/webpack.config.dev.js 与 config/webpack.config.prod.js。
在 module.rules.oneOf 中添加如下内容：
&#123;
  test: &#x2F;\.svg$&#x2F;,
  use: [
    &#123;
      loader: &#39;svg-sprite-loader&#39;
    &#125;,
    &#123;
      loader: &#39;svgo-loader&#39;
    &#125;
  ]
&#125;

需要注意到的是，以上内容一定要添加到 oneOf 项下，而不是 rules。因为如果直接添加到 rules 下的话，会受到 oneOf 中 file-loader 的影响。
]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>在 JavaScript 中使用 Proxy 实现懒初始化</title>
    <url>/2018/04/implement-lazy-initialize-with-proxy-in-javascript.html</url>
    <content><![CDATA[最近写了个库 promisify-wxmp-util 用来将微信小程序中 callback 形式的方法转换成 Promise 形式。功能实现起来很简单，分别对各个方法调用 promisify 即可。但是实践开发中并不一定会用到所有的 API，所以希望它具有懒初始化的功能，在我调用到对应的 API 时才会做 promisify 处理。
使用 Proxy 可以通过 get handler 控制对象属性的访问：
const lib &#x3D; new Proxy(&#123;&#125;, &#123;
  get(obj, prop) &#123;
    if (Reflect.has(obj, prop)) &#123;
      return Reflect.get(obj, prop);
    &#125; else if (typeof wx[prop] !&#x3D;&#x3D; &#39;undefined&#39;) &#123;
      const func &#x3D; promisify(wx[prop]);
      obj[prop] &#x3D; func;
      return func;
    &#125; else &#123;
      return new Error(&#96;Cannot read property &#39;$&#123;prop&#125;&#39; of wx&#96;);
    &#125;
  &#125;
&#125;);
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Proxy</tag>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>Zipline 的安装配置</title>
    <url>/2018/04/install-and-config-zipline.html</url>
    <content><![CDATA[Zipline 是一个 Python 的算法交易库。它的安装过程比较简单，但是在实际操作过程中可能会由于网络、系统环境等原因遇到各式各样的问题。本文以安装配置完成后能够正常运行 dual_moving_average.py 为目的。

1. 安装 AnacondaAnaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows，包含了众多流行的科学计算、数据分析的 Python 包。使用 Anaconda 能够方便的安装管理 Zipline 及其他开发过程中会用到的包。
直接从 Anaconda 的官网下载 Anaconda 可能会比较慢，所以这里从清华大学开源软件镜像站下载。
$ wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;archive&#x2F;Anaconda3-5.1.0-Linux-x86_64.sh
$ chmod +x Anaconda3-5.1.0-Linux-x86_64.sh
$ .&#x2F;Anaconda3-5.1.0-Linux-x86_64.sh

执行完 Anaconda3-5.1.0-Linux-x86_64.sh 这个脚本，会将 Anaconda 安装到 $HOME/anaconda3 如果在安装过程中没有添加 $HOME/anaconda3/bin 到 $PATH 的话需要自己手动在 .bashrc 中添加。
export PATH&#x3D;&quot;&#x2F;home&#x2F;hanai&#x2F;anaconda3&#x2F;bin:$PATH&quot;

最后还需要添加 TUNA 提供的 Anaconda 仓库的镜像。
$ conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;
$ conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;
$ conda config --set show_channel_urls yes

2. 创建环境使用 conda 来创建管理环境：
$ conda create -n py35 python&#x3D;3.5
$ source activate py35

为了方便开发，可以安装 jupyter 和 nb_conda
$ conda install jupyter nb_conda



3. 安装 Zipline在上一步中，我们切换到新创建的环境 py35，现在就可以安装 Zipline 了：
$ conda install -c Quantopian zipline

4. 下载 Quandl 数据我们先要去 Quandl 得到自己的 API Key，修改当前的环境变量。
$ export QUANDL_API_KEY&#x3D;&lt;yourkey&gt;

然后执行 zipline ingest 下载数据 bundle。这一步由于数据是存在 AWS 上的，所以下载会比较慢，可以先开启 http 代理，执行 export http_proxy=&quot;127.0.0.1:port&quot; 来加速下载。
$ zipline ingest -b quandl

数据下载完成后就可以用 dual_moving_average.py 来测试了。
$ zipline run -f dual_moving_average.py --start 2014-1-1 --end 2018-1-1 -o dma.pickle

]]></content>
      <tags>
        <tag>Zipline</tag>
        <tag>量化交易</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 系统浏览器中唤起应用</title>
    <url>/2018/04/launch-application-from-browser-in-android.html</url>
    <content><![CDATA[在进行移动端页面开发中，会遇到从 web 页面唤起 Android 应用的需求。在 Android 系统中，可以使用自定义 scheme 来实现，但是这种方式在系统未安装对应应用的情况下，不好做 fallback。所以使用 intent: 会是更好的选择。
句法使用户能够打开应用的最佳实践是构建一个 intent a 标签嵌入到页面。这可以更灵活的控制 app 如何运行，并能够通过 Intent Extras 传入 extra 到 app。
intent URI 的基本句法如下：
intent:
   HOST&#x2F;URI-path &#x2F;&#x2F; Optional host
   #Intent;
      package&#x3D;[string];
      action&#x3D;[string];
      category&#x3D;[string];
      component&#x3D;[string];
      scheme&#x3D;[string];
   end;

可以加入下面的字符串来指定 fallback URL：
S.browser_fallback_url&#x3D;[encoded_full_url]

当一个 intent 无法被执行或者外部应用无法运行时，用户会被跳转的 fallback 页面。
下面是一些 Chrome 无法运行外部应用的情况：

intent 无法被执行，如没有 app 可以处理这个 intent
JavaScript 定时器试图在没有用户交互的情况下打开一个应用

S.&lt;name&gt; 是一种用来定义字符串 extra 的方式。S.browser_fallback_url 被用来做向后兼容，但是目标应用是看不到 browser_fallback_url 的，因为 Chrome 会移除它。
示例下面的 intent 可以用来打开 Zxing 条码扫描 App：
intent:
   &#x2F;&#x2F;scan&#x2F;
   #Intent;
      package&#x3D;com.google.zxing.client.android;
      scheme&#x3D;zxing;
   end;

a 标签是这样的：
&lt;a href&#x3D;&quot;intent:&#x2F;&#x2F;scan&#x2F;#Intent;scheme&#x3D;zxing;package&#x3D;com.google.zxing.client.android;end&quot;&gt; Take a QR code &lt;&#x2F;a&gt;

加入 fallback URL：
&lt;a href&#x3D;&quot;intent:&#x2F;&#x2F;scan&#x2F;#Intent;scheme&#x3D;zxing;package&#x3D;com.google.zxing.client.android;S.browser_fallback_url&#x3D;http%3A%2F%2Fzxing.org;end&quot;&gt; Take a QR code &lt;&#x2F;a&gt;


Chrome Developer: Android Intents with Chrome
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Intent</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 性能要点：事件委托</title>
    <url>/2018/04/performance-key-in-vue-js-event-delegation.html</url>
    <content><![CDATA[Vue、React 这些框架的出现为前端开发带来了很大的便捷，但是享受这些便捷的同时我们不应忘记之前我们掌握的优化方法。
在 Vue 中为列表中每一元素绑定事件非常方便，@eventName=&quot;handler&quot; 即可，但是方便的同时带来了性能上的不友好。
如下我们采用两种方式监听 .list .item 的 click 事件。
绑定事件到每一个 .item：
&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
  &lt;div class&#x3D;&quot;list&quot;&gt;
    &lt;div class&#x3D;&quot;item&quot;
      @click&#x3D;&quot;onClickItem&quot;
      v-for&#x3D;&quot;(item, idx) in list&quot;
      :key&#x3D;&quot;idx&quot;&gt;&#123;&#123; idx &#125;&#125;&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
const getInitialData &#x3D; () &#x3D;&gt; (&#123;
  list: new Array(100),
&#125;);
export default &#123;
  data: getInitialData,
  name: &#39;App&#39;,
  methods: &#123;
    onClickItem() &#123;
      alert(&#39;click&#39;);
    &#125;,
  &#125;,
&#125;;
&lt;&#x2F;script&gt;

绑定事件到 .list：
&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
  &lt;div class&#x3D;&quot;list&quot; @click&#x3D;&quot;onClickList($event)&quot;&gt;
    &lt;div class&#x3D;&quot;item&quot;
      v-for&#x3D;&quot;(item, idx) in list&quot;
      :key&#x3D;&quot;idx&quot;&gt;&#123;&#123; idx &#125;&#125;&lt;&#x2F;div&gt;
    &lt;&#x2F;div&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
const getInitialData &#x3D; () &#x3D;&gt; (&#123;
  list: new Array(100),
&#125;);
export default &#123;
  data: getInitialData,
  name: &#39;App&#39;,
  methods: &#123;
    onClickList(event) &#123;
      const target &#x3D; event.target;
      if (target.className &#x3D;&#x3D;&#x3D; &#39;item&#39;) &#123;
        alert(&#39;click&#39;);
      &#125;
    &#125;,
  &#125;,
&#125;;
&lt;&#x2F;script&gt;

以下分别是两种方式的内存快照：


可以看出使用事件委托少了 $121 - 22 &#x3D; 19$ 个 EventListener 对象。随着 .item 元素的增多，绑定事件到 .item 会使内存消耗呈线性增长。
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
        <tag>event</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>量化交易笔记</title>
    <url>/2018/04/quantitative-trade-notebok.html</url>
    <content><![CDATA[
04_Introduction_to_pandas
05_Plotting_Data
TR&amp;ATR

]]></content>
      <tags>
        <tag>量化交易</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 的类型减法</title>
    <url>/2018/04/type-subtraction-in-typescript.html</url>
    <content><![CDATA[在使用 TypeScript 开发的过程中，我们有时会遇到需要做类型减法的情况，例如 react-i18next 的 translate 方法会为组件的 Props 添加 i18n 等属性，而这个属性在通过 translate 生成的高阶组件的 Props 中是不应体现的。这时我们就需要用到类型减法。
具体实现：
&#x2F;&#x2F; Diff &#x2F; Omit taken from https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;issues&#x2F;12215#issuecomment-311923766
type Diff&lt;T extends string, U extends string&gt; &#x3D; (&#123; [P in T]: P &#125; &amp; &#123; [P in U]: never &#125; &amp; &#123; [x: string]: never &#125;)[T];
type Omit&lt;T, K extends keyof T&gt; &#x3D; Pick&lt;T, Diff&lt;keyof T, K&gt;&gt;;

interface A &#123;
  a: string;
  b?: string;
  c: number;
&#125;

type B &#x3D; Omit&lt;A, &#39;c&#39;&gt;;

const a: A &#x3D; &#123;
  a: &#39;5&#39;,
  c: 5,
&#125;;

const b: B &#x3D; &#123;
  a: &#39;5&#39;,
&#125;;

&#x2F;&#x2F; Note: typeof B is (correctly) Pick&lt;A, &#39;a&#39; | &#39;b&#39;&gt;

这里主要用到了 Pick 工具类，Pick 可以从一个类型中取出一组属性生成新的类型。

TypeScript 2.8 更新
在 TypeScript 2.8 中，新增了条件类型 Exclude&lt;T, U&gt;，它可以从T中排除那些可分配给U的类型。
所以上面的 Omit&lt;T, K&gt; 类型可以改写为 Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;。
TypeScript 2.8 Release Notes
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在 React 中使用 D3.js</title>
    <url>/2018/04/use-d3-js-in-react.html</url>
    <content><![CDATA[问题现在很多项目使用的是 React 或 Vue，而 D3.js 却是直接操作 DOM 的，所以想在这些框架中使用 D3.js 不能使用一般的方式。下文以一个饼图为例介绍两种不错的方案。

方案 1: D3.js 做计算一种方案是只使用 D3.js 做计算，使用 React 根据计算值生成 DOM。
import * as React from &#39;react&#39;;
import * as d3 from &#39;d3&#39;;
import &#123; PieArcDatum &#125; from &#39;d3&#39;;

import &#123; str2rgb &#125; from &#39;utils&#39;;

interface PositionData &#123;
  symbol: string;
  val: number;
&#125;

interface PositionsPieProps &#123;
  positions: PositionData[];
  width: number;
  height: number;
&#125;

const PositionsPie &#x3D; (props: PositionsPieProps) &#x3D;&gt; &#123;
  const &#123; positions, width, height &#125; &#x3D; props;
  const radius &#x3D; Math.min(width, height) &#x2F; 2;

  const pie &#x3D; d3
    .pie&lt;PositionData&gt;().sort(null)
    .value(d &#x3D;&gt; d.val)(positions);

  const arcPathGen &#x3D; d3.arc&lt;PieArcDatum&lt;PositionData&gt;&gt;()
    .innerRadius(0)
    .outerRadius(radius - 10);

  return (
    &lt;svg width&#x3D;&#123;width&#125; height&#x3D;&#123;height&#125;&gt;
      &lt;g transform&#x3D;&#123;&#96;translate($&#123;width &#x2F; 2&#125;, $&#123;height &#x2F; 2&#125;)&#96;&#125;&gt;
        &#123;
          pie.map((val, idx) &#x3D;&gt; &#123;
            const arcPath &#x3D; arcPathGen(val) as string;

            const labelPath &#x3D; d3.arc&lt;PieArcDatum&lt;PositionData&gt;&gt;()
              .outerRadius(radius - 40)
              .innerRadius(radius - 40);

            return (
              &lt;g key&#x3D;&#123;idx&#125;&gt;
                &lt;path d&#x3D;&#123;arcPath&#125; fill&#x3D;&#123;str2rgb(val.data.symbol)&#125; &#x2F;&gt;
                &lt;text
                  dy&#x3D;&quot;0.35em&quot;
                  style&#x3D;&#123;&#123; textAnchor: &#39;middle&#39; &#125;&#125;
                  transform&#x3D;&#123;&#96;translate($&#123;labelPath.centroid(val)&#125;)&#96;&#125;
                &gt;
                  &#123;val.data.symbol&#125;
                &lt;&#x2F;text&gt;
              &lt;&#x2F;g&gt;
            );
          &#125;)
        &#125;
      &lt;&#x2F;g&gt;
    &lt;&#x2F;svg&gt;
  );
&#125;;

export default PositionsPie;

d3.pie() 与 d3.arc() 都可以用来做计算操作，生成绘制 SVG 所用的数据。


方案 2: D3.js 操作类 DOM 结构react-faux-dom 这个库可以生成类似 DOM 的数据结构来给 D3.js 操作，然后渲染成 React 元素。
const PositionsPie &#x3D; (props: PositionsPieProps) &#x3D;&gt; &#123;
  const &#123; positions, width, height &#125; &#x3D; props;
  const radius &#x3D; Math.min(width, height) &#x2F; 2;

  const el &#x3D; ReactFauxDOM.createElement(&#39;svg&#39;);

  const svg &#x3D; d3.select(el);
  svg.attr(&#39;width&#39;, width).attr(&#39;height&#39;, height);
  const g &#x3D; svg.append(&#39;g&#39;);
  g.attr(&#39;transform&#39;, &#96;translate($&#123;width &#x2F; 2&#125;, $&#123;height &#x2F; 2&#125;)&#96;);
  const pie &#x3D; d3.pie&lt;PositionData&gt;().sort(null)
    .value(d &#x3D;&gt; d.val);

  const path &#x3D; d3.arc&lt;PieArcDatum&lt;PositionData&gt;&gt;()
    .innerRadius(0)
    .outerRadius(radius - 10);

  const label &#x3D; d3.arc&lt;PieArcDatum&lt;PositionData&gt;&gt;()
    .outerRadius(radius - 40)
    .innerRadius(radius - 40);

  const arc &#x3D; g.selectAll(&#39;.arc&#39;)
    .data(pie(positions))
    .enter().append(&#39;g&#39;)
    .attr(&#39;class&#39;, &#39;arc&#39;);

  arc.append(&#39;path&#39;)
    .attr(&#39;d&#39;, path)
    .attr(&#39;fill&#39;, d &#x3D;&gt; str2rgb(d.data.symbol));

  arc.append(&#39;text&#39;)
    .attr(&#39;transform&#39;, d &#x3D;&gt; &#96;translate($&#123;label.centroid(d)&#125;)&#96;)
    .attr(&#39;dy&#39;, &#39;0.35em&#39;)
    .attr(&#39;style&#39;, &#39;textAnchor: middle&#39;)
    .text(d &#x3D;&gt; d.data.symbol);

  return el.toReact();
&#125;;

除了能够像 D3.js 默认的方式那样进行操作外，还支持动画。
]]></content>
      <tags>
        <tag>React</tag>
        <tag>D3</tag>
        <tag>visualization</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Tiingo 作为量化分析数据源</title>
    <url>/2018/04/use-tiingo-as-data-source-for-quantitative-analysis.html</url>
    <content><![CDATA[在学习量化交易过程中，数据源非常重要。之前一段时间使用的是 Quandl 提供的免费数据，然而现在发现它免费的数据里并没有 ETF，而且一些数据也有问题（例如 SHAK 拿不到正确的数据），遂决定寻找替换方案。从 pandas-datareader 了解到 Tiingo 这个数据源，一番测试下来，觉得符合自己目前的需求。
首先需要在 Tiingo 注册账号，得到自己的 API Key。
然后安装开源的 API 客户端 Tiingo Python。
$ pip install tiingo

使用方法：
from tiingo import TiingoClient

config &#x3D; &#123;&#125;
config[&#39;session&#39;] &#x3D; True
config[&#39;api_key&#39;] &#x3D; &quot;MY_SECRET_API_KEY&quot;

client &#x3D; TiingoClient(config)

historical_prices &#x3D; client.get_ticker_price(&quot;GOOGL&quot;,
                                            fmt&#x3D;&#39;json&#39;,
                                            startDate&#x3D;&#39;2017-08-01&#39;,
                                            endDate&#x3D;&#39;2017-08-31&#39;,
                                            frequency&#x3D;&#39;daily&#39;)

get_ticker_price 取得的历史数据会是 json 格式的，为了方便使用，我对其进行了简单的封装，将值转换成 DataFrame：
def get_df_from_tiingo(symbol, start, end):
    df &#x3D; pd.DataFrame(client.get_ticker_price(symbol,
                      startDate&#x3D;start,
                      endDate&#x3D;end,
                      frequency&#x3D;&#39;daily&#39;
                     ))
    df.set_index(&#39;date&#39;, inplace&#x3D;True)
    df.index &#x3D; pd.to_datetime(df.index)
    del df.index.name
    return df


]]></content>
      <tags>
        <tag>量化交易</tag>
        <tag>Python</tag>
        <tag>Tiingo</tag>
        <tag>Quandl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Node.js 构建 API Gateway [译]</title>
    <url>/2018/05/building-api-gateway-using-node-js.html</url>
    <content><![CDATA[
译者说：大前端的概念被提出已经很久了，那么在大前端的背景下，我们前端开发人员使用 Node.js 应该做什么，不应该做什么呢？相信此文能够提供一定的参考。

背景后台有着各种各样的服务，他们可能会使用不同的语言、数据库、协议及传输层。而客户端对数据也会有不同的要求，比如一个客户端可能需要 XML 格式而其他的需要 JSON。多少情况下，这些你都要支持。另一方面，不同的服务会有一些通用的共享逻辑，例如身份验证，我们不想在所有的服务中重复的去实现。于是就有了 API Gateway 的出现，它可以为不同的服务协议提供一个共享层，满足不同客户端的需求。
什么是 API Gateway？API Gateway 是一种微服务架构中的一种服务，它可以为客户端与内部服务通信提供一个共享层与 API。API Gateway 能够路由请求、转换协议、数据聚合及实现共享的逻辑（如身份验证、流量限制）。
你可以把 API Gateway 当作微服务世界的入口。根据客户端的需求，我们的系统可以有一个或多个 API Gateway。例如对桌面端和移动端我们可以有不同的 gateway。

前端团队的 Node.js API Gateway因为 API Gateway 的功能是提供给客户端的，所以它可以由负责前端应用的团队实现管理。这也意味着它的实现语言应该由负责客户端的团队选择。对应熟悉 JavaScript 的前端开发来说，Node.js 是很好的实现 API Gateway 的语言。
Netflix 成功的使用了 Node.js 的 API Gateway 与 Java 后端为多种客户端提供服务（The “Paved Road” PaaS for Microservices at Netflix）。

Paved PaaS to Microservices
API Gateway 的功能前面我们讨论了可以把通用共享逻辑放入 API Gateway，接下来将介绍 gateway 常见的职责。
路由和版本控制使用 API Gateway 作为微服务的入口时，在 gateway 服务中，你可以派发客户端的请求到不同的服务，通过路由控制版本。



进化设计API Gateway 还可以帮你分解庞大的体系结构。在大多数情况下，从头开始重写系统作为微服务不是一个好主意，也不可能，因为我们需要在转换过程中为业务提供功能。
这种情况下，我们可以把代理或者 API Gateway 放在庞大的体系结构前，把新的功能实现为微服务。之后我们就可以分解庞大的体系结构，迁移存在的功能到新的服务。
通过进化设计，我们可以从庞大的体系结构平滑过渡到微服务。

身份验证大多数微服务需要处理认证。将共享逻辑如身份验证添加到 API Gateway 可帮助您保持服务的小型化和领域化。
在微服务架构中，您可以通过网络配置将您的服务保护在 DMZ（demilitarized zone）中，并通过 API Gateway 将其展示给客户端。该 gateway 还可以支持多种身份验证方法。例如，您可以同时支持基于 cookie 和 token 的身份验证。

数据聚合在微服务架构中，客户端可能需要不同聚合级别的数据，比如在各种微服务中进行数据实体的非规范化。在这种情况下，我们可以使用我们的API Gateway 来解决这些依赖关系并从多个服务收集数据。

序列化格式转换可能发生的情况是，我们需要支持具有不同数据序列化格式要求的客户端。
假设我们的微服务使用 JSON，但我们的一个客户只能使用 XML。在这种情况下，我们可以将 JSON 转换为 XML 到API Gateway，而不是在所有微服务中实现。

协议转换微服务架构允许传输多种协议，从中获得不同技术的好处。但是大多数客户端只支持一种协议。在这种情况下，我们需要为客户端转换协议。
API网关还可以处理客户端和微服务之间的协议转换。在下图中，您可以看到客户端期望通过 HTTP REST 进行所有的通信，而我们的内部微服务使用 gRPC 和 GraphQL。

流量控制与缓存过于庞大的 API Gateway实现 API Gateway 的时候，应该避免把非通用的逻辑（如特点域的数据转换）放入 API Gateway。
服务应始终对其数据域拥有完全所有权。建立一个过于庞大的 API Gateway 违背了微服务的理念。
这就是为什么你应该小心在你的 API Gateway 中的数据聚合 - 它可能是强大的，但也可能导致你应该避免的特定领域的数据转换或规则处理逻辑。
始终为您的 API Gateway 定义明确的责任，并且只在其中包含通用共享逻辑。
Node.js API Gateway当你想要做简单的事情，例如将请求路由到特定的服务，您可以使用像 nginx 的反向代理。但是在某些时候，您可能需要实现一般代理不支持的逻辑。在这种情况下，您可以在 Node.js 中实现自己的 API Gateway。
在 Node.js 中，您可以使用 http-proxy 包简单地将请求代理到特定服务，或者使用功能更多的功能丰富的 express-gateway 来创建 API Gateway。
下面，我们在将在请求代理到用户服务之前对其进行身份验证。
const express &#x3D; require(&#39;express&#39;)
const httpProxy &#x3D; require(&#39;express-http-proxy&#39;)
const app &#x3D; express()

const userServiceProxy &#x3D; httpProxy(&#39;https:&#x2F;&#x2F;user-service&#39;)

&#x2F;&#x2F; Authentication
app.use((req, res, next) &#x3D;&gt; &#123;
  &#x2F;&#x2F; TODO: my authentication logic
  next()
&#125;)

&#x2F;&#x2F; Proxy request
app.get(&#39;&#x2F;users&#x2F;:userId&#39;, (req, res, next) &#x3D;&gt; &#123;
  userServiceProxy(req, res, next)
&#125;)

除此之外可以在 API Gateway 中发出新请求，并将响应返回给客户端：
const express &#x3D; require(&#39;express&#39;)
const request &#x3D; require(&#39;request-promise-native&#39;)
const app &#x3D; express()

&#x2F;&#x2F; Resolve: GET &#x2F;users&#x2F;me
app.get(&#39;&#x2F;users&#x2F;me&#39;, async (req, res) &#x3D;&gt; &#123;
  const userId &#x3D; req.session.userId
  const uri &#x3D; &#96;https:&#x2F;&#x2F;user-service&#x2F;users&#x2F;$&#123;userId&#125;&#96;
  const user &#x3D; await request(uri)
  res.json(user)
&#125;)

总结API Gateway 提供了一个共享层，以满足微服务架构的客户端的需求。它有助于保持您的服务小而专注于领域。您可以将不同的通用逻辑添加到 API Gateway，但您应该避免使用过于庞大的 API Gateway，因为它们会从服务获得控制权。


Building an API Gateway using Node.js

]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>translation</tag>
        <tag>Microservices</tag>
        <tag>微服务</tag>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中 repeat 的多种实现方法</title>
    <url>/2018/05/multiple-methods-of-repeat-implementation-in-js.html</url>
    <content><![CDATA[
最近翻回了 『JavaScript 框架设计』这本司徒正美编著，在 2014 年发行的书，此书主要讲述了从零开始写一个前端框架所要掌握的内容，每次阅读都会有新的收获。其中内容会在兼容性及性能上做很多考量，本文便是书中的一个关于字符串方法 repeat 实现的例子。


空数组 join

function repeat(target, n) &#123;
  return (new Array(n + 1)).join(target);
&#125;


改良方法 1，省去创建数组这一步，提高性能。另，之所以创建一个带 length 属性的对象，是因为要调用数组的原型方法，需要指定 call 第一个参数为类数组对象。

function repeat(target, n) &#123;
  return Array.prototype.join.call(&#123;
    length: n + 1
  &#125;, target);
&#125;


改良方法 2，利用闭包缓存 join，避免重复创建对象、寻找方法。

var repeat &#x3D; (function () &#123;
  var join &#x3D; Array.prototype.join, obj &#x3D; &#123;&#125;;
  return function(target, n) &#123;
    obj.length &#x3D; n + 1;
    return join.call(obj, target);
  &#125;;
&#125;)();


使用二分法，减少操作次数

function repeat(target, n) &#123;
  var s &#x3D; target, total &#x3D; [];
  while (n &gt; 0) &#123;
    if (n % 2 &#x3D;&#x3D;&#x3D; 1) &#123;
      total[total.length] &#x3D; s;
    &#125;
    if (n &#x3D;&#x3D;&#x3D; 1) &#123;
      break;
    &#125;

    s +&#x3D; s;
    n &#x3D; n &gt;&gt; 1; &#x2F;&#x2F; Math.floor(n &#x2F; 2);
  &#125;
  return total.join(&#39;&#39;);
&#125;




4 的变种，免去创建数组与使用 join。缺点是循环中创建的字符串比要求的长。

function repeat(target, n) &#123;
  var s &#x3D; target, c &#x3D; s.length * n;
  do &#123;
    s +&#x3D; s;
  &#125; while (n &#x3D; n &gt;&gt; 1)
  s &#x3D; s.substring(0, c);
  return s;
&#125;


4 的改良。

function repeat(target, n) &#123;
  var s &#x3D; target, total &#x3D; &quot;&quot;;
  while (n &gt; 0) &#123;
    if (n % 2 &#x3D;&#x3D;&#x3D; 1) &#123;
      total +&#x3D; s;
    &#125;
    if (n &#x3D;&#x3D;&#x3D; 1) &#123;
      break;
    &#125;
    s +&#x3D; s;
    n &#x3D; n &gt;&gt; 1;
  &#125;
  return total;
&#125;


与 6 相近，不过递归在浏览器中有优化。

function repeat(target, n) &#123;
  if (n &#x3D;&#x3D;&#x3D; 1) &#123;
    return target;
  &#125;
  var s &#x3D; repeat(target, Math.floor(n &#x2F; 2));
  s +&#x3D; s;
  if (n % 2) &#123;
    s +&#x3D; target;
  &#125;
  return s;
&#125;


一则反例，很慢，但是可行。

function repeat(target, n) &#123;
  return (n &lt;&#x3D; 0) ? &quot;&quot; : target.concat(repeat(target, --n));
&#125;
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>repeat</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移猿文档到 Severless 架构</title>
    <url>/2018/05/transfer-yuanwendang-to-serverless-architecture.html</url>
    <content><![CDATA[背景好早前就知道了 Serverless 架构，近日发现阿里云支持了函数计算，便决定将猿文档的后端服务进行迁移。
此前，猿文档的后端服务基于 Node.js，采用 egg.js 框架，运行于 docker 中，购买的是阿里云的云服务器 ECS。之所以决定此次迁移是由于以下几点原因：

按使用收费：目前猿文档的请求量并不大，不存在高频请求的情况，阿里云函数计算的免费额度够用。
功能简单：猿文档只有三个接口，方便迁移。
维护性：使用无服务器架构只需要部署一个个函数，简单易用。

进行阿里云函数计算可以在这里了解函数计算文档中心。
原 3 个接口可以很方便的写成三个函数，基本格式如下：
module.exports.handler &#x3D; function (request, response, context) &#123;
  const queries &#x3D; request.queries;
  &#x2F;&#x2F; ...
  const res &#x3D; &#123;
    message: &#39;ok&#39;,
    code: 0,
  &#125;;
  response.setHeader(&#39;Content-Type&#39;, &#39;application&#x2F;json&#39;);
  response.setStatusCode(200);
  response.send(JSON.stringify(res));
&#125;;

部署使用 fcli 工具。进入 fcli shell 后基本操作如下：
&gt;&gt;&gt; ls  # 查看服务列表
&gt;&gt;&gt; cd yuanwendang  # 进入服务
&gt;&gt;&gt; ls  # 查看函数列表
&gt;&gt;&gt; mkf doc-entry -h entry.handler -d .&#x2F;doc-entry -t nodejs8  # 新建函数
&gt;&gt;&gt; upf doc-entry -h entry.handler -d .&#x2F;doc-entry -t nodejs8  # 更新函数



在阿里云的管理控制台中会将服务中的函数清晰的呈现出来：

其中 public 函数是用来响应静态文件请求的：
&#39;use strict&#39;;
const fs &#x3D; require(&#39;fs&#39;);
const util &#x3D; require(&#39;util&#39;);
const path &#x3D; require(&#39;path&#39;);
const mime &#x3D; require(&#39;mime-types&#39;);

const stat &#x3D; util.promisify(fs.stat);
const readFile &#x3D; util.promisify(fs.readFile);

const send404 &#x3D; (response) &#x3D;&gt; &#123;
  response.setHeader(&#39;Content-Type&#39;, &#39;text&#x2F;plain&#39;);
  response.setStatusCode(404);
  response.send(&#39;404 Not Found&#39;);
&#125;;

module.exports.handler &#x3D; function (request, response, context) &#123;
  const reqPath &#x3D; request.path;
  const filePath &#x3D; path.join(__dirname, reqPath);
  stat(filePath)
    .then(stats &#x3D;&gt; &#123;
      if (stats.isFile()) &#123;
        readFile(filePath)
          .then(data &#x3D;&gt; &#123;
            response.setStatusCode(200);
            const contentType &#x3D; mime.lookup(filePath) || &#39;application&#x2F;octet-stream&#39;;
            response.setHeader(&#39;Content-Type&#39;, contentType);
            response.send(data);
          &#125;)
          .catch(err &#x3D;&gt; &#123;
            console.error(err);
            send404(response);
          &#125;);
      &#125; else &#123;
        send404(response);
      &#125;
    &#125;)
    .catch(err &#x3D;&gt; &#123;
      send404(response);
    &#125;)
&#125;;

每一个函数都可以在控制台中编辑，调试：

Fn projectFn项目是一个开源的容器本地无服务器平台，您可以在任何地方运行 - 任何云或内部部署。它易于使用，支持多种编程语言，并且是可扩展和高性能的。
]]></content>
      <tags>
        <tag>Serverless</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Install IB Gateway on RaspberryPi</title>
    <url>/2018/12/install-ib-gate-way-on-raspberry-pi.html</url>
    <content><![CDATA[从 Oracle 官网下载安装 jdk8。
从 IB 官网下载 IB Gateway for Linux。
使用二进制模式修改 ibgateway-stable-standalone-linux-x86.sh
$ vim -b ~&#x2F;ibgateway-stable-standalone-linux-x86.sh

将 INSTALL4J_JAVA_HOME_OVERRIDE 赋值为安装的 jdk8 的路径
INSTALL4J_JAVA_HOME_OVERRIDE&#x3D;&quot;&#x2F;opt&#x2F;jdk1.8.0_191&#x2F;&quot;

修改 test_jvm() 函数，删除版本检查的逻辑
  if [ &quot;$ver_major&quot; &#x3D; &quot;&quot; ]; then
    return;
  fi
-  if [ &quot;$ver_major&quot; -lt &quot;1&quot; ]; then
-    return;
-  elif [ &quot;$ver_major&quot; -eq &quot;1&quot; ]; then
-    if [ &quot;$ver_minor&quot; -lt &quot;8&quot; ]; then
-      return;
-    elif [ &quot;$ver_minor&quot; -eq &quot;8&quot; ]; then
-      if [ &quot;$ver_micro&quot; -lt &quot;0&quot; ]; then
-        return;
-      elif [ &quot;$ver_micro&quot; -eq &quot;0&quot; ]; then
-        if [ &quot;$ver_patch&quot; -lt &quot;152&quot; ]; then
-          return;
-        fi
-      fi
-    fi
-  fi
-
-  if [ &quot;$ver_major&quot; &#x3D; &quot;&quot; ]; then
-    return;
-  fi
-  if [ &quot;$ver_major&quot; -gt &quot;1&quot; ]; then
-    return;
-  elif [ &quot;$ver_major&quot; -eq &quot;1&quot; ]; then
-    if [ &quot;$ver_minor&quot; -gt &quot;8&quot; ]; then
-      return;
-    elif [ &quot;$ver_minor&quot; -eq &quot;8&quot; ]; then
-      if [ &quot;$ver_micro&quot; -gt &quot;0&quot; ]; then
-        return;
-      elif [ &quot;$ver_micro&quot; -eq &quot;0&quot; ]; then
-        if [ &quot;$ver_patch&quot; -gt &quot;152&quot; ]; then
-          return;
-        fi
-      fi
-    fi
-  fi

  app_java_home&#x3D;$test_dir
&#125;

安装 IB Gateway
$ .&#x2F;ibgateway-stable-standalone-linux-x86.sh

安装完成后直接执行 IB Gateway 会提示
No suitable Java Virtual Machine could be found on your system.
The version of the JVM must be 1.8.0_152.
Please define INSTALL4J_JAVA_HOME to point to a suitable JVM.

需要使用同样的方式修改 ~/Jts/ibgateway/972/ibgateway。
]]></content>
      <tags>
        <tag>ib</tag>
        <tag>RaspberryPi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 hddtemp 于未知 SSD</title>
    <url>/2019/02/hddtemp-for-unknown-ssd.html</url>
    <content><![CDATA[部分 SSD 无法被 hddtemp 获取到温度信息：
$ sudo hddtemp &#x2F;dev&#x2F;sda
WARNING: Drive &#x2F;dev&#x2F;sda doesn&#39;t seem to have a temperature sensor.
WARNING: This doesn&#39;t mean it hasn&#39;t got one.
WARNING: If you are sure it has one, please contact me (hddtemp@guzu.net).
WARNING: See --help, --debug and --drivebase options.
&#x2F;dev&#x2F;sda: Samsung SSD 860 EVO 500G B              @:  no sensor

安装 smartmontools：
$ sudo apt-get install smartmontools



使用 smartctl 查看设备的 SMART 信息：
$ smartctl -a &#x2F;dev&#x2F;sda
smartctl 6.6 2016-05-31 r4324 [x86_64-linux-4.20.10-042010-generic] (local build)
Copyright (C) 2002-16, Bruce Allen, Christian Franke, www.smartmontools.org

&#x3D;&#x3D;&#x3D; START OF INFORMATION SECTION &#x3D;&#x3D;&#x3D;
Device Model:     Samsung SSD 860 EVO 500GB
Serial Number:    S3Z3NB0KA38288Y
LU WWN Device Id: 5 002538 e408d72bb
Firmware Version: RVT01B6Q
User Capacity:    500,107,862,016 bytes [500 GB]
Sector Size:      512 bytes logical&#x2F;physical
Rotation Rate:    Solid State Device
Form Factor:      2.5 inches
Device is:        Not in smartctl database [for details use: -P showall]
ATA Version is:   Unknown(0x09fc), ACS-4 T13&#x2F;BSR INCITS 529 revision 5
SATA Version is:  SATA 3.1, 6.0 Gb&#x2F;s (current: 6.0 Gb&#x2F;s)
Local Time is:    Sat Feb 16 14:28:48 2019 CST
SMART support is: Available - device has SMART capability.
SMART support is: Enabled

&#x3D;&#x3D;&#x3D; START OF READ SMART DATA SECTION &#x3D;&#x3D;&#x3D;
SMART overall-health self-assessment test result: PASSED

General SMART Values:
Offline data collection status:  (0x00)	Offline data collection activity
					was never started.
					Auto Offline Data Collection: Disabled.
Self-test execution status:      (   0)	The previous self-test routine completed
					without error or no self-test has ever 
					been run.
Total time to complete Offline 
data collection: 		(    0) seconds.
Offline data collection
capabilities: 			 (0x53) SMART execute Offline immediate.
					Auto Offline data collection on&#x2F;off support.
					Suspend Offline collection upon new
					command.
					No Offline surface scan supported.
					Self-test supported.
					No Conveyance Self-test supported.
					Selective Self-test supported.
SMART capabilities:            (0x0003)	Saves SMART data before entering
					power-saving mode.
					Supports SMART auto save timer.
Error logging capability:        (0x01)	Error logging supported.
					General Purpose Logging supported.
Short self-test routine 
recommended polling time: 	 (   2) minutes.
Extended self-test routine
recommended polling time: 	 (  85) minutes.
SCT capabilities: 	       (0x003d)	SCT Status supported.
					SCT Error Recovery Control supported.
					SCT Feature Control supported.
					SCT Data Table supported.

SMART Attributes Data Structure revision number: 1
Vendor Specific SMART Attributes with Thresholds:
ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
  5 Reallocated_Sector_Ct   0x0033   100   100   010    Pre-fail  Always       -       0
  9 Power_On_Hours          0x0032   099   099   000    Old_age   Always       -       208
 12 Power_Cycle_Count       0x0032   099   099   000    Old_age   Always       -       87
177 Wear_Leveling_Count     0x0013   099   099   000    Pre-fail  Always       -       2
179 Used_Rsvd_Blk_Cnt_Tot   0x0013   100   100   010    Pre-fail  Always       -       0
181 Program_Fail_Cnt_Total  0x0032   100   100   010    Old_age   Always       -       0
182 Erase_Fail_Count_Total  0x0032   100   100   010    Old_age   Always       -       0
183 Runtime_Bad_Block       0x0013   100   100   010    Pre-fail  Always       -       0
187 Reported_Uncorrect      0x0032   100   100   000    Old_age   Always       -       0
190 Airflow_Temperature_Cel 0x0032   069   053   000    Old_age   Always       -       31
195 Hardware_ECC_Recovered  0x001a   200   200   000    Old_age   Always       -       0
199 UDMA_CRC_Error_Count    0x003e   100   100   000    Old_age   Always       -       0
235 Unknown_Attribute       0x0012   099   099   000    Old_age   Always       -       33
241 Total_LBAs_Written      0x0032   099   099   000    Old_age   Always       -       1764231405

SMART Error Log Version: 1
No Errors Logged

SMART Self-test log structure revision number 1
No self-tests have been logged.  [To run self-tests, use: smartctl -t]

SMART Selective self-test log data structure revision number 1
 SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS
    1        0        0  Not_testing
    2        0        0  Not_testing
    3        0        0  Not_testing
    4        0        0  Not_testing
    5        0        0  Not_testing
Selective self-test flags (0x0):
  After scanning selected spans, do NOT read-scan remainder of disk.
If Selective self-test is pending on power-up, resume after 0 minute delay.

可以找到温度传感器对应的 ID 为 190。
找到 hddtemp.db 文件：
$ sudo find -name &#39;hddtemp.db&#39;
.&#x2F;etc&#x2F;hddtemp.db

编辑文件，增加相关设备的信息：
&quot;Samsung SSD 860 EVO 500G B&quot;    190     C &quot;Samsung SSD 860 EVO 500GB&quot;

]]></content>
      <tags>
        <tag>SSD</tag>
        <tag>hddtemp</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch 解析 GBK 编码 Response</title>
    <url>/2019/03/fetch-parse-response-in-gbk.html</url>
    <content><![CDATA[通常情况，当我们使用 fetch 发送网络请求，并获得 content-type 为 application/json 的 Response 时，我们需要使用 text() 或 json() 得到 body 的 JSON 对象。但是 text() 或 json() 仅支持 UTF-8 编码的 response，若编码为 GBK，则得到的 JSON 对象中会存在乱码。
若想正确解析 GBK 编码的 response，我们可以先将 response 的 body 转换为 Blob 对象，再使用 FileReader.readAsText(blob[, encoding]) 通过正确的 encoding 读取为文本。
(function () &#123;
    const readBlobAsText &#x3D; (blob, encoding) &#x3D;&gt; &#123;
        return new Promise((resolve, reject) &#x3D;&gt; &#123;
            const fr &#x3D; new FileReader();
            fr.onload &#x3D; event &#x3D;&gt; &#123;
                resolve(fr.result);
            &#125;;

            fr.onerror &#x3D; err &#x3D;&gt; &#123;
                reject(err);
            &#125;;

            fr.readAsText(blob, encoding);
        &#125;);
    &#125;;

    fetch(&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;hanai&quot;, &#123;
        &quot;body&quot;: null,
        &quot;method&quot;: &quot;GET&quot;
    &#125;).then(res &#x3D;&gt; &#123;
        const contentType &#x3D; res.headers.get(&#39;content-type&#39;);
        if (contentType !&#x3D;&#x3D; null) &#123;
            if (&#x2F;(^|;)application\&#x2F;json($|;)&#x2F;i.test(contentType)) &#123;
                const charsetMatches &#x3D; contentType.match(&#x2F;(^|;)charset&#x3D;([^;]+)($|;)&#x2F;i);
                if (charsetMatches &amp;&amp; charsetMatches.length &amp;&amp; charsetMatches[2]) &#123;
                    const charset &#x3D; charsetMatches[2];
                    return res.blob().then(blob &#x3D;&gt; readBlobAsText(blob, charset)).then(JSON.parse);
                &#125; else &#123;
                    return res.json();
                &#125;
            &#125;
        &#125;
    &#125;).then(data &#x3D;&gt; &#123;
        console.log(data);
    &#125;);
&#125;());
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>fetch</tag>
        <tag>GBK</tag>
        <tag>encoding</tag>
        <tag>charset</tag>
      </tags>
  </entry>
  <entry>
    <title>React Developer Tools 检查 iframe 中的元素</title>
    <url>/2019/05/react-developer-tools-inspect-element-in-iframe.md.html</url>
    <content><![CDATA[在 iframe 的 React 应用引入 React 前添加以下代码：
__REACT_DEVTOOLS_GLOBAL_HOOK__ &#x3D; parent.__REACT_DEVTOOLS_GLOBAL_HOOK__;]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React Developer Tools</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title>Database Navigator 连接 HSQLDB</title>
    <url>/2019/06/database-navigator-connect-hsqldb.html</url>
    <content><![CDATA[Database Navigator 是 IDEA 的一个用于数据库开发的插件。它默认提供了 Oracle, MySQL, PostgreSQL, SQLite 四种类型数据库连接的模板，连接 HSQLDB 需要选择 Generic 手动配置。

如图，URL 中配置数据库的本地路径，Driver library 中配置 hsqldb 库的本地路径（一般在 ~/.gradle/caches 下，可以在 Project 窗口的 External Libraries 中找到 hsqldb-x.x.x.jar，右键 Copy Path 获得）。
]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>HSQLDB</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>批量修改 git 的 commiter</title>
    <url>/2020/02/batch-modify-git-commiter.html</url>
    <content><![CDATA[使用如下脚本：
#!&#x2F;bin&#x2F;sh

git filter-branch --env-filter &#39;

OLD_EMAIL&#x3D;&quot;your-old-email@example.com&quot;
CORRECT_NAME&#x3D;&quot;Your Correct Name&quot;
CORRECT_EMAIL&#x3D;&quot;your-correct-email@example.com&quot;

if [ &quot;$GIT_COMMITTER_EMAIL&quot; &#x3D; &quot;$OLD_EMAIL&quot; ]
then
    export GIT_COMMITTER_NAME&#x3D;&quot;$CORRECT_NAME&quot;
    export GIT_COMMITTER_EMAIL&#x3D;&quot;$CORRECT_EMAIL&quot;
fi
if [ &quot;$GIT_AUTHOR_EMAIL&quot; &#x3D; &quot;$OLD_EMAIL&quot; ]
then
    export GIT_AUTHOR_NAME&#x3D;&quot;$CORRECT_NAME&quot;
    export GIT_AUTHOR_EMAIL&#x3D;&quot;$CORRECT_EMAIL&quot;
fi
&#39; --tag-name-filter cat -- --branches --tags

运行完成后执行：
$ git push --force --tags origin &#39;refs&#x2F;heads&#x2F;*&#39;


Changing author info

]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GraphQL API 构建基于 Issues 的博客</title>
    <url>/2020/02/build-blog-based-on-issues-with-graphql-api.html</url>
    <content><![CDATA[身边有很多人把 GitHub 的 Issues 用作个人博客，它具有写作方便、免于部署的优点，但是由于需要从仓库的 Issues 访问，定制化程度很低。
GitHub 提供了访问仓库的 Issues 的 API，我们可以自己开发定制前端页面，发布到 GitHub Pages，前端调用 API 读取 Issues 动态渲染页面。这样我们依旧能够在 GitHub 上新建&#x2F;修改文章，同时不用再去进行发布操作。
简单实现

Github 当前提供了 2 种版本的 API：

REST API v3
GraphQL API v4

它们都能满足我们的需求，但是 REST 版本返回的数据较多，里面有很多我们不需要的内容，所以这里我们选择可定制性更强的 GraphQL 版本。
查询语句的构建可以在 GraphQL API Explorer 进行。


查询语句：
&#123;
  search(type: ISSUE, query: &quot;label:tip repo:hanai&#x2F;blog_source&quot;, first: 10) &#123;
    nodes &#123;
      ... on Issue &#123;
        title
        body
        bodyHTML
        createdAt
        labels(first: 8) &#123;
          nodes &#123;
            name
          &#125;
        &#125;
        lastEditedAt
      &#125;
    &#125;
  &#125;
&#125;

前端页面请求 API：
fetch(&quot;https:&#x2F;&#x2F;api.github.com&#x2F;graphql&quot;, &#123;
  method: &quot;POST&quot;,
  headers: &#123;
    authorization: &quot;bearer &#123;&#123;token&#125;&#125;&quot;
  &#125;,
  body: JSON.stringify(&#123;
    query: query
  &#125;)
&#125;)
  .then(res &#x3D;&gt; res.json())
  .then(console.log);

安全实现直接将自己 GitHub 的 access token 暴露在公网环境是非常危险的（本例中 access token 对公开仓库具有写权限），实际使用中可以借助云服务商提供的函数计算服务作为网关来请求 GitHub 的 API：


以阿里云为例，代码如下：
const process &#x3D; require(&#39;process&#39;);
const https &#x3D; require(&quot;https&quot;);

module.exports.handler &#x3D; function (req, resp, context) &#123;
    const &#123; queries, headers &#125; &#x3D; req;
    const &#123; origin &#125; &#x3D; headers;

    const ak &#x3D; process.env.ak;

    if (&#x2F;\.ihanai\.com&#x2F;.test(origin)) &#123;
        const postData &#x3D; JSON.stringify(&#123;
            &#39;query&#39;: &#96;&#123;
  search(type: ISSUE, query: &quot;label:tip repo:hanai&#x2F;blog_source&quot;, first: 10) &#123;
    nodes &#123;
      ... on Issue &#123;
        title
        body
        bodyHTML
        createdAt
        labels(first: 8) &#123;
          nodes &#123;
            name
          &#125;
        &#125;
        lastEditedAt
      &#125;
    &#125;
  &#125;
&#125;&#96;
        &#125;);
        const httpReq &#x3D; https.request(&#123;
            host: &#39;api.github.com&#39;,
            path: &#39;&#x2F;graphql&#39;,
            method: &#39;POST&#39;,
            headers: &#123;
                authorization: &quot;bearer &quot; + ak,
                &#39;Content-Length&#39;: Buffer.byteLength(postData),
                &#39;user-agent&#39;: &quot;Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.100 Safari&#x2F;537.36&quot;
            &#125;
        &#125;, res &#x3D;&gt; &#123;
            res.setEncoding(&#39;utf8&#39;);
            const chunks &#x3D; [];
            res.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;
                chunks.push(chunk);
            &#125;);
            res.on(&#39;end&#39;, () &#x3D;&gt; &#123;
                resp.setStatusCode(200);
                resp.setHeader(&#39;content-type&#39;, &#39;application&#x2F;json&#39;);
                resp.setHeader(&#39;Access-Control-Allow-Origin&#39;, origin);
                const json &#x3D; JSON.parse(chunks.join(&#39;&#39;));
                resp.send(JSON.stringify(json.data.search));
            &#125;);
        &#125;);
        httpReq.write(postData);
        httpReq.end();
    &#125; else &#123;
        resp.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;https:&#x2F;&#x2F;blog.ihanai.com&#39;);
        resp.send(&#39;&#39;);
    &#125;
&#125;
]]></content>
      <tags>
        <tag>Serverless</tag>
        <tag>GraphQL</tag>
        <tag>GitHub</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>使 Access-Control-Allow-Origin 支持多个 Origin</title>
    <url>/2020/02/make-access-control-allow-origin-support-multiple-origin.html</url>
    <content><![CDATA[做跨域请求时，会需要用到 HTTP 响应头部的 Access-Control-Allow-Origin 属性，但是这个属性只能配置一个域，当一个接口需要被多个域请求时，该如何配置呢？
很简单，动态设置这个值就好，以一个部署在阿里云上的函数为例：
module.exports.handler &#x3D; function (req, resp, context) &#123;
    const &#123; queries, headers &#125; &#x3D; req;
    const &#123; origin &#125; &#x3D; headers;

    if (&#x2F;\.ihanai\.com&#x2F;.test(origin)) &#123;
        resp.setHeader(&#39;Access-Control-Allow-Origin&#39;, origin);
        resp.send(&#39;&#39;);
    &#125; else &#123;
        resp.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;https:&#x2F;&#x2F;blog.ihanai.com&#39;);
        resp.send(&#39;&#39;);
    &#125;
&#125;
]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>AliOS Things 在 NodeMCU 上的实践</title>
    <url>/2020/09/aos-on-nodemcu.html</url>
    <content><![CDATA[构建环境安装 ESP32 工具链在 Linux 环境开发，需要 xtensa-esp32-elf。
安装依赖：
$ yay -S --needed gcc git make ncurses flex bison gperf
$ pip install pyserial

下载安装工具链：
$ wget -P ~&#x2F;Downloads https:&#x2F;&#x2F;dl.espressif.com&#x2F;dl&#x2F;xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz
$ mkdir -p ~&#x2F;esp
$ cd ~&#x2F;esp
$ tar -xzf ~&#x2F;Downloads&#x2F;xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz

更新环境变量：
# ~&#x2F;.profile
export PATH&#x3D;&quot;$PATH:$HOME&#x2F;esp&#x2F;xtensa-esp32-elf&#x2F;bin&quot;



安装 AOS 开发工具安装 aos-cube：
$ pip install --trusted-host&#x3D;mirrors.aliyun.com -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; aos-cube

下载 AliOS Things 源代码并配置环境变量：
$ git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;AliOS-Things.git -b rel_3.1.0
$ echo &quot;export AOS_SDK_PATH&#x3D;&#x2F;home&#x2F;user&#x2F;AliOS-Things&quot; &gt;&gt; ~&#x2F;.profile

新建项目选择正确的 board当前 AliOS Things 支持的 board 可以在 https://aliosthings.iot.aliyun.com/aos/download?version=latest 这里看到，我使用的是 NodeMCU，对应 board_esp32devkitc。

其他
实际操作中发现，在 ArchLinux 系统下， aos 依赖 libselinux，需要另外安装：

$ yay -S libselinux


Visual Studio Code 的 alios-studio 扩展会在 ~/.aos/pyenv-venv 创建新的 virtualenv，若是使用此扩展进行开发，需注意当前所在环境。

串口监听工具 minicom 和 jpnevulator 各有千秋


参考
ESP-IDF Programming Guide - Get Started - Standard Setup of Toolchain for Linux
IoT 物联网操作系统 - 快速开始 - 开发环境安装 - Linux 环境安装

]]></content>
      <tags>
        <tag>AOS</tag>
        <tag>AliOS Things</tag>
        <tag>NodeMCU</tag>
      </tags>
  </entry>
  <entry>
    <title>使用结构化克隆算法克隆复杂对象</title>
    <url>/2020/09/clone-complex-object-with-structured-algo.html</url>
    <content><![CDATA[const clone &#x3D; (obj) &#x3D;&gt; &#123;
  const id &#x3D; Date.now();
  return new Promise((resolve, reject) &#x3D;&gt; &#123;
    const onMessage &#x3D; (e) &#x3D;&gt; &#123;
      if (e &amp;&amp; e.data &amp;&amp; e.data.id &#x3D;&#x3D;&#x3D; id) &#123;
        resolve(e.data.obj);
        window.removeEventListener(&quot;message&quot;, onMessage);
      &#125;
    &#125;;
    window.addEventListener(&quot;message&quot;, onMessage);
    window.postMessage(&#123;
      id: id,
      obj: obj,
    &#125;);
  &#125;);
&#125;;

clone(&#123;
  date: new Date(),
  reg: &#x2F;\d+&#x2F;,
  child: &#123;
    arr: [
      1,
      3,
      new Map(
        Object.entries(&#123;
          apple: &quot;red&quot;,
        &#125;)
      ),
    ],
  &#125;,
&#125;).then(console.log);

参考
MDN - The structured clone algorithm

]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>postMessage</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM 节点遍历可视化</title>
    <url>/2020/09/dom-node-traverse-visualization.html</url>
    <content><![CDATA[
DOM 树是树形结构，且对 DOM 的操作可以在浏览器中看到，那么是否可以借此做对树形结构操作的可视化呢？

今日在写一个用来高亮 DOM 节点中匹配到指定正则的文本的代码时，实现了一个遍历 DOM 节点的函数：
const traverseNode &#x3D; (node, cb, isChild) &#x3D;&gt; &#123;
  if (node.firstChild) &#123;
    traverseNode(node.firstChild, cb, true);
  &#125;

  cb(node);

  if (isChild &amp;&amp; node.nextSibling) &#123;
    traverseNode(node.nextSibling, cb, true);
  &#125;
&#125;;

写完之后，我想到一个问题：既然 DOM 树是个树形结构，而且对 DOM 节点样式的修改可以被浏览器反映出来，那么是否可以做出遍历树形结构的可视化呢？
成果：

]]></content>
      <tags>
        <tag>Visualization</tag>
        <tag>DOM</tag>
        <tag>Data Struct</tag>
      </tags>
  </entry>
  <entry>
    <title>新玩具 GET - NodeMCU 32S</title>
    <url>/2020/09/new-toy-get-nodemcu-32s.html</url>
    <content><![CDATA[近日买了个新玩具：NodeMCU 32S，这是一个可玩性极强的 ESP32 开发版。
ESP32 是乐鑫出的提供了 Wi-Fi 与蓝牙功能的 MCU，功能强大，用途广泛，可用于低功耗传感器网络。成本很低，约 15 元。


$ esptool.py --chip esp32 --port &#x2F;dev&#x2F;ttyUSB0 --baud 115200 read_mac
esptool.py v2.8
Serial port &#x2F;dev&#x2F;ttyUSB0
Connecting.....
Chip is ESP32D0WDQ5 (revision 1)
Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None
Crystal is 40MHz
MAC: 40:f5:20:79:d9:38
Uploading stub...
Running stub...
Stub running...
MAC: 40:f5:20:79:d9:38
Hard resetting via RTS pin...
]]></content>
      <tags>
        <tag>NodeMCU</tag>
        <tag>ESP32</tag>
      </tags>
  </entry>
  <entry>
    <title>欧陆风云4 存档管理器开发小记</title>
    <url>/2020/09/note-of-eu4-save-manager-development.html</url>
    <content><![CDATA[近日在玩欧陆风云 4，为了完成成就，所以选择了铁人模式，由于是新手+铁人模式不能自由存档（新存档会覆盖旧存档），容错率较低，故考虑开发一个工具来管理存档，将新的存档备份起来，以便需要时读取。
第一版是使用 Node.js 实现的，通过 setInterval 定时备份存档文件。这种做法有些缺陷：

没有 GUI，每次需要手动在 cmd 下执行
不能监听存档文件的变动，手动保存的存档不一定会被备份
会生成很多重复的文件
不好查看备份操作的记录

于是考虑开发一个 GUI 应用，希望它具有以下能力

跨平台（欧陆风云 4 支持 Windows&#x2F;Linux&#x2F;Mac）
能够选择存档目录
能够监听文件变动（做保存操作时能够触发，将新的存档备份）
能够展示备份操作记录
能力强大可扩展（为后续开发提供空间）

综合考虑后，决定使用 Python + PyQt 开发。


UI 绘制：
使用 Qt Designer 生成 .ui 文件，通过 pyside2-uic 将 .ui 文件编译成 .py 文件，在 MainWindow 中引入：
from ui.MainWindow import Ui_MainWindow

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui &#x3D; Ui_MainWindow()
        self.ui.setupUi(self)

Windows 系统下 QDialog 窗口右上角有问号按钮：
app.setAttribute(Qt.AA_DisableWindowContextHelpButton)

应用打包：
使用 pyinstaller 打包，在 Windows 和 Mac 环境下，生成文件大小约为 30-50MB，使用 UPX+生成单文件的情况下可以大幅缩小文件尺寸。
后续计划：

构建
完善图标、bundle identifier 等信息
使用 GitHub Actions 自动调用 pyinstaller 完成构建


功能
检查文件 hash，避免生成重复备份
展示备份操作记录（时间列+文件名列）
从存档中解析出国家、时间信息，在管理器界面展示



项目地址：https://github.com/hanai/eu4-save-manager
]]></content>
      <tags>
        <tag>Europa Universalis IV</tag>
        <tag>欧陆风云</tag>
        <tag>Game</tag>
        <tag>PySide2</tag>
        <tag>PyQt</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>SHENZHEN I/O</title>
    <url>/2020/09/shenzhen-io.html</url>
    <content><![CDATA[Manual:

English
中文

模拟安全摄像头


cost
power
loc



6
60
12





控制信号放大器


cost
power
loc



3
240
4



诊断脉冲生成器


cost
power
loc



3
164
6



动画 ESPORTS 标志


cost
power
loc



11
236
20


思路：

由 click-0 与 click-1 输出相反，可考虑通过一个 P 引脚输出 click-0，通过反向器输出 click-1
此时处理器 1 剩余一个 P 引脚，可输出 drink-0
drink-1 与 drink-2 由处理器 2 输出





cost
power
loc



9
179
16


思路：

观察发现 drink-0 可由 drink-1 与 drink-2 XOR 运算得到，故可使用一个处理器 + 一个异或门得出 drink-0, drink-1, drink-2


饮酒游戏积分器


cost
power
loc



3
323
8



调谐最优化引擎


cost
power
loc



6
515
11


思路：

由于 P 引脚数量限制，使用两个控制器，一个读取 maximize 状态，一个读取音频输入，并进行数值运算。


被动红外感应器


cost
power
loc



7
458
11


思路：

由于 P 引脚数量及价格因素，使用 I&#x2F;0 扩展器做最终输出





cost
power
loc



6
398
10


思路：

由前一方案将两个 MC4000 替换为一个 MC6000


]]></content>
      <tags>
        <tag>Game</tag>
        <tag>SHENZHEN I/O</tag>
        <tag>Assembly</tag>
        <tag>Microcontroller</tag>
        <tag>Zachtronics</tag>
      </tags>
  </entry>
  <entry>
    <title>从 YouTube 下载视频</title>
    <url>/2020/10/download-video-from-youtube.html</url>
    <content><![CDATA[最近计划学习钢琴，有网友建议去看 Andrew Furmanczyk 的 How to play piano 系列视频进行学习，由于原视频是在 YouTube 上且字幕是由 YouTube 自动生成的，为了方便观看，需要下载下来。实际操作中，发现想要达到预期的效果并不容易，有很多细节需要注意，故作此文记录。

下载工具youtube-dl
代理配置--proxy
下载自动生成的字幕文件--write-auto-sub
字幕文件格式转换下载下来的字幕文件格式为 vtt，为了便于播放器读取，需转换为 srt 格式的文件 ffmpeg -i input.vtt output.srt
WARNING: Requested formats are incompatible for merge and will be merged into mkv.默认情况下，youtube-dl 将下载最佳画质和音质的流，然后将这些流打包到兼容的容器中。如果最佳的流不能存在 mp4 容器中时，youtube-dl 则会将它们打包到 mkv 容器中，这时就会看到这条警告。如果一定要将这些流打包到 mp4 容器中，则需要手动指定格式 -f &#39;bestvideo[ext=mp4]+bestaudio[ext=m4a]&#39;
以上这些配置可以直接写入 ~/.config/youtube-dl/config--no-playlist --write-auto-sub --proxy &quot;socks5:&#x2F;&#x2F;localhost:80&quot; -f &#39;bestvideo[ext&#x3D;mp4]+bestaudio[ext&#x3D;m4a]&#39; --user-agent &#39;Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36&#39;
批量转换 vtt 文件从 playlist 下载下来的会是多个 vtt 文件，可以使用 shell 脚本批量转换：#!&#x2F;bin&#x2F;bash
for f in .&#x2F;how_to_play_piano&#x2F;*.vtt;
do
    ffmpeg -i &quot;$f&quot; &quot;$&#123;f%.vtt&#125;&quot;.srt;
done

]]></content>
      <tags>
        <tag>YouTube</tag>
        <tag>钢琴</tag>
        <tag>youtube-dl</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具 - spreadsheet 转 table</title>
    <url>/2020/10/small-tool-spreadsheet-to-table.html</url>
    <content><![CDATA[背景用 Markdown 写文档时，经常遇到插入表格的情况（如旅行规划），但是直接使用 Markdown 的语法来写表格并不方便，且 Markdown 的表格不支持单元格合并。这时候可以先在 Excle 等工具中写表格，再转换成 HTML 的 Table 插入 Markdown 文档。一番搜索发现现有的表格转 Table 工具有很多，但支持单元格合并的并没有，需要自己开发一个。
依赖
React&#x2F;ReactDOM
Ant Design
sheetjs(xlsx)

产出spreadsheet2table
]]></content>
      <tags>
        <tag>Tool</tag>
        <tag>Spreadsheet</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title>思考（吐槽）笔记</title>
    <url>/2020/10/think-note.html</url>
    <content><![CDATA[计划以后每月都把当月的一些思考整理记录下来，期望锻炼自己的思维能力，同时能够深入的思考一些问题。（由于是第一次，便把以前的一些想法也记录下来）
做前端的三个阶段：前端框架各有各的不同；前端框架没有什么不同；不要考虑前端框架
前端框架各自的实现不同
数据变化检测
React setState
Angular 脏检查
Vue 属性访问器（Object.defineProperty&#x2F;Proxy）


视图层写法（DSL）
Vue 模板
React JSX


由视图层写法的差异，导致 UI 表达能力的不同
由 DSL 的不同，Vue 在编译时有更多的优化空间


前端框架都是处理 State -&gt; UI 的工具
多关注价值（业务价值&#x2F;技术价值）

做前端重构最好的时间是 React 16.8 发布时，其次是现在
从 React 16.8 开始，React Hook 稳定版本正式发布。

很多事情其实就是拍脑袋决定的，区别是拍谁的脑袋这种情况是不是有做 A&#x2F;B test 的空间呢？
偏见的形成和距离有关&#x2F;了解的越多越可能产生偏见]]></content>
  </entry>
  <entry>
    <title>福建游记</title>
    <url>/2020/10/travel-note-of-fujian.html</url>
    <content><![CDATA[主要交通
  
    
      日期
      时间
      路线
      交通方式
      内容
      金额
      平台
    
  
  
    
      2020/10/13
      08:03-10:17
      杭州 - 厦门
      火车
      G1651 杭州东站 - 武夷山北站
      193.50
      飞猪（12306）
    
    
      2020/10/15
      12:40-15:55
      武夷山 - 厦门
      火车
      G1601 武夷山北站 - 厦门北站
      209.00
      飞猪（12306）
    
    
      2020/10/18
      14:40-16:15
      厦门 - 杭州
      飞机
      山东航空 SC8891 厦门高崎 - 杭州萧山
      487.00（437.00 + 50.00）
      马蜂窝
    
  


住宿
  
    
      时间
      城市
      酒店
      房型
      金额
      地点
      平台
    
  
  
    
      2020/10/13-2020/10/15
      福建武夷山
      武夷山旧街五号云起时客栈
      笙歌静思大床房（大窗）
      478.00
      三姑度假区幔亭峰路7号
      携程
    
    
      2020/10/15-2020/10/18
      福建厦门
      全季厦门中山路酒店
      双床房
      717.00
      思明南路291号（近镇海路地铁口2号出口）
      华住
    
  




活动
  
    
      时间
      时间
      地点
      内容
      路线
      分类
      消费金额
    
  
  
    
      2020/10/13
      上午
      08:03-10:17
      武夷山
      杭州东站
      火车 杭州东站 - 武夷山北站
      
      
      
    
    
      
      武夷山北站
      出租车 武夷山北站 - 半岛酒店
      
      
      20.00（原价50.00）
    
    
      中午
      
      云起时客栈
      入住
      
      
      
    
    
      
      食色餐厅
      午餐
      
      
      27.00
    
    
      下午
      
      天游峰
      步行从酒店到武夷宫，乘观光车到天游峰，游天游景区
      天游峰 - 桃源洞
      
      
    
    
      晚上
      19:30-?
      印象大红袍
      
      
      
      198
    
    
      2020/10/14
      
      
      
      
      
      
      
      
    
  

]]></content>
      <tags>
        <tag>福建</tag>
        <tag>旅行</tag>
        <tag>游记</tag>
        <tag>厦门</tag>
        <tag>武夷山</tag>
      </tags>
  </entry>
  <entry>
    <title>福建游见闻</title>
    <url>/2020/10/traveling-in-fujian.html</url>
    <content><![CDATA[上周去武夷山+厦门游玩了 6 日，日后会放出游记，本文仅记述在支付、门票、机票等角度的见闻。
支付本次行程中有很多场景只能使用微信支付，如武夷山的公交、船夫的讲解、小店购物等；其他微信、支付宝都支持的场景，也有存在支付宝收款码不明显的情况。
我们平时都用微信，支付宝是大城市人用的。
某船夫



门票看到其他同事的推荐，我选择使用美团来购买景点门票。所有景点的门票我都有在飞猪、美团两个平台进行比价，价格并无差异。
美团除了有购买门票的功能，在语音讲解这一块做的也很出色，我去的几个景点都有讲解，且内容详实。




机票开始我是在飞猪和携程两个平台比较机票的，在价格上并无明显差异，但是在下单过程中携程会默认选中一些附加收费内容。后来在马蜂窝搜同样的机票，竟便宜了 40+，实属意外。看来以后购机票可以多看几个平台。
酒店飞猪中酒店的选择没有携程丰富，且我选择的酒店在携程上更优惠。携程上可以直接在线联系到店家，这一点体验优于飞猪。
]]></content>
      <tags>
        <tag>福建</tag>
        <tag>旅行</tag>
        <tag>厦门</tag>
        <tag>武夷山</tag>
        <tag>OTA</tag>
        <tag>美团</tag>
        <tag>飞猪</tag>
        <tag>携程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查找 JAVA_HOME</title>
    <url>/2020/11/how-to-find-java-home.html</url>
    <content><![CDATA[
Linux&#x2F;macOSjava -XshowSettings:properties -version 2&gt;&amp;1 &gt; &#x2F;dev&#x2F;null | grep &#39;java.home&#39;
Windowsjava -XshowSettings:properties -version 2&gt;&amp;1 | findstr &quot;java.home&quot;

]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>投资思考</title>
    <url>/2020/11/investment-thinking.html</url>
    <content><![CDATA[
多想少动：多做思考，少做操作
每次操作前想清执行此操作的动机（如趋势、基本面、消息等等），确定后续操作（如止损点、止盈点、重要日期时刻）
清楚自己只能获得自己应得的部分收益，不为卖点不够高苦恼
不迷信权威
找到适合自己的方法
不做预测，从概率的角度提升成功率

]]></content>
      <categories>
        <category>Investment</category>
      </categories>
      <tags>
        <tag>Investment</tag>
        <tag>投资</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemJS: 如何注册全局脚本</title>
    <url>/2020/11/systemjs-how-to-register-global-script.html</url>
    <content><![CDATA[有如下可以正常运行的代码，功能很简单，加载 React, ReactDOM，然后在 app 中渲染 React 元素：
&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;
&lt;script
  src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;systemjs&#x2F;6.7.1&#x2F;system.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script&gt;
  (async () &#x3D;&gt; &#123;
    const React &#x3D; await System.import(
      &quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;react&#x2F;17.0.1&#x2F;umd&#x2F;react.development.js&quot;
    );
    const ReactDOM &#x3D; await System.import(
      &quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;react-dom&#x2F;17.0.1&#x2F;umd&#x2F;react-dom.development.min.js&quot;
    );

    const &#123; createElement: h &#125; &#x3D; React;
    const container &#x3D; document.getElementById(&quot;app&quot;);

    ReactDOM.render(h(&quot;p&quot;, &#123;&#125;, &quot;Hello world.&quot;), container);
  &#125;)();
&lt;&#x2F;script&gt;

一切看上去很正常，ちょっと待って，引入的两个模块都是 UMD 的，为什么 SystemJS 可以正常注册模块呢？



从上图我们可以看出在 React 模块初始化时，exports, module, define 都是不存在的，React 直接被添加到了全局对象 window 上。
通过断点，我找到了这段代码（剔除其中无关代码）：
&#x2F;*
 * SystemJS global script loading support
 * Extra for the s.js build only
 * (Included by default in system.js build)
 *&#x2F;
(function (global) &#123;
  var systemJSPrototype &#x3D; global.System.constructor.prototype;

  &#x2F;&#x2F; safari unpredictably lists some new globals first or second in object order
  var firstGlobalProp, secondGlobalProp, lastGlobalProp;
  function getGlobalProp() &#123;
    var cnt &#x3D; 0;
    var lastProp;
    for (var p in global) &#123;
      &#x2F;&#x2F; do not check frames cause it could be removed during import
      if (shouldSkipProperty(p)) continue;
      if (
        (cnt &#x3D;&#x3D;&#x3D; 0 &amp;&amp; p !&#x3D;&#x3D; firstGlobalProp) ||
        (cnt &#x3D;&#x3D;&#x3D; 1 &amp;&amp; p !&#x3D;&#x3D; secondGlobalProp)
      )
        return p;
      cnt++;
      lastProp &#x3D; p;
    &#125;
    if (lastProp !&#x3D;&#x3D; lastGlobalProp) return lastProp;
  &#125;

  function noteGlobalProps() &#123;
    &#x2F;&#x2F; alternatively Object.keys(global).pop()
    &#x2F;&#x2F; but this may be faster (pending benchmarks)
    firstGlobalProp &#x3D; secondGlobalProp &#x3D; undefined;
    for (var p in global) &#123;
      &#x2F;&#x2F; do not check frames cause it could be removed during import
      if (shouldSkipProperty(p)) continue;
      if (!firstGlobalProp) firstGlobalProp &#x3D; p;
      else if (!secondGlobalProp) secondGlobalProp &#x3D; p;
      lastGlobalProp &#x3D; p;
    &#125;
    return lastGlobalProp;
  &#125;

  var impt &#x3D; systemJSPrototype.import;
  systemJSPrototype.import &#x3D; function (id, parentUrl) &#123;
    noteGlobalProps();
    return impt.call(this, id, parentUrl);
  &#125;;

  &#x2F;&#x2F; balabala

  var isIE11 &#x3D;
    typeof navigator !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;
    navigator.userAgent.indexOf(&quot;Trident&quot;) !&#x3D;&#x3D; -1;

  function shouldSkipProperty(p) &#123;
    return (
      !global.hasOwnProperty(p) ||
      (!isNaN(p) &amp;&amp; p &lt; global.length) ||
      (isIE11 &amp;&amp;
        global[p] &amp;&amp;
        typeof window !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;
        global[p].parent &#x3D;&#x3D;&#x3D; window)
    );
  &#125;
&#125;)(typeof self !&#x3D;&#x3D; &quot;undefined&quot; ? self : global);

可以看到，每次 SystemJS 在 import 新的模块前，会调用 noteGlobalProps 检查当前全局的属性（亦可使用 Object.keys），记录下最后一条属性。当模块加载完成后，再调用 getGlobalProp 获得当前全局对象中的最后一条属性，若此属性和加载前的得到的最后一条属性不同，则认为此属性是新加载的模块。需要注意的 Safari 有可能将新的属性放在第一或第二位，所以要特殊处理。
综上，我们可以知晓， SystemJS 是通过检查全局对象中新增的属性来注册全局的脚本的。
那么就有了一个新的问题，如果我们在模块加载过程中不断的向全局对象新增属性，是否会影响模块的注册呢？

通过在 getGlobalProp 断点，观察调用栈我们可以发现在 JavaScript 脚本 load 完成后，从 getRegister 到 getGlobalProp 的过程都是同步的 Task，所以模块加载过程中动态向全局对象增加属性不会影响模块的注册。

In depth: Microtasks and the JavaScript runtime environment

]]></content>
      <tags>
        <tag>SystemJS</tag>
        <tag>模块加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>常见扩展方法实现</title>
    <url>/2020/12/common-extension-method-implementation.html</url>
    <content><![CDATA[拦截器示例：axios实现&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;axios&#x2F;axios&#x2F;blob&#x2F;master&#x2F;lib&#x2F;core&#x2F;InterceptorManager.js
function InterceptorManager() &#123;
  this.handlers &#x3D; [];
&#125;

InterceptorManager.prototype.use &#x3D; function use(fulfilled, rejected) &#123;
  this.handlers.push(&#123;
    fulfilled: fulfilled,
    rejected: rejected,
  &#125;);
  return this.handlers.length - 1;
&#125;;

InterceptorManager.prototype.eject &#x3D; function eject(id) &#123;
  if (this.handlers[id]) &#123;
    this.handlers[id] &#x3D; null;
  &#125;
&#125;;

InterceptorManager.prototype.forEach &#x3D; function forEach(fn) &#123;
  utils.forEach(this.handlers, function forEachHandler(h) &#123;
    if (h !&#x3D;&#x3D; null) &#123;
      fn(h);
    &#125;
  &#125;);
&#125;;

&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;axios&#x2F;axios&#x2F;blob&#x2F;master&#x2F;lib&#x2F;core&#x2F;Axios.js
function Axios(instanceConfig) &#123;
  this.interceptors &#x3D; &#123;
    request: new InterceptorManager(),
    response: new InterceptorManager(),
  &#125;;
&#125;

Axios.prototype.request &#x3D; function request(config) &#123;
  &#x2F;&#x2F; Hook up interceptors middleware
  var chain &#x3D; [dispatchRequest, undefined];
  var promise &#x3D; Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(
    interceptor
  ) &#123;
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  &#125;);

  this.interceptors.response.forEach(function pushResponseInterceptors(
    interceptor
  ) &#123;
    chain.push(interceptor.fulfilled, interceptor.rejected);
  &#125;);

  while (chain.length) &#123;
    promise &#x3D; promise.then(chain.shift(), chain.shift());
  &#125;

  return promise;
&#125;;

拦截器的注册：在 InterceptorManager 实例中使用一个数组储存拦截器函数，use 拦截器时会将 handler 插入数组，返回插入的位置，以备 eject 时使用。
拦截器的调用：Axios 的实例会为 request 和 response 生成两个独立的 InterceptorManager。发起请求时，会生成一个 chain 的队列，将发起请求的 handler 放入其中，将 request 的拦截器插入队列前，将 response 的拦截器插入队列后，通过 Promise 链式调用的方式使这些 handler 可以依次被执行。


中间件示例：koa&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;koajs&#x2F;koa&#x2F;blob&#x2F;master&#x2F;lib&#x2F;application.js
class Application extends Emitter &#123;
  constructor(options) &#123;
    super();
    this.middleware &#x3D; [];
  &#125;

  &#x2F;**
   * Use the given middleware &#96;fn&#96;.
   *
   * Old-style middleware will be converted.
   *
   * @param &#123;Function&#125; fn
   * @return &#123;Application&#125; self
   * @api public
   *&#x2F;
  use(fn) &#123;
    if (typeof fn !&#x3D;&#x3D; &quot;function&quot;)
      throw new TypeError(&quot;middleware must be a function!&quot;);
    debug(&quot;use %s&quot;, fn._name || fn.name || &quot;-&quot;);
    this.middleware.push(fn);
    return this;
  &#125;

  &#x2F;**
   * Return a request handler callback
   * for node&#39;s native http server.
   *
   * @return &#123;Function&#125;
   * @api public
   *&#x2F;
  callback() &#123;
    const fn &#x3D; compose(this.middleware);

    if (!this.listenerCount(&quot;error&quot;)) this.on(&quot;error&quot;, this.onerror);

    const handleRequest &#x3D; (req, res) &#x3D;&gt; &#123;
      const ctx &#x3D; this.createContext(req, res);
      return this.handleRequest(ctx, fn);
    &#125;;

    return handleRequest;
  &#125;

  &#x2F;**
   * Handle request in callback.
   *
   * @api private
   *&#x2F;
  handleRequest(ctx, fnMiddleware) &#123;
    const res &#x3D; ctx.res;
    res.statusCode &#x3D; 404;
    const onerror &#x3D; (err) &#x3D;&gt; ctx.onerror(err);
    const handleResponse &#x3D; () &#x3D;&gt; respond(ctx);
    onFinished(res, onerror);
    return fnMiddleware(ctx).then(handleResponse).catch(onerror);
  &#125;
&#125;

&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;koajs&#x2F;compose&#x2F;blob&#x2F;master&#x2F;index.js
&#x2F;**
 * Compose &#96;middleware&#96; returning
 * a fully valid middleware comprised
 * of all those which are passed.
 *
 * @param &#123;Array&#125; middleware
 * @return &#123;Function&#125;
 * @api public
 *&#x2F;
function compose(middleware) &#123;
  if (!Array.isArray(middleware))
    throw new TypeError(&quot;Middleware stack must be an array!&quot;);
  for (const fn of middleware) &#123;
    if (typeof fn !&#x3D;&#x3D; &quot;function&quot;)
      throw new TypeError(&quot;Middleware must be composed of functions!&quot;);
  &#125;

  &#x2F;**
   * @param &#123;Object&#125; context
   * @return &#123;Promise&#125;
   * @api public
   *&#x2F;

  return function (context, next) &#123;
    &#x2F;&#x2F; last called middleware #
    let index &#x3D; -1;
    return dispatch(0);
    function dispatch(i) &#123;
      if (i &lt;&#x3D; index)
        return Promise.reject(new Error(&quot;next() called multiple times&quot;));
      index &#x3D; i;
      let fn &#x3D; middleware[i];
      if (i &#x3D;&#x3D;&#x3D; middleware.length) fn &#x3D; next;
      if (!fn) return Promise.resolve();
      try &#123;
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      &#125; catch (err) &#123;
        return Promise.reject(err);
      &#125;
    &#125;
  &#125;;
&#125;

Application 实例使用 middleware 数组存储所有 use 的中间件函数。这些中间件函数会被 compose 后作为 request 的 callback 函数被调用。
]]></content>
      <tags>
        <tag>设计</tag>
        <tag>扩展</tag>
        <tag>拦截器</tag>
        <tag>中间件</tag>
        <tag>interceptor</tag>
        <tag>middleware</tag>
      </tags>
  </entry>
  <entry>
    <title>同层渲染方案比较</title>
    <url>/2020/12/comparison-of-solution-for-same-layer-render.html</url>
    <content><![CDATA[定义同层渲染：通过一定技术把原生组件直接渲染在 WebView 层级中，原生组件直接挂载在 WebView 节点。
解决什么问题
原生组件层级问题

微信小程序iOS原理iOS 中，当在一个 DOM 节点设置 CSS 属性：
overflow: scroll;
-webkit-overflow-scrolling: touch;

时，WKWebView 会为其生成一个 WKChildScrollView，与 DOM 节点存在映射关系，这是一个 UIScrollView 的子类，WebView 里的滚动是由原生的滚动组件来承载的。


实现
创建能够生成 WKChildScrollView 的 DOM 节点
通知客户端找到 WKChildScrollView 组件
将原生组件挂载到 WKChildScrollView 下

Android原理Chromium 支持 WebPlugin 机制，可以用 WebPlugin 解析和描述 embed 标签。
&lt;embed id&#x3D;&quot;web-plugin&quot; type&#x3D;&quot;plugin&#x2F;video&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot; &#x2F;&gt;

实现
创建 embed DOM 节点并指定组件类型
Chromium 创建 WebPlugin 实例，生成一个 RenderLayer
客户端初始化对应的原生组件
将原生组件绘制到 RenderLayer 所绑定的 SurfaceTexture 上
通知 Chromium 内核渲染 RenderLayer
Chromium 渲染 embed 节点并上屏

参考
小程序同层渲染原理剖析
The Chromium Projects - Plugin Architecture

]]></content>
      <tags>
        <tag>跨端</tag>
        <tag>Hybrid App</tag>
        <tag>WebView</tag>
        <tag>同层渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 镜像</title>
    <url>/2020/12/gradle-mirror.html</url>
    <content><![CDATA[腾讯软件源 Gradle - https://mirrors.cloud.tencent.com/gradle/
]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>镜像</tag>
        <tag>mirros</tag>
      </tags>
  </entry>
  <entry>
    <title>树形结构的拆分及应用</title>
    <url>/2020/12/splitting-and-application-of-tree-struct.html</url>
    <content><![CDATA[背景在之前的介绍小程序性能优化的文章中曾提到一种使用 rich-text 来替代 web-view 展示 Web 页面的方法，由于实际操作中，源 DOM 树可能会非常复杂，导致生成的 node 树很庞大，不易拆分，直接执行 setData 会造成页面卡死，所以需要有能够分段拆分树型结构的方案。这种方案应该满足我们的两点需求：

能够被分批读取生成 node 树
每段大小可以控制

简单设计由需求 1，拆分的结果需要可以被分批读取，我们可以做如下设计：
interface Node &#123;
  children?: Node[];
&#125;

interface Fragment &#123;
  path: number[];
  nodes: Node[];
&#125;

const splitTree &#x3D; (tree: Node): Fragment[] &#x3D;&gt; &#123;&#125;;

const renderFragments &#x3D; (frags: Fragment[]): void &#x3D;&gt; &#123;&#125;;

树的拆分To be continued…
]]></content>
      <tags>
        <tag>小程序</tag>
        <tag>树</tag>
        <tag>前端</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Flutter 中使用服务定位器管理路由</title>
    <url>/2021/01/use-service-locator-to-manage-route-in-flutter.html</url>
    <content><![CDATA[问题在 Flutter 中进行页面跳转需要访问到当前的 BuildContext 及目标页面的 Widget，不利于代码的组织管理。
onPressed: () &#123;
  Navigator.push(
    context,
    MaterialPageRoute(builder: (context) &#x3D;&gt; SecondRoute()),
  );
&#125;

服务定位器（Service Locator）The service locator pattern is a design pattern used in software development to encapsulate the processes involved in obtaining a service with a strong abstraction layer. This pattern uses a central registry known as the “service locator”, which on request returns the information necessary to perform a certain task. Proponents of the pattern say the approach simplifies component-based applications where all dependencies are cleanly listed at the beginning of the whole application design, consequently making traditional dependency injection a more complex way of connecting objects. Critics of the pattern argue that it is an anti-pattern which obscures dependencies and makes software harder to test.
Wikipedia - Service locator pattern

简单来说服务定位器模式可以将获得服务的过程封装在服务定位器中，应用程序的代码不需要管理维护服务的大量依赖，使应用程序的结构得到良好的分离。


应用创建 NavigationService首先创建 NavigationService 处理页面的跳转，它包含两个方法：navigateTo、 goBack 分别负责页面的跳转和返回。
navigatorKey 是用来创建 Navigator 的 Key，通过它可以直接得到 Navigator 而不需要使用 Navigator.of 从 BuildContext 中获取 Navigator。
class NavigationService &#123;
  final GlobalKey&lt;NavigatorState&gt; navigatorKey &#x3D;
      new GlobalKey&lt;NavigatorState&gt;();

  Future&lt;dynamic&gt; navigateTo(String routeName, &#123;dynamic arguments&#125;) &#123;
    return navigatorKey.currentState!
        .pushNamed(routeName, arguments: arguments);
  &#125;

  void goBack() &#123;
    navigatorKey.currentState!.pop();
  &#125;
&#125;

注册 locator在 get_it 的 setup 中注册 NavigationService。
GetIt locator &#x3D; GetIt.instance;

void setupLocator() &#123;
  locator.registerLazySingleton(() &#x3D;&gt; NavigationService());
&#125;

routes 生成在 router.dart 中创建路由生成函数。页面参数的可以通过 RouteSettings 来传递。
const String HomePageRoute &#x3D; &#39;&#x2F;&#39;;

const String LoginPageRoute &#x3D; &#39;&#x2F;login&#39;;

const String WebViewPageRoute &#x3D; &#39;&#x2F;web_view&#39;;

Route&lt;dynamic&gt; generateRoute(RouteSettings settings) &#123;
  switch (settings.name) &#123;
    case HomePageRoute:
      return MaterialPageRoute(builder: (context) &#x3D;&gt; HomePage(title: &#39;Home&#39;));
    case LoginPageRoute:
      return MaterialPageRoute(builder: (context) &#x3D;&gt; LoginPage(title: &#39;Login&#39;));
    case WebViewPageRoute:
      var args &#x3D; settings.arguments! as Map&lt;String, dynamic&gt;;
      var url &#x3D; args[&#39;url&#39;] as String;
      var title &#x3D; args[&#39;title&#39;] as String;
      return MaterialPageRoute(
          builder: (context) &#x3D;&gt; WebViewPage(
                url: url,
                title: title,
              ));
    default:
      return MaterialPageRoute(builder: (context) &#x3D;&gt; HomePage(title: &#39;Home&#39;));
  &#125;
&#125;

在 MaterialApp 上定义路由import &#39;package:flutter&#x2F;material.dart&#39;;
import &#39;services&#x2F;navigation_service.dart&#39;;
import &#39;router.dart&#39; as router;
import &#39;get_it.dart&#39;;

void main() &#123;
  setupLocator();

  runApp(MyApp());
&#125;

class MyApp extends StatelessWidget &#123;
  @override
  Widget build(BuildContext context) &#123;
    return MaterialApp(
      navigatorKey: locator&lt;NavigationService&gt;().navigatorKey,
      onGenerateRoute: router.generateRoute,
      initialRoute: router.HomePageRoute
    );
  &#125;
&#125;

应用中调用完成上述操作后，我们便可以在应用中的任意位置通过 locator 访问 NavigationService 来进行页面跳转：
class _HomePageState extends State&lt;HomePage&gt; &#123;
  final NavigationService _navigationService &#x3D; locator&lt;NavigationService&gt;();

  _onPressed () &#123;
    _navigationService.navigateTo(router.LoginPageRoute);
  &#125;
&#125;

此时页面跳转仅需要访问到 locator、NavigationService 和目标页路由的 name。
参考
Wikipedia - Service locator pattern
pub.dev - get_it
Flutter - Navigate with named routes

]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>get_it</tag>
        <tag>路由</tag>
        <tag>服务定位器</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Darktable 安装中文语言</title>
    <url>/2021/09/install-chinese-lang-for-darktable.html</url>
    <content><![CDATA[下载中文语言文件 https://raw.githubusercontent.com/darktable-org/darktable/master/po/zh_CN.po
yay -S poedit
msgfmt zh_CN.po -o darktable.mo
sudo chown root:root darktable.mo
sudo mv darktable.mo &#x2F;usr&#x2F;share&#x2F;locale&#x2F;zh_CN&#x2F;LC_MESSAGES&#x2F;darktable.mo
]]></content>
      <categories>
        <category>Tip</category>
      </categories>
      <tags>
        <tag>Darktable</tag>
        <tag>locale</tag>
      </tags>
  </entry>
  <entry>
    <title>FlatList: 从一个聊天消息列表谈起</title>
    <url>/2017/11/flatlist-start-from-a-chat-message-list.html</url>
    <content><![CDATA[缘起昨天看到了 Android 上 Telegram 消息列表的动效，觉得比较有趣，便打算试着用 ReactNative 模仿一下。
PS：视频是从 macOS 端录制的，但是效果是一致的。

可以看到列表可视区域内最下面一条消息的用户的头像会随着列表的滚动而上下移动位置。


组件结构外层容器我们只关注中间的消息列表，所以头部和输入栏用 Placeholder 替代。列表使用 ReactNative 最新引入的 FlatList。

MessageItem每一条消息分为左右两个部分，左侧是头像区域，头像图片在这里上下移动，右侧是消息气泡。

实现先来设计消息项的数据结构，这里我使用 faker 来生成伪数据。
&#x2F;&#x2F; util.js
import faker from &#39;faker&#39;;
import _ from &#39;lodash&#39;;

export const generateMsg &#x3D; () &#x3D;&gt; &#123;
  const id &#x3D; faker.random.uuid();
  const avatar &#x3D; faker.internet.avatar();
  const author &#x3D; faker.internet.userName();
  const content &#x3D; faker.lorem[_.sample([&#39;sentence&#39;, &#39;sentences&#39;, &#39;word&#39;, &#39;words&#39;])]();
  const date &#x3D; faker.date.past();

  const msg &#x3D; &#123;
    id,
    avatar,
    author,
    content,
    date,
  &#125;;

  return msg;
&#125;

有了消息项的数据结构，我们就可以实现 MessageItem 组件。
MessageItem 分两部分：Avatar、Bubble：
&#x2F;&#x2F; Avatar.js

import React from &#39;react&#39;;
import &#123; View, Image, StyleSheet, Platform &#125; from &#39;react-native&#39;;
import pure from &#39;recompose&#x2F;pure&#39;;

const Avatar &#x3D; pure((props) &#x3D;&gt; &#123;
  const &#123; avatar, style, _props &#125; &#x3D; props;

  return (
    &lt;View style&#x3D;&#123;[styles.container, style]&#125; &#123;..._props&#125;&gt;
      &lt;Image style&#x3D;&#123;styles.avatar&#125;
        source&#x3D;&#123;&#123; uri: avatar &#125;&#125;
        resizeMode&#x3D;&quot;contain&quot; &#x2F;&gt;
    &lt;&#x2F;View&gt;
  );
&#125;);

const styles &#x3D; StyleSheet.create(&#123;
  container: &#123;
    width: 50,
    height: 50,
    position: &#39;absolute&#39;,
    bottom: 0,
    left: 0,
  &#125;,
  avatar: &#123;
    width: 50,
    height: 50,
    backgroundColor: &#39;transparent&#39;,
    overflow: &#39;hidden&#39;,
    ...Platform.select(&#123;
      ios: &#123;
        borderRadius: 50 &#x2F; 2,
      &#125;,
      android: &#123;
        borderRadius: 50,
      &#125;
    &#125;),
  &#125;
&#125;);

export default Avatar;

&#x2F;&#x2F; Bubble.js

import React from &#39;react&#39;;
import &#123; View, Text, StyleSheet &#125; from &#39;react-native&#39;;
import pure from &#39;recompose&#x2F;pure&#39;;
import moment from &#39;moment&#39;;

const Bubble &#x3D; pure((props) &#x3D;&gt; &#123;
  const &#123; content, author, date &#125; &#x3D; props;

  const time &#x3D; moment(date).format(&#39;h:mm A&#39;);

  return (
    &lt;View style&#x3D;&#123;styles.container&#125;&gt;
      &lt;View style&#x3D;&#123;styles.bubble&#125;&gt;
        &lt;Text style&#x3D;&#123;styles.author&#125;&gt;&#123;author&#125;&lt;&#x2F;Text&gt;
        &lt;Text style&#x3D;&#123;styles.content&#125;&gt;&#123;content&#125;&lt;&#x2F;Text&gt;
        &lt;Text style&#x3D;&#123;styles.time&#125;&gt;&#123;time&#125;&lt;&#x2F;Text&gt;
      &lt;&#x2F;View&gt;
    &lt;&#x2F;View&gt;
  );
&#125;);

const styles &#x3D; StyleSheet.create(&#123;
  container: &#123;
    display: &#39;flex&#39;,
    flexWrap: &#39;wrap&#39;,
    flexDirection: &#39;row&#39;,
  &#125;,
  bubble: &#123;
    backgroundColor: &#39;#fff&#39;,
    borderColor: &#39;#ccc&#39;,
    borderWidth: StyleSheet.hairlineWidth,
    padding: 10,
    borderRadius: 6,
  &#125;,
  author: &#123;
    color: &#39;blue&#39;,
    fontSize: 12,
  &#125;,
  content: &#123;
    color: &#39;#000&#39;,
    fontSize: 18,
  &#125;,
  time: &#123;
    textAlign: &#39;right&#39;,
    color: &#39;#bababa&#39;,
    fontSize: 12,
  &#125;
&#125;);

export default Bubble;

合二为一：
&#x2F;&#x2F; MessageItem.js

import React from &#39;react&#39;;
import &#123; View, StyleSheet &#125; from &#39;react-native&#39;;
import pure from &#39;recompose&#x2F;pure&#39;;

import Avatar from &#39;.&#x2F;Avatar&#39;;
import Bubble from &#39;.&#x2F;Bubble&#39;;

class MessageItem extends React.Component &#123;
  render() &#123;
    const &#123; msg &#125; &#x3D; this.props;

    const &#123; avatar, content, author, date &#125; &#x3D; msg;

    return (
      &lt;View style&#x3D;&#123;styles.container&#125;&gt;
        &lt;View style&#x3D;&#123;styles.avatarWrapper&#125;&gt;
          &lt;Avatar avatar&#x3D;&#123;avatar&#125; &#x2F;&gt;
        &lt;&#x2F;View&gt;
        &lt;View style&#x3D;&#123;styles.bubbleWrapper&#125;&gt;
          &lt;Bubble author&#x3D;&#123;author&#125; date&#x3D;&#123;date&#125; content&#x3D;&#123;content&#125; &#x2F;&gt;
        &lt;&#x2F;View&gt;
      &lt;&#x2F;View&gt;
    );
  &#125;
&#125;

const styles &#x3D; StyleSheet.create(&#123;
  container: &#123;
    display: &#39;flex&#39;,
    flexDirection: &#39;row&#39;,
    alignItems: &#39;stretch&#39;,
    marginVertical: 4,
    marginHorizontal: 6,
  &#125;,
  avatarWrapper: &#123;
    width: 50,
    display: &#39;flex&#39;,
    flexDirection: &#39;column&#39;,
    justifyContent: &#39;flex-end&#39;,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: &#39;red&#39;,
  &#125;,
  bubbleWrapper: &#123;
    marginLeft: 6,
    flex: 1,
  &#125;
&#125;);

export default MessageItem;

需要注意到的是尽可能使用纯函数组件来提升性能。
然后可以实现外部容器了。
Placeholder 比较简单，仅起到占位的作用。
&#x2F;&#x2F; Placeholder.js

import React from &#39;react&#39;;
import &#123; StyleSheet, Text, View &#125; from &#39;react-native&#39;;

const Placeholder &#x3D; (props) &#x3D;&gt; &#123;
  return (
    &lt;View style&#x3D;&#123;[styles.container, props.style]&#125;&gt;
      &lt;Text style&#x3D;&#123;styles.text&#125;&gt;Placeholder&lt;&#x2F;Text&gt;
    &lt;&#x2F;View&gt;
  )
&#125;;

const styles &#x3D; StyleSheet.create(&#123;
  container: &#123;
    height: 60,
    backgroundColor: &#39;grey&#39;,
    display: &#39;flex&#39;,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
  &#125;,
  text: &#123;
    color: &#39;#000&#39;,
    fontSize: 20
  &#125;
&#125;);

export default Placeholder;

&#x2F;&#x2F; App.js
import React from &#39;react&#39;;
import &#123; StyleSheet, Text, View, FlatList, ScrollView &#125; from &#39;react-native&#39;;
import _ from &#39;lodash&#39;;

import &#123; generateMsg &#125; from &#39;.&#x2F;util&#39;;

import Placeholder from &#39;.&#x2F;Placeholder&#39;;
import MessageItem from &#39;.&#x2F;MessageItem&#39;;

export default class App extends React.Component &#123;
  state &#x3D; &#123;
    list: (function () &#123;
      const msgList &#x3D; [];
      for (let i &#x3D; 0; i &lt; 500; i++) &#123;
        msgList.push(generateMsg());
      &#125;
      return msgList;
    &#125;())
  &#125;;

  itemRefs &#x3D; [];
  flatListBottom &#x3D; 0;
  bottomItemIndex &#x3D; -1;

  _keyExtractor &#x3D; (item, index) &#x3D;&gt; item.id;

  _renderItem &#x3D; (&#123; item, index &#125;) &#x3D;&gt; &#123;
    return (
      &lt;MessageItem
        msg&#x3D;&#123;item&#125;
        ref&#x3D;&#123;item &#x3D;&gt; this.itemRefs[index] &#x3D; item&#125;
      &#x2F;&gt;
    );
  &#125;

  _placeItemAvatarWithRef &#x3D; (&#123; listBottom, itemHeight, itemTop, ref &#125;) &#x3D;&gt; &#123;
    const itemBottom &#x3D; itemTop + itemHeight;
    const AVATAR_HEIGHT &#x3D; 50;

    let offset;
    if ((listBottom - itemTop) &lt; AVATAR_HEIGHT) &#123;
      offset &#x3D; itemHeight - AVATAR_HEIGHT;
    &#125; else &#123;
      offset &#x3D; itemBottom - listBottom;
      if (offset &lt; 0) offset &#x3D; 0;
    &#125;
    ref._setAvatarBottom(offset);
  &#125;;

  _placeItemAvatarAtIndex &#x3D; (index) &#x3D;&gt; &#123;
    const ref &#x3D; this.itemRefs[index];

    if (ref &amp;&amp; typeof ref._measure &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
      ref._measure((x, y, width, height, pageX, pageY) &#x3D;&gt; &#123;
        this._placeItemAvatarWithRef(&#123;
          listBottom: this.flatListBottom,
          itemHeight: height,
          itemTop: pageY,
          ref: ref
        &#125;);
      &#125;);
    &#125;
  &#125;;

  _onScroll &#x3D; (event) &#x3D;&gt; &#123;
    const &#123; nativeEvent &#125; &#x3D; event;
    const bottomItemIndex &#x3D; this.bottomItemIndex;
    this._placeItemAvatarAtIndex(bottomItemIndex);
  &#125;;

  _onViewableItemsChanged &#x3D; (&#123; viewableItems, changed &#125;) &#x3D;&gt; &#123;
    if (viewableItems.length &#x3D;&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 列表滚动过快时 viewableItems 可能为空
      this.bottomItemIndex &#x3D; -1;
    &#125; else &#123;
      const bottomItemIndex &#x3D; viewableItems[viewableItems.length - 1].index;
      this.bottomItemIndex &#x3D; bottomItemIndex;
      this._placeItemAvatarAtIndex(bottomItemIndex);
    &#125;
  &#125;;

  _handleFlatListLayout &#x3D; (event) &#x3D;&gt; &#123;
    const &#123; nativeEvent &#125; &#x3D; event;
    const &#123; layout &#125; &#x3D; nativeEvent;
    const &#123; y, height &#125; &#x3D; layout;
    this.flatListBottom &#x3D; y + height;
  &#125;;

  render() &#123;
    const &#123; list &#125; &#x3D; this.state;

    return (
      &lt;View style&#x3D;&#123;styles.container&#125;&gt;
        &lt;Placeholder &#x2F;&gt;
        &lt;FlatList
          keyExtractor&#x3D;&#123;this._keyExtractor&#125;
          onLayout&#x3D;&#123;this._handleFlatListLayout&#125;
          data&#x3D;&#123;list&#125;
          onScroll&#x3D;&#123;this._onScroll&#125;
          onViewableItemsChanged&#x3D;&#123;this._onViewableItemsChanged&#125;
          renderItem&#x3D;&#123;this._renderItem&#125; &#x2F;&gt;
        &lt;Placeholder &#x2F;&gt;
      &lt;&#x2F;View&gt;
    );
  &#125;
&#125;

const styles &#x3D; StyleSheet.create(&#123;
  container: &#123;
    flex: 1,
    backgroundColor: &#39;#f2f3f8&#39;,
  &#125;
&#125;);

FlatList 一些接口的实现需要参考源代码。
由于需要随着列表的滚动而改变列表可视区域的底部头像图片的位置，所以我们用 onViewableItemsChanged 来知晓可视区域最下面的条目的 index，在 onScroll 中做处理。
我们需要知道 FlatList 底边的位置，所以使用 onLayout 来获取并保存到 flatListBottom。
现在回到 MessageItem 来实现 _measure 和 _setAvatarBottom 方法。
&#x2F;&#x2F; Avatar.js
const Avatar &#x3D; pure((props) &#x3D;&gt; &#123;
  const &#123; avatar, style, avatarContainerRef, _props &#125; &#x3D; props;

  return (
    &lt;View ref&#x3D;&#123;avatarContainerRef&#125; style&#x3D;&#123;[styles.container, style]&#125; &#123;..._props&#125;&gt;
      &lt;Image style&#x3D;&#123;styles.avatar&#125;
        source&#x3D;&#123;&#123; uri: avatar &#125;&#125;
        resizeMode&#x3D;&quot;contain&quot; &#x2F;&gt;
    &lt;&#x2F;View&gt;
  );
&#125;);

&#x2F;&#x2F; MessageItem.js
class MessageItem extends React.Component &#123;
  _measure &#x3D; (cb) &#x3D;&gt; &#123;
    if (this.container) &#123;
      this.container.measure(cb);
    &#125;
  &#125;

  _setAvatarBottom &#x3D; (bottom) &#x3D;&gt; &#123;
    const ref &#x3D; this.avatarContainerRef;
    if (ref) &#123;
      ref.setNativeProps(&#123;
        bottom: bottom
      &#125;);
    &#125;
  &#125;

  shouldComponentUpdate(nextProps, nextState) &#123;
    if (nextProps.msg.id !&#x3D;&#x3D; this.props.msg.id) return true;
    if (nextState.avatarBottom !&#x3D;&#x3D; this.state.avatarBottom) return true;
    return false;
  &#125;

  render() &#123;
    const &#123; msg &#125; &#x3D; this.props;
    const &#123; avatarBottom &#125; &#x3D; this.state;

    const &#123; avatar, content, author, date &#125; &#x3D; msg;

    return (
      &lt;View
        renderToHardwareTextureAndroid&#x3D;&#123;true&#125;
        style&#x3D;&#123;styles.container&#125;
        ref&#x3D;&#123;view &#x3D;&gt; this.container &#x3D; view&#125; &gt;
        &lt;View style&#x3D;&#123;styles.avatarWrapper&#125;&gt;
          &lt;Avatar avatar&#x3D;&#123;avatar&#125;
            avatarContainerRef&#x3D;&#123;ref &#x3D;&gt; this.avatarContainerRef &#x3D; ref&#125;
          &#x2F;&gt;
        &lt;&#x2F;View&gt;
        &lt;View style&#x3D;&#123;styles.bubbleWrapper&#125;&gt;
          &lt;Bubble author&#x3D;&#123;author&#125; date&#x3D;&#123;date&#125; content&#x3D;&#123;content&#125; &#x2F;&gt;
        &lt;&#x2F;View&gt;
      &lt;&#x2F;View&gt;
    );
  &#125;
&#125;

修改元素的 bottom 值需要使用到 setNativeProps 来避免 setState 造成的额外开销。
这里我们实现了 shouldComponentUpdate 防止 MessageItem 组件不必要的更新。
基本大功告成了。
更进一步滚动列表的时候，会发现有些头像的位置不对。

分析原因，是由于 onScroll 并不能保证 ._setAvatarBottom(0); 在 MessageItem 完整显示时被触发。所以对于完整显示的 MessageItem 我们可以在 onViewableItemsChanged 中进行处理。
&#x2F;&#x2F; App.js

class App &#123;
  _resetItemAtIndexes &#x3D; (indexes) &#x3D;&gt; &#123;
    indexes.forEach(index &#x3D;&gt; &#123;
      const ref &#x3D; this.itemRefs[index];
      if (ref) &#123;
        ref._setAvatarBottom(0);
      &#125;
    &#125;);
  &#125;

  _onViewableItemsChanged &#x3D; (&#123; viewableItems, changed &#125;) &#x3D;&gt; &#123;
    if (viewableItems.length &#x3D;&#x3D;&#x3D; 0) &#123;
      this.bottomItemIndex &#x3D; -1;
    &#125; else &#123;
      const bottomItemIndex &#x3D; viewableItems[viewableItems.length - 1].index;
      this.bottomItemIndex &#x3D; bottomItemIndex;
      this._placeItemAvatarAtIndex(bottomItemIndex);
      this._resetItemAtIndexes(
        viewableItems.map(item &#x3D;&gt; item.index)
          .filter(index &#x3D;&gt; index !&#x3D;&#x3D; bottomItemIndex) &#x2F;&#x2F; 找出所有完整显示的项目
      );
    &#125;
  &#125;;
&#125;

现在我们再来看下效果，

似乎并不尽如人意，通过 bottom 来修改 avatar 的位置并不流畅。
看来还有优化空间。
在 _placeItemAvatarAtIndex 中，由于 _measure 是异步的操作，可能在 measure 执行完成后，已不需要对对应的元素进行处理，所以可以在这里加个判断。
_placeItemAvatarAtIndex &#x3D; (index) &#x3D;&gt; &#123;
  const ref &#x3D; this.itemRefs[index];

  if (ref &amp;&amp; typeof ref._measure &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
    this.currentMeasure &#x3D; index;
    ref._measure((x, y, width, height, pageX, pageY) &#x3D;&gt; &#123;
      console.log(index !&#x3D;&#x3D; this.currentMeasure);
      if (index !&#x3D;&#x3D; this.currentMeasure) return; &#x2F;&#x2F; 不需要执行后续操作，直接返回
      this._placeItemAvatarWithRef(&#123;
        listBottom: this.flatListBottom,
        itemHeight: height,
        itemTop: pageY,
        ref: ref
      &#125;);
    &#125;);
  &#125;
&#125;;

考虑生成一个悬浮的 Avatar 在滚动 FlatList 的时候，动态显示隐藏，这样应该会更流畅。
&#x2F;&#x2F; App.js

class App &#123;
  state &#x3D; &#123;
    list: (function () &#123;
      const msgList &#x3D; [];
      for (let i &#x3D; 0; i &lt; 500; i++) &#123;
        msgList.push(generateMsg());
      &#125;
      return msgList;
    &#125;()),
    currentFixedAvatarUri: &#39;&#39;,
    showFixedAvatar: false
  &#125;;

  itemRefs &#x3D; []; &#x2F;&#x2F; 保存列表中元素的 ref
  flatListBottom &#x3D; 0; &#x2F;&#x2F; 列表 layout 的 bottom 值
  bottomItemIndex &#x3D; -1;
  bottomItem &#x3D; null;
  currentMeasure &#x3D; -1; &#x2F;&#x2F; 当前 measure 的元素的 index

  _showFixedAvatar() &#123;
    this.setState(&#123;
      currentFixedAvatarUri: this.bottomItem.avatar
    &#125;);
  &#125;

  _hideFixedAvatar() &#123;
    this.setState(&#123;
      showFixedAvatar: false
    &#125;);
  &#125;

  _onLoadFixedAvatar &#x3D; (uri, index) &#x3D;&gt; &#123;
    &#x2F;&#x2F; 判断载入完成的是否是当前待处理的 avatar
    if (this.bottomItem.avatar &#x3D;&#x3D;&#x3D; uri) &#123;
      const ref &#x3D; this.itemRefs[index];
      if (ref) &#123;
        this.setState(&#123;
          showFixedAvatar: true,
        &#125;);
        ref._setAvatarVisibility(false);
      &#125;
    &#125;
  &#125;

  _placeItemAvatarWithRef &#x3D; (&#123; listBottom, itemHeight, itemTop, ref, index &#125;) &#x3D;&gt; &#123;
    const itemBottom &#x3D; itemTop + itemHeight;
    const AVATAR_HEIGHT &#x3D; 50;

    let offset;
    if ((listBottom - itemTop) &lt; AVATAR_HEIGHT) &#123;
      offset &#x3D; itemHeight - AVATAR_HEIGHT;

      ref._setAvatarVisibility(true);
      this._hideFixedAvatar();
    &#125; else &#123;
      offset &#x3D; itemBottom - listBottom;

      if (offset &gt; 0) &#123;
        this._showFixedAvatar();
      &#125; else &#123;
        ref._setAvatarVisibility(true);
        this._hideFixedAvatar();
      &#125;
    &#125;

    ref._setAvatarBottom(offset &gt; 0 ? offset : 0);
  &#125;;

  _resetItemAtIndexes &#x3D; (indexes) &#x3D;&gt; &#123;
    indexes.forEach(index &#x3D;&gt; &#123;
      const ref &#x3D; this.itemRefs[index];
      if (ref) &#123;
        ref._setAvatarBottom(0);
        ref._setAvatarVisibility(true);
      &#125;
    &#125;);
  &#125;

  _onViewableItemsChanged &#x3D; (&#123; viewableItems, changed &#125;) &#x3D;&gt; &#123;
    if (viewableItems.length &#x3D;&#x3D;&#x3D; 0) &#123;
      this.bottomItemIndex &#x3D; -1;
    &#125; else &#123;
      const lastViewableItem &#x3D; viewableItems[viewableItems.length - 1];
      this.bottomItem &#x3D; lastViewableItem.item; &#x2F;&#x2F; 记录当前底部元素
      const bottomItemIndex &#x3D; lastViewableItem.index;
      this.bottomItemIndex &#x3D; bottomItemIndex; &#x2F;&#x2F; 记录当前底部元素的索引
      this._placeItemAvatarAtIndex(bottomItemIndex);
      this._resetItemAtIndexes(
        viewableItems.map(item &#x3D;&gt; item.index)
          .filter(index &#x3D;&gt; index !&#x3D;&#x3D; bottomItemIndex)
      );
    &#125;
  &#125;;

  render() &#123;
    const &#123; list, currentFixedAvatarUri, showFixedAvatar &#125; &#x3D; this.state;

    return (
      &lt;View style&#x3D;&#123;styles.container&#125;&gt;
        &lt;Placeholder &#x2F;&gt;
        &lt;FlatList
          keyExtractor&#x3D;&#123;this._keyExtractor&#125;
          onLayout&#x3D;&#123;this._handleFlatListLayout&#125;
          data&#x3D;&#123;list&#125;
          onScroll&#x3D;&#123;this._onScroll&#125;
          onViewableItemsChanged&#x3D;&#123;this._onViewableItemsChanged&#125;
          renderItem&#x3D;&#123;this._renderItem&#125; &#x2F;&gt;
        &lt;Placeholder &#x2F;&gt;
        &lt;Avatar
          onLoad&#x3D;&#123;this._onLoadFixedAvatar.bind(this, currentFixedAvatarUri, this.bottomItemIndex)&#125;
          style&#x3D;&#123;[styles.fixedAvatar, showFixedAvatar ? &#123; opacity: 1 &#125; : &#123; opacity: 0 &#125;]&#125;
          avatar&#x3D;&#123;currentFixedAvatarUri&#125; &#x2F;&gt;
      &lt;&#x2F;View&gt;
    );
  &#125;
&#125;

const styles &#x3D; StyleSheet.create(&#123;
  container: &#123;
    flex: 1,
    backgroundColor: &#39;#f2f3f8&#39;,
  &#125;,
  fixedAvatar: &#123;
    bottom: 60 + OFFSET,
    left: 6,
  &#125;
&#125;);

&#x2F;&#x2F; MessageItem.js
class MessageItem &#123;
  _setAvatarVisibility &#x3D; (visible) &#x3D;&gt; &#123;
    const ref &#x3D; this.avatarContainerRef;
    if (ref) &#123;
      ref.setNativeProps(&#123;
        opacity: visible ? 1 : 0
      &#125;);
    &#125;
  &#125;
&#125;

效果：

注意点：

通过 opacity 属性控制元素的显示隐藏
监听 fixedAvatar 的 onLoad 事件，避免图片加载造成显示的抖动

]]></content>
      <tags>
        <tag>ReactNative</tag>
        <tag>React</tag>
        <tag>FlatList</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 Virtual DOM</title>
    <url>/2018/01/deep-into-virtual-dom.html</url>
    <content><![CDATA[想要深入了解 Virtual DOM，我们可以学习 snabbdom 这个库。Snabbdom 是一个专注简洁、模块化、高性能的虚拟 DOM 库。
用法如下：
var snabbdom &#x3D; require(&#39;snabbdom&#39;);
var patch &#x3D; snabbdom.init([ &#x2F;&#x2F; Init patch function with chosen modules
  require(&#39;snabbdom&#x2F;modules&#x2F;class&#39;).default, &#x2F;&#x2F; makes it easy to toggle classes
  require(&#39;snabbdom&#x2F;modules&#x2F;props&#39;).default, &#x2F;&#x2F; for setting properties on DOM elements
  require(&#39;snabbdom&#x2F;modules&#x2F;style&#39;).default, &#x2F;&#x2F; handles styling on elements with support for animations
  require(&#39;snabbdom&#x2F;modules&#x2F;eventlisteners&#39;).default, &#x2F;&#x2F; attaches event listeners
]);
var h &#x3D; require(&#39;snabbdom&#x2F;h&#39;).default; &#x2F;&#x2F; helper function for creating vnodes

var container &#x3D; document.getElementById(&#39;container&#39;);

var vnode &#x3D; h(&#39;div#container.two.classes&#39;, &#123;on: &#123;click: someFn&#125;&#125;, [
  h(&#39;span&#39;, &#123;style: &#123;fontWeight: &#39;bold&#39;&#125;&#125;, &#39;This is bold&#39;),
  &#39; and this is just normal text&#39;,
  h(&#39;a&#39;, &#123;props: &#123;href: &#39;&#x2F;foo&#39;&#125;&#125;, &#39;I\&#39;ll take you places!&#39;)
]);
&#x2F;&#x2F; Patch into empty DOM element – this modifies the DOM as a side effect
patch(container, vnode);

var newVnode &#x3D; h(&#39;div#container.two.classes&#39;, &#123;on: &#123;click: anotherEventHandler&#125;&#125;, [
  h(&#39;span&#39;, &#123;style: &#123;fontWeight: &#39;normal&#39;, fontStyle: &#39;italic&#39;&#125;&#125;, &#39;This is now italic type&#39;),
  &#39; and this is still just normal text&#39;,
  h(&#39;a&#39;, &#123;props: &#123;href: &#39;&#x2F;bar&#39;&#125;&#125;, &#39;I\&#39;ll take you places!&#39;)
]);
&#x2F;&#x2F; Second &#96;patch&#96; invocation
patch(vnode, newVnode); &#x2F;&#x2F; Snabbdom efficiently updates the old view to the new state

由于它仅有约 200 行源码容易阅读，支持 JSX，并且 Vue 的 patch.js 便是在它的基础上进行些许修改得来的，所以非常值得学习。


VNode 类Virtual DOM 的基础是 VNode 类。
&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;snabbdom&#x2F;snabbdom&#x2F;blob&#x2F;v0.7.1&#x2F;src&#x2F;vnode.ts

export type Key &#x3D; string | number;

export interface VNode &#123;
  sel: string | undefined;
  data: VNodeData | undefined;
  children: Array&lt;VNode | string&gt; | undefined;
  elm: Node | undefined;
  text: string | undefined;
  key: Key | undefined;
&#125;

export interface VNodeData &#123;
  props?: Props;
  attrs?: Attrs;
  class?: Classes;
  style?: VNodeStyle;
  dataset?: Dataset;
  on?: On;
  hero?: Hero;
  attachData?: AttachData;
  hook?: Hooks;
  key?: Key;
  ns?: string; &#x2F;&#x2F; for SVGs
  fn?: () &#x3D;&gt; VNode; &#x2F;&#x2F; for thunks
  args?: Array&lt;any&gt;; &#x2F;&#x2F; for thunks
  [key: string]: any; &#x2F;&#x2F; for any other 3rd party module
&#125;

export function vnode(sel: string | undefined,
                      data: any | undefined,
                      children: Array&lt;VNode | string&gt; | undefined,
                      text: string | undefined,
                      elm: Element | Text | undefined): VNode &#123;
  let key &#x3D; data &#x3D;&#x3D;&#x3D; undefined ? undefined : data.key;
  return &#123;sel: sel, data: data, children: children,
          text: text, elm: elm, key: key&#125;;
&#125;

可以看到 VNode 有这些属性：

sel: 选择器
data: VNode 承载的各种属性及方法
children: VNode 的子元素列表
elm: VNode 对应的 DOM 节点
text: VNode 文字节点的内容
key: VNode 在列表中 patch 时用到的标识，与 data.key 相同

h 生成 VNode 树&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;snabbdom&#x2F;snabbdom&#x2F;blob&#x2F;v0.7.1&#x2F;src&#x2F;h.ts

export type VNodes &#x3D; Array&lt;VNode&gt;;
export type VNodesSparse &#x3D; VNode | Array&lt;VNode | undefined | null&gt;;

export function h(sel: string): VNode;
export function h(sel: string, data: VNodeData): VNode;
export function h(sel: string, text: string): VNode;
export function h(sel: string, children: VNodesSparse): VNode;
export function h(sel: string, data: VNodeData, text: string): VNode;
export function h(sel: string, data: VNodeData, children: VNodesSparse): VNode;
export function h(sel: any, b?: any, c?: any): VNode &#123;
  var data: VNodeData &#x3D; &#123;&#125;, children: any, text: any, i: number;
  if (c !&#x3D;&#x3D; undefined) &#123;
    data &#x3D; b;
    if (is.array(c)) &#123; children &#x3D; c; &#125;
    else if (is.primitive(c)) &#123; text &#x3D; c; &#125;
    else if (c &amp;&amp; c.sel) &#123; children &#x3D; [c]; &#125;
  &#125; else if (b !&#x3D;&#x3D; undefined) &#123;
    if (is.array(b)) &#123; children &#x3D; b; &#125;
    else if (is.primitive(b)) &#123; text &#x3D; b; &#125;
    else if (b &amp;&amp; b.sel) &#123; children &#x3D; [b]; &#125;
    else &#123; data &#x3D; b; &#125;
  &#125;
  if (is.array(children)) &#123;
    for (i &#x3D; 0; i &lt; children.length; ++i) &#123;
      if (is.primitive(children[i])) children[i] &#x3D; vnode(undefined, undefined, undefined, children[i], undefined);
    &#125;
  &#125;
  if (
    sel[0] &#x3D;&#x3D;&#x3D; &#39;s&#39; &amp;&amp; sel[1] &#x3D;&#x3D;&#x3D; &#39;v&#39; &amp;&amp; sel[2] &#x3D;&#x3D;&#x3D; &#39;g&#39; &amp;&amp;
    (sel.length &#x3D;&#x3D;&#x3D; 3 || sel[3] &#x3D;&#x3D;&#x3D; &#39;.&#39; || sel[3] &#x3D;&#x3D;&#x3D; &#39;#&#39;)
  ) &#123;
    addNS(data, children, sel);
  &#125;
  return vnode(sel, data, children, text, undefined);
&#125;;
export default h;

h 函数可以用来生成单个 VNode 或是 VNode 树。需要主要的是对于 svg 元素的 VNode 需要添加 ns。


patch&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;snabbdom&#x2F;snabbdom&#x2F;blob&#x2F;v0.7.1&#x2F;src&#x2F;snabbdom.ts

export function init(modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) &#123;
  let i: number, j: number, cbs &#x3D; (&#123;&#125; as ModuleHooks);

  const api: DOMAPI &#x3D; domApi !&#x3D;&#x3D; undefined ? domApi : htmlDomApi;

  for (i &#x3D; 0; i &lt; hooks.length; ++i) &#123;
    cbs[hooks[i]] &#x3D; [];
    for (j &#x3D; 0; j &lt; modules.length; ++j) &#123;
      const hook &#x3D; modules[j][hooks[i]];
      if (hook !&#x3D;&#x3D; undefined) &#123;
        (cbs[hooks[i]] as Array&lt;any&gt;).push(hook);
      &#125;
    &#125;
  &#125;

  function emptyNodeAt(elm: Element) &#123;
    const id &#x3D; elm.id ? &#39;#&#39; + elm.id : &#39;&#39;;
    const c &#x3D; elm.className ? &#39;.&#39; + elm.className.split(&#39; &#39;).join(&#39;.&#39;) : &#39;&#39;;
    return vnode(api.tagName(elm).toLowerCase() + id + c, &#123;&#125;, [], undefined, elm);
  &#125;

  function createRmCb(childElm: Node, listeners: number) &#123;
    return function rmCb() &#123;
      if (--listeners &#x3D;&#x3D;&#x3D; 0) &#123;
        const parent &#x3D; api.parentNode(childElm);
        api.removeChild(parent, childElm);
      &#125;
    &#125;;
  &#125;

  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node &#123;
    let i: any, data &#x3D; vnode.data;
    if (data !&#x3D;&#x3D; undefined) &#123;
      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.init)) &#123;
        i(vnode);
        data &#x3D; vnode.data;
      &#125;
    &#125;
    let children &#x3D; vnode.children, sel &#x3D; vnode.sel;
    if (sel &#x3D;&#x3D;&#x3D; &#39;!&#39;) &#123;
      if (isUndef(vnode.text)) &#123;
        vnode.text &#x3D; &#39;&#39;;
      &#125;
      vnode.elm &#x3D; api.createComment(vnode.text as string);
    &#125; else if (sel !&#x3D;&#x3D; undefined) &#123;
      &#x2F;&#x2F; Parse selector
      const hashIdx &#x3D; sel.indexOf(&#39;#&#39;);
      const dotIdx &#x3D; sel.indexOf(&#39;.&#39;, hashIdx);
      const hash &#x3D; hashIdx &gt; 0 ? hashIdx : sel.length;
      const dot &#x3D; dotIdx &gt; 0 ? dotIdx : sel.length;
      const tag &#x3D; hashIdx !&#x3D;&#x3D; -1 || dotIdx !&#x3D;&#x3D; -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      const elm &#x3D; vnode.elm &#x3D; isDef(data) &amp;&amp; isDef(i &#x3D; (data as VNodeData).ns) ? api.createElementNS(i, tag)
                                                                               : api.createElement(tag);
      if (hash &lt; dot) elm.setAttribute(&#39;id&#39;, sel.slice(hash + 1, dot));
      if (dotIdx &gt; 0) elm.setAttribute(&#39;class&#39;, sel.slice(dot + 1).replace(&#x2F;\.&#x2F;g, &#39; &#39;));
      for (i &#x3D; 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      if (is.array(children)) &#123;
        for (i &#x3D; 0; i &lt; children.length; ++i) &#123;
          const ch &#x3D; children[i];
          if (ch !&#x3D; null) &#123;
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          &#125;
        &#125;
      &#125; else if (is.primitive(vnode.text)) &#123;
        api.appendChild(elm, api.createTextNode(vnode.text));
      &#125;
      i &#x3D; (vnode.data as VNodeData).hook; &#x2F;&#x2F; Reuse variable
      if (isDef(i)) &#123;
        if (i.create) i.create(emptyNode, vnode);
        if (i.insert) insertedVnodeQueue.push(vnode);
      &#125;
    &#125; else &#123;
      vnode.elm &#x3D; api.createTextNode(vnode.text as string);
    &#125;
    return vnode.elm;
  &#125;

  function addVnodes(parentElm: Node,
                     before: Node | null,
                     vnodes: Array&lt;VNode&gt;,
                     startIdx: number,
                     endIdx: number,
                     insertedVnodeQueue: VNodeQueue) &#123;
    for (; startIdx &lt;&#x3D; endIdx; ++startIdx) &#123;
      const ch &#x3D; vnodes[startIdx];
      if (ch !&#x3D; null) &#123;
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      &#125;
    &#125;
  &#125;

  function invokeDestroyHook(vnode: VNode) &#123;
    let i: any, j: number, data &#x3D; vnode.data;
    if (data !&#x3D;&#x3D; undefined) &#123;
      if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.destroy)) i(vnode);
      for (i &#x3D; 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (vnode.children !&#x3D;&#x3D; undefined) &#123;
        for (j &#x3D; 0; j &lt; vnode.children.length; ++j) &#123;
          i &#x3D; vnode.children[j];
          if (i !&#x3D; null &amp;&amp; typeof i !&#x3D;&#x3D; &quot;string&quot;) &#123;
            invokeDestroyHook(i);
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;

  function removeVnodes(parentElm: Node,
                        vnodes: Array&lt;VNode&gt;,
                        startIdx: number,
                        endIdx: number): void &#123;
    for (; startIdx &lt;&#x3D; endIdx; ++startIdx) &#123;
      let i: any, listeners: number, rm: () &#x3D;&gt; void, ch &#x3D; vnodes[startIdx];
      if (ch !&#x3D; null) &#123;
        if (isDef(ch.sel)) &#123;
          invokeDestroyHook(ch);
          listeners &#x3D; cbs.remove.length + 1;
          rm &#x3D; createRmCb(ch.elm as Node, listeners);
          for (i &#x3D; 0; i &lt; cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i &#x3D; ch.data) &amp;&amp; isDef(i &#x3D; i.hook) &amp;&amp; isDef(i &#x3D; i.remove)) &#123;
            i(ch, rm);
          &#125; else &#123;
            rm();
          &#125;
        &#125; else &#123; &#x2F;&#x2F; Text node
          api.removeChild(parentElm, ch.elm as Node);
        &#125;
      &#125;
    &#125;
  &#125;

  function updateChildren(parentElm: Node,
                          oldCh: Array&lt;VNode&gt;,
                          newCh: Array&lt;VNode&gt;,
                          insertedVnodeQueue: VNodeQueue) &#123;
    let oldStartIdx &#x3D; 0, newStartIdx &#x3D; 0;
    let oldEndIdx &#x3D; oldCh.length - 1;
    let oldStartVnode &#x3D; oldCh[0];
    let oldEndVnode &#x3D; oldCh[oldEndIdx];
    let newEndIdx &#x3D; newCh.length - 1;
    let newStartVnode &#x3D; newCh[0];
    let newEndVnode &#x3D; newCh[newEndIdx];
    let oldKeyToIdx: any;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;
      if (oldStartVnode &#x3D;&#x3D; null) &#123;
        oldStartVnode &#x3D; oldCh[++oldStartIdx]; &#x2F;&#x2F; Vnode might have been moved left
      &#125; else if (oldEndVnode &#x3D;&#x3D; null) &#123;
        oldEndVnode &#x3D; oldCh[--oldEndIdx];
      &#125; else if (newStartVnode &#x3D;&#x3D; null) &#123;
        newStartVnode &#x3D; newCh[++newStartIdx];
      &#125; else if (newEndVnode &#x3D;&#x3D; null) &#123;
        newEndVnode &#x3D; newCh[--newEndIdx];
      &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode &#x3D; oldCh[++oldStartIdx];
        newStartVnode &#x3D; newCh[++newStartIdx];
      &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode &#x3D; oldCh[--oldEndIdx];
        newEndVnode &#x3D; newCh[--newEndIdx];
      &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node));
        oldStartVnode &#x3D; oldCh[++oldStartIdx];
        newEndVnode &#x3D; newCh[--newEndIdx];
      &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node);
        oldEndVnode &#x3D; oldCh[--oldEndIdx];
        newStartVnode &#x3D; newCh[++newStartIdx];
      &#125; else &#123;
        if (oldKeyToIdx &#x3D;&#x3D;&#x3D; undefined) &#123;
          oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        &#125;
        idxInOld &#x3D; oldKeyToIdx[newStartVnode.key as string];
        if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          newStartVnode &#x3D; newCh[++newStartIdx];
        &#125; else &#123;
          elmToMove &#x3D; oldCh[idxInOld];
          if (elmToMove.sel !&#x3D;&#x3D; newStartVnode.sel) &#123;
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          &#125; else &#123;
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] &#x3D; undefined as any;
            api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node);
          &#125;
          newStartVnode &#x3D; newCh[++newStartIdx];
        &#125;
      &#125;
    &#125;
    if (oldStartIdx &lt;&#x3D; oldEndIdx || newStartIdx &lt;&#x3D; newEndIdx) &#123;
      if (oldStartIdx &gt; oldEndIdx) &#123;
        before &#x3D; newCh[newEndIdx+1] &#x3D;&#x3D; null ? null : newCh[newEndIdx+1].elm;
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      &#125; else &#123;
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      &#125;
    &#125;
  &#125;

  function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) &#123;
    let i: any, hook: any;
    if (isDef(i &#x3D; vnode.data) &amp;&amp; isDef(hook &#x3D; i.hook) &amp;&amp; isDef(i &#x3D; hook.prepatch)) &#123;
      i(oldVnode, vnode);
    &#125;
    const elm &#x3D; vnode.elm &#x3D; (oldVnode.elm as Node);
    let oldCh &#x3D; oldVnode.children;
    let ch &#x3D; vnode.children;
    if (oldVnode &#x3D;&#x3D;&#x3D; vnode) return;
    if (vnode.data !&#x3D;&#x3D; undefined) &#123;
      for (i &#x3D; 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
      i &#x3D; vnode.data.hook;
      if (isDef(i) &amp;&amp; isDef(i &#x3D; i.update)) i(oldVnode, vnode);
    &#125;
    if (isUndef(vnode.text)) &#123;
      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;
        if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh as Array&lt;VNode&gt;, ch as Array&lt;VNode&gt;, insertedVnodeQueue);
      &#125; else if (isDef(ch)) &#123;
        if (isDef(oldVnode.text)) api.setTextContent(elm, &#39;&#39;);
        addVnodes(elm, null, ch as Array&lt;VNode&gt;, 0, (ch as Array&lt;VNode&gt;).length - 1, insertedVnodeQueue);
      &#125; else if (isDef(oldCh)) &#123;
        removeVnodes(elm, oldCh as Array&lt;VNode&gt;, 0, (oldCh as Array&lt;VNode&gt;).length - 1);
      &#125; else if (isDef(oldVnode.text)) &#123;
        api.setTextContent(elm, &#39;&#39;);
      &#125;
    &#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123;
      api.setTextContent(elm, vnode.text as string);
    &#125;
    if (isDef(hook) &amp;&amp; isDef(i &#x3D; hook.postpatch)) &#123;
      i(oldVnode, vnode);
    &#125;
  &#125;

  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode &#123;
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue &#x3D; [];
    for (i &#x3D; 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]();

    if (!isVnode(oldVnode)) &#123;
      oldVnode &#x3D; emptyNodeAt(oldVnode);
    &#125;

    if (sameVnode(oldVnode, vnode)) &#123;
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    &#125; else &#123;
      elm &#x3D; oldVnode.elm as Node;
      parent &#x3D; api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue);

      if (parent !&#x3D;&#x3D; null) &#123;
        api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      &#125;
    &#125;

    for (i &#x3D; 0; i &lt; insertedVnodeQueue.length; ++i) &#123;
      (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]);
    &#125;
    for (i &#x3D; 0; i &lt; cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  &#125;;
&#125;

patch 方法用来比较两个 VNode 树。

graph TD
subgraph patch
START[oldVnode, vnode] --&gt; B{&quot;isVnode(oldVnode)&lt;br&gt;判断 oldVnode 是否是 VNode&quot;}

B --&gt; |否: oldVnode 是 DOM 元素| D[将 DOM 元素转换成空的 VNode, 赋值给 oldVnode]

B --&gt; |是| C{&quot;sameVnode(oldVnode, vnode)&lt;br&gt;判断两 vnode 是否相同&lt;br&gt;(sel 与 key 均相同)&quot;}

D --&gt; C

C --&gt; |是| F[&quot;patchVnode(oldVnode, vnode, insertedVnodeQueue)&quot;]
C --&gt; |否| E[&quot;createElm(vnode, insertedVnodeQueue)&lt;br&gt;替换掉 DOM 中的元素&quot;]

F --&gt; G
E --&gt; G

G[&quot;对 insertedVnodeQueue 中的 VNode 分别执行 hook.insert&quot;]

G --&gt; END

END[&quot;返回 vnode&quot;]
end


这里需要留意 sameVnode 函数，当 key 与 sel 都相同时，变认为是同一 VNode。同一 VNode 会进行 patchVnode 操作；非同一 VNode 则会用新的 VNode 新创建 Element，删除旧的 VNode。

graph TD
subgraph patchVnode
START[&quot;oldVnode, vnode, insertedVnodeQueue&quot;] --&gt; B[&quot;hook.prepatch(oldVnode, vnode)&quot;]
B --&gt; D[&quot;elm &#x3D; vnode.elm &#x3D; oldVnode.elm&quot;]
D --&gt; E{&quot;oldVnode, vnode 是否同一对象&quot;}
E --&gt; |是| G[不做处理]
E --&gt; |否| F{&quot;vnode 是否有 data 属性&quot;}
F --&gt; |有| H[&quot;对 oldVnode, vnode 应用各 hook.update&quot;]
F --&gt; |无| I{&quot;vnode 是否有 text 属性&quot;}
H --&gt; I
I --&gt; |&quot;有 - vnode 文字节点&quot;| J[&quot;为 vnode.elm 设置 textContent&quot;]
J --&gt; END

I --&gt; |无 - vnode 元素节点| K{&quot;判断 oldVnode, vnode 的 children 的情况&quot;}
K --&gt; |都有 children 且不相同| L[&quot;执行 updateChildren&quot;]
K --&gt; |只有 vnode 有 children| N[&quot;在 elm 下创建 children 的 DOM 元素&quot;]
K --&gt; |只有 oldVnode 有 children| M[&quot;移除 elm 所有子 VNode&quot;]
K --&gt; |oldVnode 是文字节点| O[&quot;elm 的 textContent 设为空字符串&quot;]
L --&gt; END
M --&gt; END
N --&gt; END
O --&gt; END
END[&quot;hook.postpatch(oldVnode, vnode)&quot;]
end


patchVnode 中先判断两 VNode 是否为同一对象（引用相同），是则不需要修改；然后进行必要的 update hook；再判断 nodeType 类别，children 有无执行不同操作。

graph TD
subgraph createElm
START[&quot;vnode, insertedVnodeQueue&quot;] --&gt; B[&quot;hook.init(vnode)&quot;]
B --&gt; C{&quot;nodeType&quot;}
C --&gt; |&quot;其他(text 文本节点)&quot;| D[&quot;createTextNode(vnode.text)&quot;]
C --&gt; |&quot;element 元素节点&quot;| E[&quot;从 vnode.sel 中提出 tag, class, id&quot;]
C --&gt; |&quot;comment 注释节点&quot;| F[&quot;createComment(vnode.text)&quot;]

E --&gt; G[&quot;createElement(tag) 或 createElementNS(ns, tag)&quot;]
G --&gt; H[&quot;设置 class, id 到 vnode.elm&quot;]
H --&gt; I[&quot;cbs.create[i](emptyNode, vnode)&quot;]
I --&gt; J{&quot;是否有children&quot;}
J --&gt; |有| K[&quot;appendChild(elm, createElm(child, insertedVnodeQueue))&quot;]
K --&gt; M[&quot;hook.create(emptyNode, vnode)&quot;]
M --&gt; N[&quot;insertedVnodeQueue.push(vnode);&quot;]
J --&gt; |无| L[&quot;appendChild(elm, createTextNode(vnode.text))&quot;]

N --&gt; END
L --&gt; END
D --&gt; END
F --&gt; END
END[&quot;return vnode.elm&quot;]
end

]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>VNode</tag>
        <tag>图解</tag>
      </tags>
  </entry>
</search>
